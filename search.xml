<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>linuxday1基本命令</title>
    <url>/2021/11/03/linuxday1/</url>
    <content><![CDATA[<p>一、基本命令<br>1.1 关机和重启<br>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p>
<p>1.2 帮助命令<br>–help命令<br>  shutdown –help：<br>  ifconfig  –help：查看网卡信息</p>
<p>man命令（命令说明书）<br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p>
<p>二、目录操作命令<br>2.1 目录切换 cd<br>命令：cd 目录</p>
<p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p>
<p>2.2 目录查看 ls [-al]<br>命令：ls [-al]</p>
<p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr<br>ls -d        仅列出目录本身，而不列出目录内的文件数据<br>ls  -i         显示出inode<br>2.3 目录操作【增，删，改，查】<br>2.3.1 创建目录【增】 mkdir<br>命令：mkdir 目录</p>
<p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录<br>rmdir    删除一个空目录<br>2.3.2 删除目录或文件【删】rm<br>命令：rm [-rf] 目录</p>
<p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p>
<p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p>
<p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p>
<p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</p>
<p>2.3.3 目录修改【改】mv 和 cp<br>一、重命名目录<br>    命令：mv 当前目录  新目录<br>    例如：mv aaa bbb    将目录aaa改为bbb<br>    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</p>
<p>二、剪切目录<br>    命令：mv 目录名称 目录的新位置<br>    示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面     mv /usr/tmp/aaa /usr<br>    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p>
<p>三、拷贝目录<br>    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归<br>    示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面     cp /usr/tmp/aaa  /usr<br>    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</p>
<p>2.3.4 搜索目录【查】find<br>命令：find 目录 参数 文件名称<br>示例：find /usr/tmp -name ‘a*’    查找/usr/tmp目录下的所有以a开头的目录或文件<br>(1)-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写<br>(2)-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。<br>(3)-type c : 文件类型是 c 的文件。 d: 目录   f: 一般文件<br>(4)-atime n : 在过去n天内被读取过的文件<br>(5)-cmin n : 在过去 n 分钟内被修改过<br>三、文件操作命令<br>3.1 文件操作【增，删，改，查】<br>3.1.1 新建文件【增】touch<br>命令：touch 文件名<br>示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</p>
<p>3.1.2 删除文件 【删】 rm<br>命令：rm -rf 文件名</p>
<p>3.1.3 修改文件【改】 vi或vim<br>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p>
<ol>
<li>命令行模式command mode）<br>   控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>   命令行模式下的常用命令：<br>   【1】控制光标移动：↑，↓，j<br>   【2】删除当前行：dd<br>   【3】查找：/字符<br>   【4】进入编辑模式：i o a<br>   【5】进入底行模式：:</li>
<li>编辑模式（Insert mode）<br>   只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>   编辑模式下常用命令：<br>   【1】ESC 退出编辑模式到命令行模式；</li>
<li>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：<br>  【1】退出编辑：   :q<br>  【2】强制退出：   :q!<br>  【3】保存并退出：  :wq</li>
</ol>
<p>打开文件</p>
<p>命令：vi 文件名<br>示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</p>
<p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</p>
<p>编辑文件</p>
<p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p>
<p>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p>
<p>保存或者取消编辑</p>
<p>保存文件：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑</p>
<p>取消编辑：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p>
<p>3.1.4 文件的查看【查】<br>文件的查看命令：cat   /more/less/tail</p>
<p>cat：看最后一屏</p>
<p>-n 打印出行号</p>
<p>示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容<br>cat sudo.conf<br>列：检查红帽发行信息  cat  /etc/redhat-release<br>列出内核版本：  uname  -r<br>查看cpu  lscpu<br>检查内存大小： cat  /proc/meminfo</p>
<p>more：百分比显示，可翻页查看</p>
<p>示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>more sudo.conf</p>
<p>less：翻页查看</p>
<p>示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>less sudo.conf</p>
<p>head  ：命令可用于查看文件的开头部分的内容<br>tail：命令可以用于查看文件的后面部分的内容<br>示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束<br>tail -10 sudo.conf</p>
<p>3.2 权限修改<br>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>
<p>示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是-rw——-</p>
<p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限</p>
<p>   421  421  421</p>
<ul>
<li> rw-   —     —</li>
</ul>
<p>命令：chmod +x aaa.txt或者采用8421法命令：chmod 100 aaa.txt<br>chown  修改属主和属组<br>chattr  配置文件隐藏属性<br>lsattr    查看文件隐藏属性<br>特殊权限：<br>（1）SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。<br>举一个例子，我们都知道，Linux 系统中所有用户的密码数据都记录在 /etc/shadow 这个文件中，通过 ll /etc/shadow 命令可以看到，此文件的权限是 0（———），也就是说，普通用户对此文件没有任何操作权限。<br>（2）SGID用户在执行具有 SGID 权限的可执行文件时，用户的群组身份会变为文件所属群组<br>  (3)  SBIT  SBIT 权限仅对目录有效，一旦目录设定了 SBIT 权限，则用户在此目录下创建的文件或目录，就只有自己和 root 才有权利修改或删除该文件</p>
<p>四、压缩文件操作<br>4.1 打包和压缩<br>Windows的压缩文件的扩展名  .zip/.rar<br>linux中的打包文件：aa.tar<br>linux中的压缩文件：bb.gz<br>linux中打包并压缩的文件：.tar.gz<br>•    tar    -zcf 备份文件.tar.gz 文档….<br>•    tar    -jcf 备份文件.tar.bz2 文档….<br>•    tar   -Jcf 备份文件.tar.xz 文档….</p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>
<p>命令：tar -zcvf 打包压缩后的文件名 要打包的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名</p>
<p>示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar<br>tar -zcvf ab.tar aa.txt bb.txt<br>或：tar -zcvf ab.tar  *<br>•    tar -tf 备份文件<br>4.2 解压<br>命令：tar [-zxvf] 压缩文件<br>其中：x：代表解压<br>示例：将/usr/tmp 下的ab.tar解压到当前目录下</p>
<p>五、查找命令<br>5.1 grep<br>grep命令是一种强大的文本搜索工具</p>
<p>使用实例：</p>
<p>ps -ef | grep sshd  查找指定ssh服务进程 ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 ps -ef | grep sshd -c 查找指定进程个数<br>5.2 find<br>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p>
<p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>5.3 locate<br>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。如果数据库中没有查询的数据，则会报出locate: can not stat () `/var/lib/mlocate/mlocate.db’: No such file or directory该错误！updatedb即可！</p>
<p>yum -y install mlocate 如果是精简版CentOS系统需要安装locate命令</p>
<p>使用实例：</p>
<p>updatedblocate /etc/sh 搜索etc目录下所有以sh开头的文件 locate pwd 查找和pwd相关的所有文件<br>5.4 whereis<br>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p>
<p>使用实例：</p>
<p>whereis ls    将和ls文件相关的文件都查找出来<br>5.5 which  （查找命令的路径）<br>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p>使用实例：</p>
<p>which pwd  查找pwd命令所在路径 which java  查找path中java的路径 </p>
<p>观察文件类型：file<br>file    /usr/bin/passwd<br>六、su、sudo<br>6.1 su<br>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。<br>九、定时任务指令crontab 配置  （date查看时间）<br>crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。</p>
<p>crontab安装： yum install crontabs<br>1）确保系统服务crond可用</p>
<ol>
<li>systemctl restart crond    重启</li>
<li> systemctl enable crond   开机自启</li>
<li>1 命令格式<br>crontab [-u user] file</li>
</ol>
<p>crontab [-u user] [ -e | -l | -r ]</p>
<p>参数说明：</p>
<p>-u user：用来设定某个用户的crontab服务   列如：为用户natasha添加计划任务</p>
<ol>
<li> crontab **-**e **-**u natasha</li>
</ol>
<p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件</p>
<p>并载入crontab。</p>
<p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前</p>
<p>用户的crontab文件。</p>
<p>-l：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前</p>
<p>用户的crontab文件内容。</p>
<p>-r：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab</p>
<p>文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>9.2 配置说明、实例<br>命令：*   *    *   *   *   command  </p>
<p>解释：分  时  日  月  周  命令</p>
<p>第1列表示分钟1～59 每分钟用*或者 */1表示    </p>
<p>第2列表示小时0～23（0表示0点）</p>
<p>第3列表示日期1～31  </p>
<p>第4列表示月份1～12  </p>
<p>第5列标识号星期0～6（0表示星期天）<br>tail  /var/log/cron  查看日志</p>
<p>vim  /etc/crontab   计划任务配置文件</p>
<p>第6列要运行的命令<br>十、其他命令<br>10.1 查看当前目录：pwd<br>命令：pwd     查看当前目录路径</p>
<p>10.2 查看进程：ps -ef<br>命令：ps -ef    查看所有正在运行的进程</p>
<p>10.3 结束进程：kill<br>命令：kill pid 或者 kill -9 pid(强制杀死进程)           pid:进程号</p>
<p>10.4 网络通信命令：<br>ifconfig：查看网卡信息</p>
<p>命令：ifconfig 或 ifconfig | more</p>
<p>ping：查看与某台机器的连接情况</p>
<p>命令：ping ip</p>
<p>netstat -an：查看当前系统端口</p>
<p>命令：netstat -an</p>
<p>搜索指定端口<br>命令：netstat -an | grep 8080</p>
<p>10.5 配置网络<br>命令：setup</p>
<p>10.6 重启网络<br>命令：service network restart</p>
<p>10.7 切换用户<br>命令：su - 用户名</p>
<p>10.8 关闭防火墙<br>命令：chkconfig iptables off</p>
<p>10.9 清屏<br>命令：ctrl + l</p>
<p>10.11 vi模式下快捷键<br>esc后:</p>
<p>保存并退出快捷键：shift+z+z</p>
<p>光标跳到最后一行快捷键：shift+g</p>
<p>删除一行：dd</p>
<p>复制一行内容：y+y</p>
<p>粘贴复制的内容：p<br>显示目前所支持的语系 locale<br>locale </p>
<p>lsblk  磁盘<br>df  -h  将容量结果显示出来</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday10Linux的补充知识</title>
    <url>/2021/11/13/linuxday10/</url>
    <content><![CDATA[<p>一。linux的安装</p>
<p>安装VMware Workstation Pro<br>激活码：VMware 10 永久许可证激活密钥<br>JC05J-6U304-2Z1X9-GVAQP-CCUJ1<br>NC6H9-FLJ03-LZMK9-RC8Q2-AAX05<br>JA6HR-2TL15-EZPG9-GKAE0-3352F<br>M109C-N0J5L-08J8A-02ARP-CE64F<br>4F207-8HJ1M-WZCP8-000N0-92Q6G<br>0A6Z5-8H1EJ-WZCL1-PK072-23DJG<br>0F0Q9-8F38L-RZXT9-4U054-ACW5F<br>JA02E-09H47-QZD81-W3A52-A3014<br>4F2AG-A0HEJ-JZWH8-L01N6-8C3Q3<br>===================================<br>VMware 12 Pro 永久许可证激活密钥<br>5A02H-AU243-TZJ49-GTC7K-3C61N<br>VF5XA-FNDDJ-085GZ-4NXZ9-N20E6<br>UC5MR-8NE16-H81WY-R7QGV-QG2D8<br>ZG1WH-ATY96-H80QP-X7PEX-Y30V4<br>AA3E0-0VDE1-0893Z-KGZ59-QGAVF<br>===================================<br>VMware 14 Pro 永久许可证激活密钥<br>FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA<br>CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD<br>===================================<br>VMware 15 Pro 永久许可证激活密钥<br>VF5WH-00ZDH-489KP-0QNXG-WZKRA<br>AA310-6UX0J-H8D1Z-C4ZXZ-MPAD0<br>镜像光盘：CentOS-7.5-x86_64-DVD-1804<br>1 案例1：装机预备技能<br>1.1 问题</p>
<ol>
<li>   RHEL与CentOS系统有什么关联？</li>
<li>   Linux系统中第三块SCSI硬盘如何表示？</li>
<li></li>
<li>2 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：RHEL系统与CentOS系统的渊源<br>RHEL是红帽公司提供的商业版Linux系统，若要获取DVD镜像、安全更新等技术服务支持，一般需要付费订阅；不过构成RHEL系统的各种软件包都是基于GPL开源协议免费发布的。<br>CentOS是一个社区性质的Linux系统，相当于RHEL的一个克隆版本，它采用了构成RHEL系统的各种软件包重新组装、开发而成，并且在此过程中做了一些优化、必要的Bug修复；CentOS系统的版本会稍晚于同版本的RHEL系统发布，其构成、管理方式与同版本的RHEL系统几乎一模一样，而且能够找到大量开放的软件源，因此受到很多企业的欢迎。<br>目前，CentOS已经被Red Hat公司所收购，仍然可自由使用。<br>步骤二：Linux系统中第三块SCSI硬盘如何表示？<br>在Linux系统中，第三块SCSI硬盘如何表示利用/dev/sdc表示<br>2 案例2：安装一台LINUX虚拟机</li>
<li>1 问题<br>基于KVM虚拟机环境新安装一各LINUX操作系统，主要完成以下事项：</li>
<li>   新建一台虚拟机，硬盘20GB，内存2GB</li>
<li>   为此虚拟机安装LINUX操作系统，采取自动分区方案</li>
<li>   软件包定制（根据课上要求选取）</li>
<li>2 方案<br>在虚拟机环境练习装机过程，打开VMware虚拟化的图形管理程序（如图-1所示），添加一台虚拟机，将LINUX系统的ISO镜像文件作为此虚拟机的安装光盘。</li>
</ol>
<p>图-1<br>2.3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：新建一台LINUX虚拟机<br>1）启动“新建虚拟机”向导程序<br>安装方式选择“自定义”（如图-2所示），单击“下一步”。<br>/<br>图-2<br>2）VMware软件虚拟功能介绍（如图-3所示），单击“下一步“。<br>/<br>图－3<br>3）选择稍后安装操作系统（如图-4所示），单击“下一步”。</p>
<p>图－4<br>4）指定虚拟机操作系统版本（如图-5所示），单击“下一步”。</p>
<p>图－5<br>5）指定虚拟机名称与存放位置，（如图-6所示）单击“下一步”。</p>
<p>图－6<br>7）指定CPU参数默认即可，（如图-7所示）单击“下一步”。</p>
<p>图-7<br>8）指定内存大小建议2G，（如图-8所示）单击“下一步”。</p>
<p>图-8<br>9）指定网络类型默认即可，（如图-9所示）单击“下一步”。</p>
<p>图-9<br>10）指定控制器类型默认即可，（如图-10所示）单击“下一步”。</p>
<p>图-10<br>11）指定控制器类型默认即可，（如图-11所示）单击“下一步”。</p>
<p>图-11<br>12）创建虚拟磁盘默认即可，（如图-12所示）单击“下一步”。</p>
<p>图-12<br>13）指定虚拟磁盘大小建议20G，（如图-13所示）单击“下一步”。</p>
<p>图-13<br>13）指定虚拟磁盘文件名称默认即可，（如图-14所示）单击“下一步”。</p>
<p>图-14<br>14）虚拟机建立完成，（如图-15所示）单击“完成”。</p>
<p>图-15<br>步骤二：启动虚拟机电源，安装Linux系统<br>1）运行Linux安装程序<br>打开新虚拟机的电源后，会自动从光盘引导主机（因为新磁盘没有引导信息，自动找其他启动设备），进入CentOS系统的安装选择界面。按上箭头键选择第一项“Install CentOS 7”（如图-16所示），然后按Enter键启动安装程序。</p>
<p>图－16<br>2）选择语言类型<br>建议初学者选择“简体中文（中国）”以降低难度（如图-17所示），单击“继续”。</p>
<p>图－17<br>3）自定义磁盘分区方案<br>在“安装信息摘要”的列表界面中，单击“系统”–&gt;“安装位置”（如图-18所示）。</p>
<p>图－18<br>打开“安装目标位置”界面以后，选择“安装位置”下的“自动配置分区” （如图-19所示），单击上方的“完成”按钮。</p>
<p>图-19<br>4）选择要安装的软件包<br>单击“安装信息摘要”界面中的“软件选择”接下来在“基本环境”下选取“带GUI的服务器”（如图-20所示），单击“完成”按钮返回。</p>
<p>图－20<br>5）确认并开始安装<br>检查“安装信息摘要界面”，确保所有带叹号的部分都已经完成，然后单击右下方的“开始安装”按钮（如图-21所示），将会执行正式安装。</p>
<p>图－21<br>在安装执行期间，根据页面提示（如图-22所示）单击“ROOT密码”后为root用户设置一个密码（注意：若密码太简单需要按两次“完成”按钮！！），无需创建其他用户。</p>
<p>图-22<br>设置好密码以后，只要等待安装结束就行了（如图-23所示）。根据系统性能及选取的软件包不同，安装过程一般需要5~30分钟。</p>
<p>图-23<br>6）结束安装过程<br>全部安装执行完毕后，会提示重启主机（如图-24所示），根据提示操作即可。</p>
<p>图－24<br>步骤三：初始化配置<br>完成LINUX系统的安装过程后，第一次启动时会要求进行初始化设置。<br>1）确认许可协议,如图-25与图-26所示，点击“完成”</p>
<p>图-25</p>
<p>图-26<br>2）选择“完成配置”（如图-27所示）。</p>
<p>图-27<br>3）选择语言，如图-28所示，点击“前进”</p>
<p>图-28<br>4）选择“语言输入”，建议选择“汉语pinyin” （如图-29所示）</p>
<p>图-29<br>5）隐私如图-30所示，点击“前进”<br>/<br>图-30<br>6）时区如图-31所示，选择“上海”<br>/<br>图-32<br>7）在线账号如图-33所示，选择“跳过”<br>/<br>图-33<br>8）创建用户如图-34所示<br>/<br>图-34<br>9）完成用户密码设置如图-35所示<br>/<br>图-35<br>接下来只要单击“开始使用”即可</p>
<p>图-36<br>自动登入（以后登录时需要提供密码）到桌面环境（如图-37所示）。</p>
<p>图-38<br>至此，整个LINUX虚拟机系统的安装就完成了。<br>3 案例3：使用LINUX图形桌面<br>3.1 问题<br>本例要求学员熟悉新装LINUX系统的图形桌面环境，完成下列任务：</p>
<ol>
<li>   更改桌面背景图片</li>
<li>   打开应用程序 “Firefox Web Browser”</li>
<li>   添加一个普通用户账号（4参考自己姓名的拼音）</li>
<li>   注销，换新用户登录</li>
<li>   重启此系统</li>
<li>2 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：以root用户登入到图形桌面<br>将新装的LINUX系统关机、重新开机，启动完毕会看到登录界面（如图-39所示）。</li>
</ol>
<p>图-39<br>单击展示的用户列表下方的“未列出？”，然后根据提示输入管理员用户名root（如图-40所示），单击“下一步”。</p>
<p>图-40<br>接下来再根据提示输入root用户的正确口令（如图-41所示），单击“登录”按钮即成功进入图形桌面环境。</p>
<p>图-41<br>步骤二：完成简单的桌面操作<br>1）更改桌面背景图片<br>在桌面空白处右击，选择“更改桌面背景”，在弹出的对话框中单击“背景”并选取自己所喜爱的图片即可（如图-42所示）；如果需要更改锁屏图片，可以单击旁边的“锁屏”去选择。</p>
<p>图-42<br>2）打开Firefox网页浏览器<br>单击桌面菜单组“应用程序”–&gt;“互联网”–&gt;“Firefox Web Browser”（如图-43所示），可以打开火狐网页浏览器程序。</p>
<p>图-43<br>3）添加一个普通用户账号（参考自己姓名的拼音）<br>单击桌面菜单组“应用程序”–&gt;“系统工具”–&gt;“设置”（如图-44所示），可以打开系统设置平台。</p>
<p>图-44<br>点击“详细信息”（如图-45所示）。</p>
<p>图-46<br>然后点击“用户”管理窗口后，可以通过右上方的按钮来添加用户账号。根据自己的姓名拟定一个用户名，添加此账号即可（如图-47所示）。</p>
<p>图-47<br>4）注销，换新用户登录<br>单击桌面右上角的电源按钮，在弹出窗口中展开用户右侧的下拉列表，根据需要选择“切换用户”或者“注销”（如图-48所示）。</p>
<p>图-48<br>5）重启此系统<br>单击桌面右上角的电源按钮，在弹出窗口中再单击右下的电源标识（如图-49所示）。</p>
<p>图-49<br>接下来会提示操作类型，根据需要选择“取消”、“重启”、“关机”即可（如图-50所示）。</p>
<p>图-50<br>4 案例4：Linux命令行基本操作<br>4.1 问题<br>本例要求熟悉新装LINUX系统中命令行界面的获取方法，并通过命令行完成下列任务：</p>
<ol>
<li>   查看内核版本、主机名、IP/MAC地址</li>
<li>   查看CPU型号/频率、内存大小</li>
<li>   切换到根目录，确认当前位置、列出有哪些子目录</li>
<li>   返回到 /root 目录，确认当前位置</li>
<li>   重启当前系统</li>
<li>2 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：获取命令行界面的不同方法<br>1）虚拟控制台切换<br>LINUX系统默认提供6个虚拟控制台（tty1<del>tty6），每个控制台可以独立登录、执行不同的任务。其中tty1默认开启图形桌面，tty2</del>tty6只开启字符模式。<br>通过组合快捷键Ctrl+Alt+Fn可以在不同的虚拟控制台之间切换，这里的Fn代表F1~F6键中的某一个。例如，当处在正常的图形桌面时，按Ctrl+Alt+F3组合键可以切换到控制台tty3，登录后即进入纯字符模式的命令行界面；如果需要返回之前的图形桌面，则再按键Ctrl+Alt+F1组合键即可。<br>2）桌面右键菜单<br>在桌面空白处右击，或者通过资源管理器浏览文件夹时在空白处右击，可以看到右键菜单中出现“在终端中打开”项（如图-51所示）。</li>
</ol>
<p>图-51<br>单击“在终端中打开”项即可获得以图形窗口展现的命令行终端程序（如图-52所示）。</p>
<p>图-52<br>3）“应用程序”相应菜单<br>通过桌面菜单组“应用程序”–&gt;“工具”–&gt;“终端”，也可以打开以图形窗口展现的命令行终端程序（如图-53所示）。</p>
<p>步骤二：简单命令行操作练习<br>1）查看内核版本、主机名、IP/MAC地址<br>检查红帽发行信息：</p>
<ol>
<li>   [root@svr7 桌面]# cat /etc/redhat-release </li>
<li>   Red Hat Enterprise Linux Server release 7.5 (Maipo)<br>列出内核版本：</li>
<li>   [root@svr7 桌面]# uname -r</li>
<li>   3.10.0-327.el7.x86_64<br>2）查看CPU型号/频率、内存大小<br>列出CPU处理器信息：</li>
<li>   [root@svr7 桌面]# lscpu</li>
<li>   Architecture:          x86_64 </li>
<li>   CPU op-mode(s):        32-bit, 64-bit</li>
<li>   Byte Order:            Little Endian</li>
<li>   CPU(s):                1</li>
<li>   On-line CPU(s) list:   0</li>
<li>   Thread(s) per core:    1</li>
<li>   Core(s) per socket:    1</li>
<li>   座：                 1</li>
<li>   NUMA 节点：         1</li>
<li>   厂商 ID：           GenuineIntel </li>
<li>   CPU 系列：          6</li>
<li>   型号：              13</li>
<li>   型号名称：        QEMU Virtual CPU version (cpu64-rhel6)</li>
<li>   步进：              3</li>
<li>   CPU MHz：             2693.762</li>
<li>   BogoMIPS：            5387.52</li>
<li>   超管理器厂商：  KVM</li>
<li>   虚拟化类型：     完全</li>
<li>   L1d 缓存：          32K</li>
<li>   L1i 缓存：          32K</li>
<li>   L2 缓存：           4096K</li>
<li>   NUMA 节点0 CPU：    0<br>检查内存大小、空闲情况</li>
<li>   [root@svr7 桌面]# cat /proc/meminfo </li>
<li>   MemTotal:        1016904 kB</li>
<li>   MemFree:          245364 kB</li>
<li>   MemAvailable:     566664 kB</li>
<li>   Buffers:            2116 kB</li>
<li>   Cached:           417372 kB</li>
<li>   SwapCached:            0 kB</li>
<li>   Active:           267272 kB</li>
<li>   Inactive:         381760 kB</li>
<li>   .. ..<br>3）切换到根目录，确认当前位置、列出有哪些子目录<br>切换目录、确认当前位置：</li>
<li>   [root@svr7 桌面]# cd  /</li>
<li>   [root@svr7 /]# pwd</li>
<li>   /<br>4）返回到 /root 目录，确认当前位置</li>
<li>   [root@svr7 /]# cd  /root</li>
<li>   [root@svr7 ~]# pwd</li>
<li>   /root<br>5）重启当前系统</li>
<li>   [root@svr7 ~]# reboot</li>
<li>   .. ..</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linuxday12</title>
    <url>/2022/01/04/linuxday12/</url>
    <content><![CDATA[<p>第3篇：常见的Webshell查杀工具<br>目前市场上的很多主机安全产品也都提供这种WebShell<br>检测能力，比如阿里云、青藤云、safedog等<br>1、diff命令<br>在linux中，我们经常使用diff来比较两个文本文件的差异。同样，我们可以通过一行命令快速找出两个项目文件的差<br>异。<br>diff -c -a -r cms1 cms2<br>2、版本控制工具<br>版本控制工具，比如说git，重新上传代码到git，add+commit+push，然后打开项目，点击commits，在历史提交版本<br>里面，查看文件更改内容，很容易就可以发现代码被篡改的地方了。<br>3、文件对比工具<br>关键词：代码对比工具，你会找到很多好用的工具，这里我们推荐两款效果还不错的工具，Beyond Compare和<br>WinMerge。<br>第二章：日志分析篇<br>Linux日志分析<br>日志默认存放位置：/var/log/<br>查看日志配置情况：more /etc/rsyslog.conf<br>比较重要的几个日志： 登录失败记录：/var/log/btmp //lastb 最后一次登录：/var/log/lastlog //lastlog 登录成功记录:<br>/var/log/wtmp //last 登录日志记录：/var/log/secure<br>日志分析技巧<br>A、常用的shell命令<br>Linux下常用的shell命令如：find、grep 、egrep、awk、sed</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday5日志</title>
    <url>/2021/11/07/linuxday5/</url>
    <content><![CDATA[<p>一.日志文件的轮循（logrotate）<br>配置文件：/etc/logrotate.conf<br>                /etc/logrotate.d/<br>执行logrotate<br>logrotate  -v /etc/logrotate.conf<br>强制进行logrotate<br>logrotate  -vf  /etc/logrotate.conf</p>
<p>二.journalctl 查看登录信息<br>Journald使用journalctl工具读取日志  journalctl<br>2查看  2017-05-27 09:37:00 到  2017-05-27 10:47:00 之间日志<br> journalctl –since “2017-05-27 09:37:00” –until “2017-05-27 10:47:00”<br>3.查看重启的记录：journalctl –list-boots<br>4.查看上一次启动以来的日志，根据上面的记录，也可以选择其他重启以来的日志： journalctl -b -1<br>5.查看最新的日志： journalctl -r<br>6.查看严重等级为错误的日志 journalctl -p err<br>7.查看指定应用日志：journalctl -t sshd<br>8.显示最近前几行的日志 如：-n  5<br>9.-f 持续显示joural日志内容</p>
<p>三.logger命令的应用<br>使用 logger 工具，可以直接将信息传入到Journald中，-p 参数指定服务名称，和日志级别<br>logger -p user.info “log test with logger”</p>
<p>四.保存journal的方式<br>mkdir  /var/log/journal<br>chown  root:systemd-journal  /var/log/journal<br>chmod  2775  /var/log/journal<br>systemctl  restart    systemd-journald.service</p>
<p>五.分析日志文件<br>centos默认提供的logwatch<br>他会每天分析一次日志文件，然后通过email 的格式寄给root<br>1.安装<br>yum install /mnt/dvd/Packages/perl-5.*.rpm</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday2进程和selinux</title>
    <url>/2021/11/03/linuxday2/</url>
    <content><![CDATA[<p>一。任务管理 （job control）<br>1.&amp;  将命令丢到后台执行<br>2.ctrl+z 将当前命令丢到后台暂停<br>3.jobs 查看目前后台状态<br>4.fg j将后台的任务拿到前台处理：fg<br>5.bg 让后台的任务变成运行中<br>6.kill 管理后台的任务  -9 强制删除<br>7.nohup 让后台任务在你注销后还能执行， nohup 和&amp; 搭配<br>二。查看进程<br>1.ps aux 查看系统所有进程  ps  -lA  查看所有系统的进程   ps  -l 仅查看自己bash相关的进程<br>2.top 查看动态的进程<br>3.pstree 进程树<br>4priority（pri） 和nice ，pri越小执行的越早。当nice为负，那么该进程就会降低pri，即会变的优先处理<br>列： nice  -n  -5 vim &amp;<br>        renice -5  14836  （重新调整进程的nice）<br>三。查看系统资源信息<br>1.free（内存的使用情况）    -m  显示目前系统的内存容量<br>2.uname 查看系统与内核信息<br>uname -a 输出系统的基本信息   内核的版本<br>uptime 查看系统启动的时间和任务负载<br>netstat ：追踪网络和socket<br>*netstat   -tulnp  找出系统上监听的网络连接及pid<br>netstat  -lt   列出所有处于监听状态的tcp端口<br>*netstat  -tulnp | grep  8080 查看指定端口号的进程情况<br>lsof  -i：8080  查看某一端口的占用情况  （进程使用的文件）<br>dmesg  |  more  输出所有内核启动时的信息。（dmesg 分析内核产生的信息）<br>vmstat  检测系统资源变化<br>四。特殊文件和进程<br>1./proc/meminfo  (内存)<br>/proc/version  内核版本<br>2.fuser:借该文件找出正在使用该文件的进程<br>fuser -muv  /proc<br>3.pidof 找出执行进程的pid<br>五。selinux<br>查看系统【进程的selinux相关信息】<br>ps  -eZ<br>selinux 三种模式<br>1.enforcing   强制模式<br>2.permissive  宽松模式<br>3.disabled   关闭模式<br>setenforce  [0|1]   0宽松 1强制<br>getenforce  查看<br>4./etc/selinux/config 是selinux的配置文件<br>5.selinux各个规则的布尔值查询getsebool<br>查询本系统的所有的布尔值的设置情况<br>getsebool  -a     修改布尔值 ：  setsebool  【-p】  【规则名称】  【0|1】<br>6.seinfo  列出selinux在此策略下的统计状态，还有sesearch 是找出进程能读取文件selinux的类型<br>7.使用chcon手动修改（文件）的selinux类型<br>restorecon 恢复正确的selinux类型（文件）<br>semanage 默认目录的安全上下文查询和修改  -a 增加 -m 修改  -d 删除</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday3 systemctl和日志</title>
    <url>/2021/11/05/linuxday3/</url>
    <content><![CDATA[<p>一。实例：通过vsftp这个ftp服务器来读写系统上的文件、<br>1.先创建ftptest用户并设置密码<br>useradd  ftptest<br>echo  ”123“  | passwd  –stdin ftptest<br>2.安装vsftpd这个服务器软件，同时启动，并开机自启。<br>yum  install  /mnt/P{tab}/vsftpd-3*<br>systemctl  start  vsftpd<br>systemctl enable vsftpd<br>二。systemctl管理服务<br>systemctl  【命令】  【服务】<br>start 启动  stop 关闭  restart  重启  enable 开机自启  status 查看</p>
<p>systemctl   列出系统上面启动的unit（服务）</p>
<p>systemctl是 Systemd 的主命令，用于管理系统。</p>
<h1 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h1><p>$ sudo systemctl reboot</p>
<h1 id="关闭系统，切断电源"><a href="#关闭系统，切断电源" class="headerlink" title="关闭系统，切断电源"></a>关闭系统，切断电源</h1><p>$ sudo systemctl poweroff</p>
<h1 id="CPU停止工作"><a href="#CPU停止工作" class="headerlink" title="CPU停止工作"></a>CPU停止工作</h1><p>$ sudo systemctl halt</p>
<h1 id="暂停系统"><a href="#暂停系统" class="headerlink" title="暂停系统"></a>暂停系统</h1><p>$ sudo systemctl suspend</p>
<h1 id="让系统进入冬眠状态"><a href="#让系统进入冬眠状态" class="headerlink" title="让系统进入冬眠状态"></a>让系统进入冬眠状态</h1><p>$ sudo systemctl hibernate</p>
<h1 id="让系统进入交互式休眠状态"><a href="#让系统进入交互式休眠状态" class="headerlink" title="让系统进入交互式休眠状态"></a>让系统进入交互式休眠状态</h1><p>$ sudo systemctl hybrid-sleep</p>
<h1 id="启动进入救援状态（单用户状态）"><a href="#启动进入救援状态（单用户状态）" class="headerlink" title="启动进入救援状态（单用户状态）"></a>启动进入救援状态（单用户状态）</h1><p>$ sudo systemctl rescue<br>3.2 systemd-analyze<br>systemd-analyze命令用于查看启动耗时。</p>
<h1 id="查看启动耗时"><a href="#查看启动耗时" class="headerlink" title="查看启动耗时"></a>查看启动耗时</h1><p>$ systemd-analyze                                                                                       </p>
<h1 id="查看每个服务的启动耗时"><a href="#查看每个服务的启动耗时" class="headerlink" title="查看每个服务的启动耗时"></a>查看每个服务的启动耗时</h1><p>$ systemd-analyze blame</p>
<h1 id="显示瀑布状的启动过程流"><a href="#显示瀑布状的启动过程流" class="headerlink" title="显示瀑布状的启动过程流"></a>显示瀑布状的启动过程流</h1><p>$ systemd-analyze critical-chain</p>
<h1 id="显示指定服务的启动流"><a href="#显示指定服务的启动流" class="headerlink" title="显示指定服务的启动流"></a>显示指定服务的启动流</h1><p>$ systemd-analyze critical-chain atd.service<br> hostnamectl<br>hostnamectl命令用于查看当前主机的信息。</p>
<h1 id="显示当前主机的信息"><a href="#显示当前主机的信息" class="headerlink" title="显示当前主机的信息"></a>显示当前主机的信息</h1><p>$ hostnamectl</p>
<h1 id="设置主机名。"><a href="#设置主机名。" class="headerlink" title="设置主机名。"></a>设置主机名。</h1><p>$ sudo hostnamectl set-hostname rhel7<br>3.4 localectl<br>localectl命令用于查看本地化设置。</p>
<h1 id="查看本地化设置"><a href="#查看本地化设置" class="headerlink" title="查看本地化设置"></a>查看本地化设置</h1><p>$ localectl</p>
<h1 id="设置本地化参数。"><a href="#设置本地化参数。" class="headerlink" title="设置本地化参数。"></a>设置本地化参数。</h1><p>$ sudo localectl set-locale LANG=en_GB.utf8<br>$ sudo localectl set-keymap en_GB<br>3.5 timedatectl<br>timedatectl命令用于查看当前时区设置。</p>
<h1 id="查看当前时区设置"><a href="#查看当前时区设置" class="headerlink" title="查看当前时区设置"></a>查看当前时区设置</h1><p>$ timedatectl</p>
<h1 id="显示所有可用的时区"><a href="#显示所有可用的时区" class="headerlink" title="显示所有可用的时区"></a>显示所有可用的时区</h1><p>$ timedatectl list-timezones                                                                                   </p>
<h1 id="设置当前时区"><a href="#设置当前时区" class="headerlink" title="设置当前时区"></a>设置当前时区</h1><p>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br>3.6 loginctl<br>loginctl命令用于查看当前登录的用户。</p>
<h1 id="列出当前session"><a href="#列出当前session" class="headerlink" title="列出当前session"></a>列出当前session</h1><p>$ loginctl list-sessions</p>
<h1 id="列出当前登录用户"><a href="#列出当前登录用户" class="headerlink" title="列出当前登录用户"></a>列出当前登录用户</h1><p>$ loginctl list-users</p>
<h1 id="列出显示指定用户的信息"><a href="#列出显示指定用户的信息" class="headerlink" title="列出显示指定用户的信息"></a>列出显示指定用户的信息</h1><p>$ loginctl show-user ruanyf<br>四、Unit<br>4.1 含义<br>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<p>Unit 一共分成12种。</p>
<p>Service unit：系统服务<br>Target unit：多个 Unit 构成的一个组<br>Device Unit：硬件设备<br>Mount Unit：文件系统的挂载点<br>Automount Unit：自动挂载点<br>Path Unit：文件或路径<br>Scope Unit：不是由 Systemd 启动的外部进程<br>Slice Unit：进程组<br>Snapshot Unit：Systemd 快照，可以切回某个快照<br>Socket Unit：进程间通信的 socket<br>Swap Unit：swap 文件<br>Timer Unit：定时器<br>systemctl list-units命令可以查看当前系统的所有 Unit 。</p>
<h1 id="列出正在运行的-Unit"><a href="#列出正在运行的-Unit" class="headerlink" title="列出正在运行的 Unit"></a>列出正在运行的 Unit</h1><p>$ systemctl list-units</p>
<h1 id="列出所有Unit，包括没有找到配置文件的或者启动失败的"><a href="#列出所有Unit，包括没有找到配置文件的或者启动失败的" class="headerlink" title="列出所有Unit，包括没有找到配置文件的或者启动失败的"></a>列出所有Unit，包括没有找到配置文件的或者启动失败的</h1><p>$ systemctl list-units –all</p>
<h1 id="列出所有没有运行的-Unit"><a href="#列出所有没有运行的-Unit" class="headerlink" title="列出所有没有运行的 Unit"></a>列出所有没有运行的 Unit</h1><p>$ systemctl list-units –all –state=inactive</p>
<h1 id="列出所有加载失败的-Unit"><a href="#列出所有加载失败的-Unit" class="headerlink" title="列出所有加载失败的 Unit"></a>列出所有加载失败的 Unit</h1><p>$ systemctl list-units –failed</p>
<h1 id="列出所有正在运行的、类型为-service-的-Unit"><a href="#列出所有正在运行的、类型为-service-的-Unit" class="headerlink" title="列出所有正在运行的、类型为 service 的 Unit"></a>列出所有正在运行的、类型为 service 的 Unit</h1><p>$ systemctl list-units –type=service<br>4.2 Unit 的状态<br>systemctl status命令用于查看系统状态和单个 Unit 的状态。</p>
<h1 id="显示系统状态"><a href="#显示系统状态" class="headerlink" title="显示系统状态"></a>显示系统状态</h1><p>$ systemctl status</p>
<h1 id="显示单个-Unit-的状态"><a href="#显示单个-Unit-的状态" class="headerlink" title="显示单个 Unit 的状态"></a>显示单个 Unit 的状态</h1><p>$ sysystemctl status bluetooth.service</p>
<h1 id="显示远程主机的某个-Unit-的状态"><a href="#显示远程主机的某个-Unit-的状态" class="headerlink" title="显示远程主机的某个 Unit 的状态"></a>显示远程主机的某个 Unit 的状态</h1><p>$ systemctl -H <a href="mailto:&#x72;&#111;&#111;&#x74;&#x40;&#114;&#104;&#101;&#108;&#55;&#x2e;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x72;&#111;&#111;&#x74;&#x40;&#114;&#104;&#101;&#108;&#55;&#x2e;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a> status httpd.service<br>除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<h1 id="显示某个-Unit-是否正在运行"><a href="#显示某个-Unit-是否正在运行" class="headerlink" title="显示某个 Unit 是否正在运行"></a>显示某个 Unit 是否正在运行</h1><p>$ systemctl is-active application.service</p>
<h1 id="显示某个-Unit-是否处于启动失败状态"><a href="#显示某个-Unit-是否处于启动失败状态" class="headerlink" title="显示某个 Unit 是否处于启动失败状态"></a>显示某个 Unit 是否处于启动失败状态</h1><p>$ systemctl is-failed application.service</p>
<h1 id="显示某个-Unit-服务是否建立了启动链接"><a href="#显示某个-Unit-服务是否建立了启动链接" class="headerlink" title="显示某个 Unit 服务是否建立了启动链接"></a>显示某个 Unit 服务是否建立了启动链接</h1><p>$ systemctl is-enabled application.service<br>4.3 Unit 管理<br>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<h1 id="立即启动一个服务"><a href="#立即启动一个服务" class="headerlink" title="立即启动一个服务"></a>立即启动一个服务</h1><p>$ sudo systemctl start apache.service</p>
<h1 id="立即停止一个服务"><a href="#立即停止一个服务" class="headerlink" title="立即停止一个服务"></a>立即停止一个服务</h1><p>$ sudo systemctl stop apache.service</p>
<h1 id="重启一个服务"><a href="#重启一个服务" class="headerlink" title="重启一个服务"></a>重启一个服务</h1><p>$ sudo systemctl restart apache.service</p>
<h1 id="杀死一个服务的所有子进程"><a href="#杀死一个服务的所有子进程" class="headerlink" title="杀死一个服务的所有子进程"></a>杀死一个服务的所有子进程</h1><p>$ sudo systemctl kill apache.service</p>
<h1 id="重新加载一个服务的配置文件"><a href="#重新加载一个服务的配置文件" class="headerlink" title="重新加载一个服务的配置文件"></a>重新加载一个服务的配置文件</h1><p>$ sudo systemctl reload apache.service</p>
<h1 id="重载所有修改过的配置文件"><a href="#重载所有修改过的配置文件" class="headerlink" title="重载所有修改过的配置文件"></a>重载所有修改过的配置文件</h1><p>$ sudo systemctl daemon-reload</p>
<h1 id="显示某个-Unit-的所有底层参数"><a href="#显示某个-Unit-的所有底层参数" class="headerlink" title="显示某个 Unit 的所有底层参数"></a>显示某个 Unit 的所有底层参数</h1><p>$ systemctl show httpd.service</p>
<h1 id="显示某个-Unit-的指定属性的值"><a href="#显示某个-Unit-的指定属性的值" class="headerlink" title="显示某个 Unit 的指定属性的值"></a>显示某个 Unit 的指定属性的值</h1><p>$ systemctl show -p CPUShares httpd.service</p>
<h1 id="设置某个-Unit-的指定属性"><a href="#设置某个-Unit-的指定属性" class="headerlink" title="设置某个 Unit 的指定属性"></a>设置某个 Unit 的指定属性</h1><p>$ sudo systemctl set-property httpd.service CPUShares=500<br>4.4 依赖关系<br>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p>systemctl list-dependencies命令列出一个 Unit 的所有依赖。</p>
<p>$ systemctl list-dependencies nginx.service<br>上面命令的输出结果之中，有些依赖Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用–all参数。</p>
<p>$ systemctl list-dependencies –all nginx.service<br>五、Unit 的配置文件<br>5.1 概述<br>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>
<p>systemctl enable命令用于在上面两个目录之间，建立符号链接关系。<br>$ sudo systemctl enable <a href="mailto:&#99;&#x6c;&#x61;&#x6d;&#x64;&#x40;&#x73;&#99;&#x61;&#110;&#46;&#x73;&#x65;&#114;&#x76;&#x69;&#99;&#x65;">&#99;&#x6c;&#x61;&#x6d;&#x64;&#x40;&#x73;&#99;&#x61;&#110;&#46;&#x73;&#x65;&#114;&#x76;&#x69;&#99;&#x65;</a></p>
<h1 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于</h1><p>$ sudo ln -s ‘/usr/lib/systemd/system/<a href="mailto:&#99;&#108;&#97;&#109;&#x64;&#64;&#x73;&#99;&#97;&#110;&#x2e;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;">&#99;&#108;&#97;&#109;&#x64;&#64;&#x73;&#99;&#97;&#110;&#x2e;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;</a>‘ ‘/etc/systemd/system/multi-user.target.wants/<a href="mailto:&#x63;&#x6c;&#x61;&#109;&#100;&#64;&#115;&#x63;&#97;&#110;&#46;&#x73;&#101;&#x72;&#x76;&#x69;&#99;&#x65;">&#x63;&#x6c;&#x61;&#109;&#100;&#64;&#115;&#x63;&#97;&#110;&#46;&#x73;&#101;&#x72;&#x76;&#x69;&#99;&#x65;</a>‘<br>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p>
<p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<p>$ sudo systemctl disable <a href="mailto:&#99;&#108;&#x61;&#109;&#x64;&#64;&#x73;&#99;&#x61;&#x6e;&#x2e;&#x73;&#101;&#114;&#118;&#x69;&#99;&#x65;">&#99;&#108;&#x61;&#109;&#x64;&#64;&#x73;&#99;&#x61;&#x6e;&#x2e;&#x73;&#101;&#114;&#118;&#x69;&#99;&#x65;</a><br>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p>
<p>5.2 配置文件的状态<br>systemctl list-unit-files命令用于列出所有配置文件。</p>
<h1 id="列出所有配置文件"><a href="#列出所有配置文件" class="headerlink" title="列出所有配置文件"></a>列出所有配置文件</h1><p>$ systemctl list-unit-files</p>
<h1 id="列出指定类型的配置文件"><a href="#列出指定类型的配置文件" class="headerlink" title="列出指定类型的配置文件"></a>列出指定类型的配置文件</h1><p>$ systemctl list-unit-files –type=service<br>这个命令会输出一个列表。</p>
<p>$ systemctl list-unit-files</p>
<p>UNIT FILE              STATE<br>chronyd.service        enabled<br>clamd@.service         static<br><a href="mailto:&#99;&#x6c;&#x61;&#109;&#x64;&#x40;&#x73;&#x63;&#x61;&#110;&#46;&#115;&#101;&#114;&#x76;&#x69;&#99;&#101;">&#99;&#x6c;&#x61;&#109;&#x64;&#x40;&#x73;&#x63;&#x61;&#110;&#46;&#115;&#101;&#114;&#x76;&#x69;&#99;&#101;</a>     disabled<br>这个列表显示每个配置文件的状态，一共有四种。</p>
<p>enabled：已建立启动链接<br>disabled：没建立启动链接<br>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖<br>masked：该配置文件被禁止建立启动链接<br>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p>
<p>$ systemctl status bluetooth.service<br>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<p>$ sudo systemctl daemon-reload<br>$ sudo systemctl restart httpd.service<br>5.3 配置文件的格式<br>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p>systemctl cat命令可以查看配置文件的内容。</p>
<p>$ systemctl cat atd.service</p>
<p>[Unit]<br>Description=ATD daemon</p>
<p>[Service]<br>Type=forking<br>ExecStart=/usr/bin/atd</p>
<p>[Install]<br>WantedBy=multi-user.target<br>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<p>[Section]<br>Directive1=value<br>Directive2=value<br>. . .<br>注意，键值对的等号两侧不能有空格。</p>
<p>5.4 配置文件的区块<br>[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<p>Description：简短描述<br>Documentation：文档地址<br>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败<br>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败<br>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行<br>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动<br>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动<br>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行<br>Condition…：当前 Unit 运行必须满足的条件，否则不会运行<br>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败<br>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<p>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中<br>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中<br>Alias：当前 Unit 可用于启动的别名<br>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit<br>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<p>Type：定义启动时的进程行为。它有以下几种值。<br>Type=simple：默认值，执行ExecStart指定的命令，启动主进程<br>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出<br>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行<br>Type=dbus：当前服务通过D-Bus启动<br>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行<br>Type=idle：若有其他任务执行完毕，当前服务才会运行<br>ExecStart：启动当前服务的命令<br>ExecStartPre：启动当前服务之前执行的命令<br>ExecStartPost：启动当前服务之后执行的命令<br>ExecReload：重启当前服务时执行的命令<br>ExecStop：停止当前服务时执行的命令<br>ExecStopPost：停止当其服务之后执行的命令<br>RestartSec：自动重启当前服务间隔的秒数<br>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog<br>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数<br>Environment：指定环境变量<br>Unit 配置文件的完整字段清单，请参考官方文档。</p>
<p>六、Target<br>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<h1 id="查看当前系统的所有-Target"><a href="#查看当前系统的所有-Target" class="headerlink" title="查看当前系统的所有 Target"></a>查看当前系统的所有 Target</h1><p>$ systemctl list-unit-files –type=target</p>
<h1 id="查看一个-Target-包含的所有-Unit"><a href="#查看一个-Target-包含的所有-Unit" class="headerlink" title="查看一个 Target 包含的所有 Unit"></a>查看一个 Target 包含的所有 Unit</h1><p>$ systemctl list-dependencies multi-user.target</p>
<h1 id="查看启动时的默认-Target"><a href="#查看启动时的默认-Target" class="headerlink" title="查看启动时的默认 Target"></a>查看启动时的默认 Target</h1><p>$ systemctl get-default</p>
<h1 id="设置启动时的默认-Target"><a href="#设置启动时的默认-Target" class="headerlink" title="设置启动时的默认 Target"></a>设置启动时的默认 Target</h1><p>$ sudo systemctl set-default multi-user.target</p>
<h1 id="切换-Target-时，默认不关闭前一个-Target-启动的进程，"><a href="#切换-Target-时，默认不关闭前一个-Target-启动的进程，" class="headerlink" title="切换 Target 时，默认不关闭前一个 Target 启动的进程，"></a>切换 Target 时，默认不关闭前一个 Target 启动的进程，</h1><h1 id="systemctl-isolate-命令改变这种行为，"><a href="#systemctl-isolate-命令改变这种行为，" class="headerlink" title="systemctl isolate 命令改变这种行为，"></a>systemctl isolate 命令改变这种行为，</h1><h1 id="关闭前一个-Target-里面所有不属于后一个-Target-的进程"><a href="#关闭前一个-Target-里面所有不属于后一个-Target-的进程" class="headerlink" title="关闭前一个 Target 里面所有不属于后一个 Target 的进程"></a>关闭前一个 Target 里面所有不属于后一个 Target 的进程</h1><p>$ sudo systemctl isolate multi-user.target<br>Target 与 传统 RunLevel 的对应关系如下。</p>
<p>Traditional runlevel      New target name     Symbolically linked to…</p>
<p>Runlevel 0           |    runlevel0.target -&gt; poweroff.target<br>Runlevel 1           |    runlevel1.target -&gt; rescue.target<br>Runlevel 2           |    runlevel2.target -&gt; multi-user.target<br>Runlevel 3           |    runlevel3.target -&gt; multi-user.target<br>Runlevel 4           |    runlevel4.target -&gt; multi-user.target<br>Runlevel 5           |    runlevel5.target -&gt; graphical.target<br>Runlevel 6           |    runlevel6.target -&gt; reboot.target<br>它与init进程的主要差别如下。</p>
<p>（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p>
<p>（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</p>
<p>（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</p>
<p>七、日志管理<br>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p>
<p>journalctl功能强大，用法非常多。</p>
<h1 id="查看所有日志（默认情况下-，只保存本次启动的日志）"><a href="#查看所有日志（默认情况下-，只保存本次启动的日志）" class="headerlink" title="查看所有日志（默认情况下 ，只保存本次启动的日志）"></a>查看所有日志（默认情况下 ，只保存本次启动的日志）</h1><p>$ sudo journalctl</p>
<h1 id="查看内核日志（不显示应用日志）"><a href="#查看内核日志（不显示应用日志）" class="headerlink" title="查看内核日志（不显示应用日志）"></a>查看内核日志（不显示应用日志）</h1><p>$ sudo journalctl -k</p>
<h1 id="查看系统本次启动的日志"><a href="#查看系统本次启动的日志" class="headerlink" title="查看系统本次启动的日志"></a>查看系统本次启动的日志</h1><p>$ sudo journalctl -b<br>$ sudo journalctl -b -0</p>
<h1 id="查看上一次启动的日志（需更改设置）"><a href="#查看上一次启动的日志（需更改设置）" class="headerlink" title="查看上一次启动的日志（需更改设置）"></a>查看上一次启动的日志（需更改设置）</h1><p>$ sudo journalctl -b -1</p>
<h1 id="查看指定时间的日志"><a href="#查看指定时间的日志" class="headerlink" title="查看指定时间的日志"></a>查看指定时间的日志</h1><p>$ sudo journalctl –since=”2012-10-30 18:17:16”<br>$ sudo journalctl –since “20 min ago”<br>$ sudo journalctl –since yesterday<br>$ sudo journalctl –since “2015-01-10” –until “2015-01-11 03:00”<br>$ sudo journalctl –since 09:00 –until “1 hour ago”</p>
<h1 id="显示尾部的最新10行日志"><a href="#显示尾部的最新10行日志" class="headerlink" title="显示尾部的最新10行日志"></a>显示尾部的最新10行日志</h1><p>$ sudo journalctl -n</p>
<h1 id="显示尾部指定行数的日志"><a href="#显示尾部指定行数的日志" class="headerlink" title="显示尾部指定行数的日志"></a>显示尾部指定行数的日志</h1><p>$ sudo journalctl -n 20</p>
<h1 id="实时滚动显示最新日志"><a href="#实时滚动显示最新日志" class="headerlink" title="实时滚动显示最新日志"></a>实时滚动显示最新日志</h1><p>$ sudo journalctl -f</p>
<h1 id="查看指定服务的日志"><a href="#查看指定服务的日志" class="headerlink" title="查看指定服务的日志"></a>查看指定服务的日志</h1><p>$ sudo journalctl /usr/lib/systemd/systemd</p>
<h1 id="查看指定进程的日志"><a href="#查看指定进程的日志" class="headerlink" title="查看指定进程的日志"></a>查看指定进程的日志</h1><p>$ sudo journalctl _PID=1</p>
<h1 id="查看某个路径的脚本的日志"><a href="#查看某个路径的脚本的日志" class="headerlink" title="查看某个路径的脚本的日志"></a>查看某个路径的脚本的日志</h1><p>$ sudo journalctl /usr/bin/bash</p>
<h1 id="查看指定用户的日志"><a href="#查看指定用户的日志" class="headerlink" title="查看指定用户的日志"></a>查看指定用户的日志</h1><p>$ sudo journalctl _UID=33 –since today</p>
<h1 id="查看某个-Unit-的日志"><a href="#查看某个-Unit-的日志" class="headerlink" title="查看某个 Unit 的日志"></a>查看某个 Unit 的日志</h1><p>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service –since today</p>
<h1 id="实时滚动显示某个-Unit-的最新日志"><a href="#实时滚动显示某个-Unit-的最新日志" class="headerlink" title="实时滚动显示某个 Unit 的最新日志"></a>实时滚动显示某个 Unit 的最新日志</h1><p>$ sudo journalctl -u nginx.service -f</p>
<h1 id="合并显示多个-Unit-的日志"><a href="#合并显示多个-Unit-的日志" class="headerlink" title="合并显示多个 Unit 的日志"></a>合并显示多个 Unit 的日志</h1><p>$ journalctl -u nginx.service -u php-fpm.service –since today</p>
<h1 id="查看指定优先级（及其以上级别）的日志，共有8级"><a href="#查看指定优先级（及其以上级别）的日志，共有8级" class="headerlink" title="查看指定优先级（及其以上级别）的日志，共有8级"></a>查看指定优先级（及其以上级别）的日志，共有8级</h1><h1 id="0-emerg"><a href="#0-emerg" class="headerlink" title="0: emerg"></a>0: emerg</h1><h1 id="1-alert"><a href="#1-alert" class="headerlink" title="1: alert"></a>1: alert</h1><h1 id="2-crit"><a href="#2-crit" class="headerlink" title="2: crit"></a>2: crit</h1><h1 id="3-err"><a href="#3-err" class="headerlink" title="3: err"></a>3: err</h1><h1 id="4-warning"><a href="#4-warning" class="headerlink" title="4: warning"></a>4: warning</h1><h1 id="5-notice"><a href="#5-notice" class="headerlink" title="5: notice"></a>5: notice</h1><h1 id="6-info"><a href="#6-info" class="headerlink" title="6: info"></a>6: info</h1><h1 id="7-debug"><a href="#7-debug" class="headerlink" title="7: debug"></a>7: debug</h1><p>$ sudo journalctl -p err -b</p>
<h1 id="日志默认分页输出，–no-pager-改为正常的标准输出"><a href="#日志默认分页输出，–no-pager-改为正常的标准输出" class="headerlink" title="日志默认分页输出，–no-pager 改为正常的标准输出"></a>日志默认分页输出，–no-pager 改为正常的标准输出</h1><p>$ sudo journalctl –no-pager</p>
<h1 id="以-JSON-格式（单行）输出"><a href="#以-JSON-格式（单行）输出" class="headerlink" title="以 JSON 格式（单行）输出"></a>以 JSON 格式（单行）输出</h1><p>$ sudo journalctl -b -u nginx.service -o json</p>
<h1 id="以-JSON-格式（多行）输出，可读性更好"><a href="#以-JSON-格式（多行）输出，可读性更好" class="headerlink" title="以 JSON 格式（多行）输出，可读性更好"></a>以 JSON 格式（多行）输出，可读性更好</h1><p>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty</p>
<h1 id="指定日志文件保存多久"><a href="#指定日志文件保存多久" class="headerlink" title="指定日志文件保存多久"></a>指定日志文件保存多久</h1><p>$ sudo journalctl –vacuum-time=1years</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday4日志文件</title>
    <url>/2021/11/06/linuxday4/</url>
    <content><![CDATA[<p>一。linux常用的日志文件文件名<br>1./var/log/boot.log 开机启动的时候系统内核会去检测和启动硬件，接下来开始启动各种内核支持的功能<br>2./var/log/cron 计划任务<br>3./var/log/dmesg 记录系统开机的时候内核检测过程所产生的相关信息<br>4./var/log/lastlog 可以记录系统上面所有账号最近一次登录系统时产生的各项信息<br>5./var/log/maillog 或/var/log/mail/* 记录邮件往来的信息<br><em>重要</em>6./var/log/messages 几乎系统发生的错误信息（重要的信息）都会记到这个文件上。<br><em>重要</em>7./var/log/secure 只要牵涉到【密码和账户】的软件，那么都会记录到这个文件上<br> 8./var/log/wtmp ,/var/log/faillog 记录正确登录系统的账户信息与错误登记用户的账户信息<br>二。日志的一般格式<br><em>事件发生的日期和时间<br><em>发生此事件的主机名<br><em>开启此事件的服务名称或命令或函数名称<br><em>该信息的实际内容<br>列cat  /var/log/secure<br>cat  /var/log/messages<br>三。rsyslog.service<br>1.记录日志文件的服务<br>Linux的日志文件主要由rsyslog.service<br>2.配置文件/etc/rsyslog.conf<br>(1)什么服务（2）什么等级信息（3）需要被记录在哪里<br>rsyslogd主要通过linux内核提供的syslog相关规范来设置数据的分类<br>3.信息等级<br>基本上,在0-6的等级之间，等级数值越高越没事，等级靠近0则代表系统出现致命的问题。<br>4.rsyslog.conf语法练习<br>列:mail.info  /var/log/maillog<br>5.rsyslog.conf内容<br>vim  /etc/rsyslog.conf<br>#kern.</em>                                                    /dev/console<br><em>.info;mail.none;authpriv.none;cron.none      /var/log/messages<br>authpriv.</em>                                    /var/log/secure<br>mail.</em>                                        /var/log/maillog<br>cron.</em>                                        /var/log/cron<br><em>.emerg                                       *<br>uucp,news.crit                                /var/log/spooler<br>local7.</em>                                      /var/log/boot.log<br>6.日志文件的安全性设置<br>如果只能增加，不能删除 可以用lsattr 和chattr这俩个程序<br>列：chattr +a  /var/log/admin.log   lsattr 显示文件的隐藏属性   chattr  配置文件隐藏属性。<br>7.日志文件服务器的设置<br>服务端：<br>vim /etc/rsyslog.conf<br>然后重启服务和查看rsyslogd<br>systemctl restart  rsyslogd.service<br>netstat  -ltnp  |  grep  syslog<br>客户端：<br>vim /etc/rsyslog.conf<br><em>.</em>   @@192.168.1.100   (服务端的ip)<br>#</em>.*   @192.168.1.100 #若用udp传输，设置就变成这样</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday6 启动流程，模块管理与loader</title>
    <url>/2021/11/08/linuxday6/</url>
    <content><![CDATA[<p>一.linux的启动流程分析<br>1.启动流程：（1）加载bios的硬件信息，<br>（2）读取并执行第一个启动设备内mbr的启动引导程序，<br>（3）根据启动引导加载与加载驱动程序<br>（4）硬件驱动成功后，kernel会调用systemd程序，并以defult.target程序启动<br>2.boot loader<br>初始化开发板上主要硬件（时钟，内存，硬盘），把操作系统从硬盘拷贝到内存，然后让CPU跳到内存中执行操作系统<br>loader的最主要功能是要识别操作系统的文件格式，并据以加载内核到内存去执行<br>boot loader<br>提供选项：（1）用户可以选择不同的启动选项，这也是多重引导的重要功能<br>（2）加载内核文件<br>（3）转交其他loader<br>3. Kernel（初始化）<br>我们知道kernel是完成探索硬件及加载硬件驱动程序，并以读写的方式挂载根文件系统。<br>kernel初始化：探测硬件-&gt;加载驱动（initrd)-&gt;挂载根文件系统-&gt;rootfs(/sbin/init)<br>4.initrd功能介绍<br>       其实说白了initrd就是一个虚拟的文件系统，里面有/、lib、bin、sbin、usr、proc、sys、var、dev、boot等一些目录<br>5./sbin/init(/etc/inittab)<br>/sbin/init启动会用到/etc/inittab所定义的条目，如：默认登陆级别id:3:initdefault:(这里就是默认启动3级别）<br>下面就来说下/etc/inittab所工作那些内容：<br>/etc/inittab<br>默认运行级别<br>   0：halt系统停机状态<br>   1: single user mode(单用户维护模式)<br>   2：multi user mode, without NFS(多用户，不支持NFS功能）<br>   3: multi user mode, text mode（字符界面）完全的多用户状态(有NFS)，登陆后进入控制台命令行模式<br>   4：reserved （系统保留）系统未使用<br>   5: multi user mode, graphic mode  （图形化界面）：X11控制台，登陆后进入图形GUI模式<br>   6: reboot   （重启）<br>6.init执行/etc/rc.d/rc.local<br>init执行中断机模拟程序mingetty来启动login进程，最后等待用户登录<br>7.启动过程会用到的主要配置文件<br>基本上，systemd有自己的配置文件处理方式，读取位于/etc/sysconfig下面的环境配置文件<br>关于模块：/etc/modprobe.d/<em>.conf及/etc/modules-load.d/</em>.conf<br>.  /etc/sysconfig/*<br>authconfig   此文件中的内容为主机在进行认证时使用<br>cpupower  启动cpupower.service服务时会读取这个配置文件</p>
<p>二.处理忘记密码<br>1.先按e进入编译模式<br>2.在编译模式里【linux16】最后面添加rd.break  ctrl+x执行<br>3.进入到另外一个模式 ，然后检查mount  ，并添加权限 mount   -o   remount ，rw /sysroot<br>4.chroot  /sysroot<br>然后改密码echo “新密码”| passwd  –stdin   root<br>然后touch  /.autorelabel<br>然后重启  redoot<br>三.tmux<br>Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。<br>1.安装</p>
<h1 id="Ubuntu-或-Debian"><a href="#Ubuntu-或-Debian" class="headerlink" title="Ubuntu 或 Debian"></a>Ubuntu 或 Debian</h1><p>$ sudo apt-get install tmux</p>
<h1 id="CentOS-或-Fedora"><a href="#CentOS-或-Fedora" class="headerlink" title="CentOS 或 Fedora"></a>CentOS 或 Fedora</h1><p>$ sudo yum install tmux</p>
<h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><p>$ brew install tmux</p>
<p>2.安装完成后，键入tmux命令，就进入了 Tmux 窗口。</p>
<p>3.按下Ctrl+d或者显式输入exit命令，就可以退出 Tmux 窗口。<br>$ exit</p>
<p>4.Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。</p>
<p>5.第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>
<p>6.在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。<br>$ tmux detach<br>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>
<p>tmux ls命令可以查看当前所有的 Tmux 会话。<br>$ tmux ls</p>
<h1 id="or"><a href="#or" class="headerlink" title="or"></a>or</h1><p>$ tmux list-session</p>
<p>接入会话<br>tmux attach命令用于重新接入某个已存在的会话。</p>
<h1 id="使用会话编号"><a href="#使用会话编号" class="headerlink" title="使用会话编号"></a>使用会话编号</h1><p>$ tmux attach -t 0</p>
<h1 id="使用会话名称"><a href="#使用会话名称" class="headerlink" title="使用会话名称"></a>使用会话名称</h1><p>$ tmux attach -t <session-name></p>
<p>杀死会话<br>tmux kill-session命令用于杀死某个会话。</p>
<h1 id="使用会话编号-1"><a href="#使用会话编号-1" class="headerlink" title="使用会话编号"></a>使用会话编号</h1><p>$ tmux kill-session -t 0</p>
<h1 id="使用会话名称-1"><a href="#使用会话名称-1" class="headerlink" title="使用会话名称"></a>使用会话名称</h1><p>$ tmux kill-session -t <session-name></p>
<p> 切换会话<br>tmux switch命令用于切换会话。</p>
<h1 id="使用会话编号-2"><a href="#使用会话编号-2" class="headerlink" title="使用会话编号"></a>使用会话编号</h1><p>$ tmux switch -t 0</p>
<h1 id="使用会话名称-2"><a href="#使用会话名称-2" class="headerlink" title="使用会话名称"></a>使用会话名称</h1><p>$ tmux switch -t <session-name></p>
<p>重命名会话<br>tmux rename-session命令用于重命名会话。<br>$ tmux rename-session -t 0 <new-name></p>
<p>快捷键<br>Ctrl+b d：分离当前会话。<br>Ctrl+b s：列出所有会话。<br>Ctrl+b $：重命名当前会话。</p>
<p>.1 划分窗格<br>tmux split-window命令用来划分窗格。</p>
<h1 id="划分上下两个窗格"><a href="#划分上下两个窗格" class="headerlink" title="划分上下两个窗格"></a>划分上下两个窗格</h1><p>$ tmux split-window</p>
<h1 id="划分左右两个窗格"><a href="#划分左右两个窗格" class="headerlink" title="划分左右两个窗格"></a>划分左右两个窗格</h1><p>$ tmux split-window -h</p>
<p>tmux select-pane命令用来移动光标位置。</p>
<h1 id="光标切换到上方窗格"><a href="#光标切换到上方窗格" class="headerlink" title="光标切换到上方窗格"></a>光标切换到上方窗格</h1><p>$ tmux select-pane -U</p>
<h1 id="光标切换到下方窗格"><a href="#光标切换到下方窗格" class="headerlink" title="光标切换到下方窗格"></a>光标切换到下方窗格</h1><p>$ tmux select-pane -D</p>
<h1 id="光标切换到左边窗格"><a href="#光标切换到左边窗格" class="headerlink" title="光标切换到左边窗格"></a>光标切换到左边窗格</h1><p>$ tmux select-pane -L</p>
<h1 id="光标切换到右边窗格"><a href="#光标切换到右边窗格" class="headerlink" title="光标切换到右边窗格"></a>光标切换到右边窗格</h1><p>$ tmux select-pane -R</p>
<p>交换窗格位置<br>tmux swap-pane命令用来交换窗格位置。</p>
<h1 id="当前窗格上移"><a href="#当前窗格上移" class="headerlink" title="当前窗格上移"></a>当前窗格上移</h1><p>$ tmux swap-pane -U</p>
<h1 id="当前窗格下移"><a href="#当前窗格下移" class="headerlink" title="当前窗格下移"></a>当前窗格下移</h1><p>$ tmux swap-pane -D</p>
<p>窗口管理<br>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p>
<p>6.1 新建窗口<br>tmux new-window命令用来创建新窗口。<br>$ tmux new-window</p>
<h1 id="新建一个指定名称的窗口"><a href="#新建一个指定名称的窗口" class="headerlink" title="新建一个指定名称的窗口"></a>新建一个指定名称的窗口</h1><p>$ tmux new-window -n <window-name><br>6.2 切换窗口<br>tmux select-window命令用来切换窗口。</p>
<h1 id="切换到指定编号的窗口"><a href="#切换到指定编号的窗口" class="headerlink" title="切换到指定编号的窗口"></a>切换到指定编号的窗口</h1><p>$ tmux select-window -t <window-number></p>
<h1 id="切换到指定名称的窗口"><a href="#切换到指定名称的窗口" class="headerlink" title="切换到指定名称的窗口"></a>切换到指定名称的窗口</h1><p>$ tmux select-window -t <window-name><br>6.3 重命名窗口<br>tmux rename-window命令用于为当前窗口起名（或重命名）。</p>
<p>$ tmux rename-window <new-name><br>6.4 窗口快捷键<br>下面是一些窗口操作的快捷键。</p>
<p>Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。<br>Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。<br>Ctrl+b n：切换到下一个窗口。<br>Ctrl+b <number>：切换到指定编号的窗口，其中的<number>是状态栏上的窗口编号。<br>Ctrl+b w：从列表中选择窗口。<br>Ctrl+b ,：窗口重命名。<br>其他命令<br>下面是一些其他命令。</p>
<h1 id="列出所有快捷键，及其对应的-Tmux-命令"><a href="#列出所有快捷键，及其对应的-Tmux-命令" class="headerlink" title="列出所有快捷键，及其对应的 Tmux 命令"></a>列出所有快捷键，及其对应的 Tmux 命令</h1><p>$ tmux list-keys</p>
<h1 id="列出所有-Tmux-命令及其参数"><a href="#列出所有-Tmux-命令及其参数" class="headerlink" title="列出所有 Tmux 命令及其参数"></a>列出所有 Tmux 命令及其参数</h1><p>$ tmux list-commands</p>
<h1 id="列出当前所有-Tmux-会话的信息"><a href="#列出当前所有-Tmux-会话的信息" class="headerlink" title="列出当前所有 Tmux 会话的信息"></a>列出当前所有 Tmux 会话的信息</h1><p>$ tmux info</p>
<h1 id="重新加载当前的-Tmux-配置"><a href="#重新加载当前的-Tmux-配置" class="headerlink" title="重新加载当前的 Tmux 配置"></a>重新加载当前的 Tmux 配置</h1><p>$ tmux source-file ~/.tmux.conf<br>四.cron计划任务<br>很多时候，我们计划任务需要精确到秒来执行，根据以下方法，可以很容易地以秒执行任务。<br>以下方法将每10秒执行一次</p>
<h1 id="crontab-e"><a href="#crontab-e" class="headerlink" title="crontab -e"></a>crontab -e</h1><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>/bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 10; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 20; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 30; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 40; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 50; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代表着所有可能取到的值，除了直接用 * 外，下面的几个例子也较为常用<br>当指定 */5 在分钟字段，代表每五分钟。<br>当指定 0-10/2 在分钟字段，代表在前十分钟的每两分钟</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>linuxday7内核管理和修改ip</title>
    <url>/2021/11/09/linuxday7/</url>
    <content><![CDATA[<p>一。内核与内核模块<br>1。内核模块与依赖性<br>内核模板放在：/lib/modules/$(uname -r)/kernel中<br>使用depmod<br>范例一：若我做好一个网卡驱动程序，文件名为a.ko,该跟新内核依赖性<br>cp a.ko /lib/modules/$(uname -r)/kernel/drivers/net<br>depmod<br>2.查看内核模块<br>lsmod<br>列出内核名称。模块大小，此模块是否被其他模块所使用<br>列出模块的相关信息<br>如列出drm的模块信息：modinfo drm<br>3.内核模块的加载与删除<br>加载insmod  删除 rmmod<br>加载：modprobe vfat<br>删除：modprobe  -r vfat<br>4.内核模块的额外参数设置：/etc/modprobe.d/*.conf<br>5.boot loader的俩个stage<br>stage1：执行boot loader 主程序<br>stage2：主程序加载配置文件</p>
<p>二。基础系统设置与备份策略<br>1.网络设置（手动设置与DHCP自动获取）<br>ipaddr-(ip)<br>netmask子网掩码<br>gateway网关<br>dns主机ip<br>2.命令<br>临时修改本机IP地址ifconfig ens33 192.168.1.200/24<br>永久修改本机IP地址：vim /etc/sysconfig/network-scripts/ifcfg-ens33<br>修改：BOOTPROTO=”static”<br>IPADDR=192.168.1.100<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.1.1<br>修改完后注意重启network服务，使其生效：<br>service network restart<br>nmtui 网络管理器<br>3.nmcli<br>    systemctl restart NetworkManager   启动网络管理器<br>查看网卡信息nmcli connection show   网卡名称<br>        启动：nmcli connection up  网卡名称<br>显示所有设配状态# nmcli device status<br>显示所有活动连接# nmcli connection show –active<br>删除一个网卡连接# nmcli connection delete eth0<br>停用：# nmcli connection down eth0<br>设置：nmcli connection modify eth0\<br>          connection.autoconnect yes\  是否开机时启动这个连接<br>          ipv4.method manual（手动）   自动还是手动设置网络参数  auto（自动）<br>          ipv4.addresses 192.168.1.1/24\   ip地址和子网掩码<br>          ipv4.gateway  192.168.200.254    网关<br>          ipv4.dns<br>4.修改主机名<br>hostnamectl   set-hostname  {姓名}<br>cat  /etc/hostname<br>5.日期与时间设置<br>设置时区：tzselect  （Asia亚洲）<br>查看时间：timedatectl<br>修改：timedatectl  set-timezone “Asia/shanghai”<br>timedatectl  list-timezone<br>timedatectl  set-time  “2021-11-10 23：17”<br>使用ntpdate手动网络校时<br>ntpdate s2m.time.edu.cn<br>hwclock  -w<br>语系设置<br>localectl<br>将locale改成en_us.utf8之后，在转化成图形界面<br>localectl  set-locale LANG=en_US.utf8<br>systemctl  isolate  multi-user.target<br>systemctl  isolate  graphicdl.target</p>
]]></content>
  </entry>
  <entry>
    <title>linux安全加固</title>
    <url>/2021/11/15/linu%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<p>一。Linux文件结构<br>/下面<br>/bin 放置的是在单人维护模式下能够被操作的指令，在/bin底下的指令可以被root和一般账号所使用<br>/boot 这个目录主要是在放开机会使用到的文件，包括linux核心文件以及开机选单与开机所需配置的文件等等<br>/dev 在linux系统上，任何装置与接口设备都是以文件的形态存在于这个目录当中的<br>/etc系统主要的配置文件几乎都放在这个，目录内，列如人员的账号密码文件，各种服务的启动档，系统变量配置等<br>/home系统默认的家目录<br>/lib放置的则是在开机时会用到的函数库，以及在/lib或/sbin5底下的指令会呼叫的函式库<br>二级目录<br>/media底下放置的是可移出的装置，包括软盘，光盘，dvd等等装置都杂事挂载在此。<br>/opt给第三方的协议软件放置的目录</p>
<p>二。账号分类：<br>超级管理员 uid=0,<br>系统默认用户 系统程序使用，从不登录<br>新建普通用户 uid大于500<br>三。修改权限：<br>chmod 777 test<br>chown s：da   test<br>umask值为0022所对应的默认文件和文件夹创建的缺省权限分别为644和755<br>文件夹其权限规则为：777-022=755<br>文件其权限规则为： 777-111-022=644（因为文件默认没有执行权限）</p>
<p>四。使用命令passwd -l &lt;用户名&gt;锁定不必要的账号。<br>使用命令passwd -u &lt;用户名&gt;解锁需要恢复的账号。</p>
<p>五。执行命令<br>#cat /etc/login.defs|grep PASS查看密码策略设置<br>加固方法：<br>#vi /etc/login.defs修改配置文件<br>PASS_MAX_DAYS 90 #用户的密码最长使用天数<br>PASS_MIN_DAYS 0 #两次修改密码的最小时间间隔<br>PASS_MIN_LEN 7 #密码的最小长度<br>PASS_WARN_AGE 9 #密码过期前多少天开始提示</p>
<p>六。禁用root之外的超级用户<br>检测方法：<br>awk -F “:” ‘($3==”0”){print $1}’ /etc/passwd 检查用户ID为0的用户<br>加固方法：<br>passwd -l &lt;用户名&gt;                  锁定用户</p>
<p>七。限制能够su为root的用户<br>#cat /etc/pam.d/su,查看是否有auth required /lib/security/pam_wheel.so这样的配置条目<br>加固方法<br>在头部添加：<br>auth required /lib/security/pam_wheel.so group=wheel<br>这样，只有wheel组的用户可以su到root<br>#usermod -G10 test 将test用户加入到wheel组</p>
<p>八。重要文件加上不可改变属性<br>把重要文件加上不可改变属性<br>[root@ayazero /]# chattr +i /etc/passwd<br>[root@ayazero /]# chattr +i /etc/shadow<br>[root@ayazero /]# chattr +i /etc/gshadow<br>[root@ayazero /]# chattr +i /etc/group<br>[root@ayazero /]# chattr +i /etc/inetd.conf<br>[root@ayazero /]# chattr +i /etc/httpd.conf<br>查看隐藏属性：lsattr /etc/shadow</p>
<p>九。Umask安全<br>第一个0代表suid 丢弃的权限；<br>第二个0代表本文件/目录拥有者什么权限都没丢弃<br>第三个2代表本文件/目录的用户组丢弃了w权限<br>第四个2代表本文件/目录的其他用户能使用的权限只有有r和x<br>实际权限=7777-0022<br>设置合理的umask权限<br>umask 0022</p>
<p>十。设置系统日志策略配置文件<br>日志的主要用途是系统审计、监测追踪和分析统计。<br>为了保证 Linux 系统正常运行、准确解决遇到的各种各样的系<br>统问题，认真地读取日志文件是管理员的一项非常重要的任务。<br>UNIX/ Linux采用了syslog工具来实现此功能，如果配置正确的<br>话，所有在主机上发生的事情都会被记录下来，不管是好的还<br>是坏的<br>   检查方法：</p>
<h1 id="ps-aef-grep-syslog-确定syslog服务是否启用"><a href="#ps-aef-grep-syslog-确定syslog服务是否启用" class="headerlink" title="ps -aef | grep syslog 确定syslog服务是否启用"></a>ps -aef | grep syslog 确定syslog服务是否启用</h1><h1 id="cat-etc-rsyslog-conf-查看syslogd的配置，并确认日志文件日否存在"><a href="#cat-etc-rsyslog-conf-查看syslogd的配置，并确认日志文件日否存在" class="headerlink" title="cat /etc/rsyslog.conf 查看syslogd的配置，并确认日志文件日否存在"></a>cat /etc/rsyslog.conf 查看syslogd的配置，并确认日志文件日否存在</h1><p>系统日志 (默认) /var/log/messages<br>cron日志 (默认) /var/log/cron<br>安全日志 (默认) /var/log/secure，只要涉及账号和密码的程序都会记录。<br>/var/log/btmp 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday9软件安装rpm和yum配置，内核编译和管理</title>
    <url>/2021/11/12/linuxday9/</url>
    <content><![CDATA[<p>软件安装：源代码与tarball<br>yum  -y install  gcc  安装编译工具<br>编译安装<br>列如：<br>下面使用proxy主机配置nginx：</p>
<p>准备工作<br>ip add show  //查看ip</p>
<p>安装常用工具：</p>
<p>yum -y install bash-completion    //安装支持tab键的工具包，安装完</p>
<p>毕之后，要退出终端重新登录才生效</p>
<p>yum -y install vim   //安装vim编辑器</p>
<p>yum provides ifconfig   //检查ifconfig命令来自于哪个软件包</p>
<p>yum -y install net-tools   //安装网络相关工具，比如ifconfig查询ip地址</p>
<p>yum -y install psmisc  //安装支持killall命令软件包</p>
<p>nmcli connection modify eth0 connection.autoconnect yes   //eth0网卡开机</p>
<p>自启</p>
<p>2，Nginx环境搭建：</p>
<p>找到lnmp_soft.tar.gz，拷贝到虚拟机的root家目录，并释放到原地<br>tar -xf  lnmp_soft.tar.gz</p>
<p>2，释放lnmp_soft目录中的nginx-1.17.6.tar.gz</p>
<p>         cd  lnmp_soft</p>
<p>        tar -xf nginx-1.17.6.tar.gz</p>
<p>yum -y install gcc   //安装编译工具</p>
<p>yum -y install pcre-devel   //可以让nginx支持正则</p>
<p>yum -y install openssl-devel   //支持搭建基于ssl(安全加密)技术的网站</p>
<p>3，编译安装</p>
<p>cd  nginx-1.17.6   //进入nginx目录</p>
<p>./configure –with-http_ssl_module  //配置，添加安全模块</p>
<p>./configure –help | grep http_ssl  //配置时，使用help与grep</p>
<p>查询过滤模块部分名，即可找到模块完整名</p>
<hr>
<p>非必须操作</p>
<p>./configure  –prefix=/usr/local/nginx   //指定安装路径</p>
<p>  –user=nginx   //指定用户</p>
<p>                –group=nginx   //指定组</p>
<hr>
<p>make  //编译</p>
<p>make install   //安装</p>
<p>ls /usr/local/nginx   //查看nginx安装目录</p>
<p>主要目录功能：</p>
<p>conf  //存放配置文件</p>
<p>html  //存放网站页面</p>
<p>logs  //存放日志</p>
<p>sbin  //主程序目录<br>二。软件安装rpm，srpm与yum<br>1 案例1：查询已安装的软件信息<br>1.1 问题</p>
<ol>
<li>   列出当前主机已安装的所有RPM软件</li>
<li>   查看firefox软件包的安装清单</li>
<li>   查询ifconfig命令程序是安装哪个软件包后产生的</li>
<li>   查看firefox软件包的用途</li>
<li>2 方案<br>查询所有已安装的rpm包，可以利用命令rpm -qa。<br>查询一个软件安装清单，可以利用命令rpm -ql 软件名。<br>查询一个文件是由哪个软件包安装后产生，可以利用命令rpm -qf 文件绝对路径。本题中首先要找到，ifconfig命令的可执行程序在哪里，可以利用which命令。<br>查看软件的用途，可以利用命令rpm -qi 软件名。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：列出当前主机已安装的所有RPM软件<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# rpm -qa<br>步骤二：查看firefox软件包的安装清单<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# rpm -ql firefox<br>步骤三：查询ifconfig命令程序是安装哪个软件包后产生的<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# which ifconfig    #查询命令所对应的程序</li>
<li>   /sbin/ifconfig</li>
<li>   [root@localhost ~]# rpm -qf /sbin/ifconfig</li>
<li>   net-tools-1.60-110.el6_2.x86_64</li>
<li>   [root@localhost ~]#<br>步骤四：查看firefox软件包的用途<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# rpm -qi firefox</li>
<li>   Name        : firefox                      Relocations: (not relocatable)</li>
<li>   Version     : 17.0.10                           Vendor: Red Hat, Inc.</li>
<li>   Release     : 1.el6_4                       Build Date: 2013年10月23日 星期三 21时14分43秒</li>
<li>   Install Date: 2015年01月06日 星期二 20时59分04秒      Build Host: x86-027.build.eng.bos.redhat.com</li>
<li>   Group       : Applications/Internet         Source RPM: firefox-17.0.10-1.el6_4.src.rpm</li>
<li>   Size        : 30424459                         License: MPLv1.1 or GPLv2+ or LGPLv2+</li>
<li>   Signature   : RSA/8, 2013年10月29日 星期二 16时20分45秒, Key ID 199e2f91fd431d51</li>
<li>   Packager    : Red Hat, Inc. <a href="http://bugzilla.redhat.com/bugzilla">http://bugzilla.redhat.com/bugzilla</a></li>
<li>   URL         : <a href="http://www.mozilla.org/projects/firefox/">http://www.mozilla.org/projects/firefox/</a></li>
<li>   Summary     : Mozilla Firefox Web browser</li>
<li>   Description :</li>
<li>   Mozilla Firefox is an open-source web browser, designed for standards</li>
<li>   compliance, performance and portability.</li>
<li>   [root@localhost ~]#<br>2 案例2：查询待安装的.rpm包</li>
<li>1 问题</li>
<li>   查询光盘中的 lynx 软件包的用途、安装清单</li>
<li>   查询光盘中的 wireshark 软件包的用途、安装清单</li>
<li>2 方案<br>注意在查询未安装的.rpm包信息时，提供的命令参数应该是准确的包文件路径，仅指定软件名是不行的。指定文件路径时，多利用Tab键补全。提前将RHEL6系统光盘挂载到/media目录，以便使用相关包文件。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：查询光盘中的 lynx 软件包的用途、安装清单<br>首先将光盘设备手动挂载到/media目录，进行查询操作。<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# mount /dev/cdrom /media/</li>
<li>   mount: block device /dev/sr0 is write-protected, mounting read-only</li>
<li></li>
<li>   [root@localhost ~]# mount | tail -1</li>
<li>   /dev/sr0 on /media type iso9660 (ro)</li>
<li>   [root@localhost ~]# rpm -qpi /media/Packages/lynx-2.8.8-0.3.dev15.el7.x86_64.rpm </li>
<li>   ……</li>
<li>   [root@localhost ~]# rpm -qpl /media/Packages/lynx-2.8.8-0.3.dev15.el7.x86_64.rpm</li>
<li>   ……<br>步骤二：查询光盘中的 wireshark 软件包的用途、安装清单<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# rpm -qpi /media/Packages/wireshark-1.10.14-14.el7.x86_64.rpm</li>
<li>   ……</li>
<li></li>
<li>   [root@localhost ~]# rpm -qpl /media/Packages/wireshark-1.10.14-14.el7.x86_64.rpm</li>
<li>   ……<br>3 案例3：RPM软件的安装和卸载</li>
<li>1 问题</li>
<li>   找出vim、vi是由哪两个包产生的</li>
<li>   删除vim、vi命令程序</li>
<li>   修复vim、vi</li>
<li>   安装bind-chroot包,体验Linux依赖关系</li>
<li>2 方案<br>本题的思路是，首相通过which命令查找到vim、vi命令可执行程序所在位置，在通过“rpm –qf 文件绝对路径”命令查看该可执行程序，是由那个包产生的。删除该可执行程序后，再将软件包安装重新产生即可。但在安装时需注意，系统会提示改程序已经安装，需加上“—force”选项强制安装。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：找出vim、vi是由那两个包产生的<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# which vi  vim</li>
<li>   /usr/bin/vi</li>
<li>   /usr/bin/vim </li>
<li>   [root@localhost ~]# rpm -qf /usr/bin/vi</li>
<li>   vim-minimal-7.4.160-4.el7.x86_64 </li>
<li>   [root@localhost ~]# rpm -qf /usr/bin/vim</li>
<li>   vim-enhanced-7.4.160-4.el7.x86_64<br>步骤二：删除vim、vi命令程序<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# rm -rf /usr/bin/vi /usr/bin/vim</li>
<li>   [root@localhost ~]#<br>步骤三：修复vim、vi<br>首先将光盘设备手动挂载到/media目录，进行修复操作。<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# mount /dev/cdrom /media/</li>
<li>   mount: block device /dev/sr0 is write-protected, mounting read-only</li>
<li>   [root@localhost ~]# rpm -ivh –force /media/Packages/vim-minimal-7.4.160-4.el7.x86_64……</li>
<li></li>
<li><pre><code>[root@localhost ~]# rpm -ivh --force /media/Packages/vim-enhanced-7.4.160-4.el7.x86_64
</code></pre>
</li>
<li>   ……</li>
<li><pre><code>[root@localhost ~]#
</code></pre>
步骤四：安装bind-chroot包,体验Linux依赖关系<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# cd  /media/Packages</li>
<li>   [root@svr5 Packages]# rpm  -ivh  bind-chroot-9.9.4-61.el7.x86_64.rpm </li>
<li>   error: Failed dependencies:</li>
<li>   ……</li>
<li></li>
<li><pre><code>[root@svr5 Packages]# rpm  -ivh  bind-9.9.4-61.el7.x86_64.rpm 
</code></pre>
</li>
<li>   Preparing…                ########################################### [100%]</li>
<li><pre><code>  1:bind                   ########################################### [100%]
</code></pre>
</li>
<li>   [root@svr5 Packages]# rpm  -ivh  bind-chroot-9.9.4-61.el7.x86_64.rpm </li>
<li>   Preparing…                ########################################### [100%]</li>
<li><pre><code>  1:bind-chroot            ########################################### [100%]
</code></pre>
4 案例4：配置Yum仓库及客户端及验证</li>
<li>1 问题</li>
<li>   将光盘挂载到/dvd，搭建本地Yum</li>
<li>   将本机设置为客户端，进行Yum验证</li>
<li>   查询Yum库中是否有firefox包</li>
<li>   使用yum命令安装bind包</li>
<li>   利用Yum安装bind</li>
<li>   利用Yum卸载bind</li>
<li>   利用yum search查询与httpd相关的包</li>
<li>   利用yum info查询firefox包描述信息</li>
<li>2 方案<br>YUM服务器配置思路：<br>第一步：确保光驱电源加电，放入Linux光盘的iso镜像<br>第二步：ls -l /dev/cdrom 查看linux系统是否识别光驱设备<br>第三步：创建挂载目录:mkdir /dvd （或也可以使用linux系统提供的挂载目录/media、/mnt）<br>第四步：利用mount命令挂载:mount /dev/cdrom /dvd<br>第五步：查看挂载情况：mount | grep dvd<br>YUM客户端配置思路：<br>第一步：切换路径到客户端配置文件路径下：cd /etc/yum.repos.d/<br>第二步：排除其他文件的干扰<br>[root@localhost ~]# mkdir /etc/yum.repos.d/repo<br>[root@localhost ~]# mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/repo<br>第三步：更改配置文件dvd.repo。<br>必须更改的字段：<br>•    【】”内容要唯一所以要更改，注意不要有空格<br>•    “baseurl”此字段指定软件包目录，注意路径写对。file：后要有三个“/”<br>•    “enabled”此字段要至于“1”，代表启用<br>Yum在使用方面，几乎rpm能够做到的事情，Yum也能够做到。此外Yum还具备自动解决依赖关系的功能。<br>常用的Yum操作：<br>•    yum install 软件名：安装一个软件包<br>•    yum remove 软件名：卸载一个软件包</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：搭建一个本地Yum，将光盘手动挂载到/dvd<br>命令操作如下所示：</li>
<li>   [root@localhost ~]# mkdir /dvd</li>
<li>   [root@localhost ~]# ls /dvd</li>
<li>   [root@localhost ~]# mount /dev/cdrom /dvd/</li>
<li>   mount: /dev/sr0 写保护，将以只读方式挂载</li>
<li>   [root@localhost ~]# ls /dvd/</li>
<li>   [root@localhost ~]# ls /dvd/Packages/<br>步骤二：将本地设置为客户端，进行Yum验证<br>Yum客户端需编辑配置文件，命令操作如下所示：</li>
<li>   [root@localhost ~]# ls /etc/yum.repos.d/</li>
<li>   [root@localhost ~]# mkdir /etc/yum.repos.d/repo</li>
<li>   [root@localhost ~]# mv /etc/yum.repos.d/*.repo  /etc/yum.repos.d/repo </li>
<li>   [root@localhost ~]# ls /etc/yum.repos.d/</li>
<li>   [root@localhost ~]# vim /etc/yum.repos.d/dvd.repo</li>
<li>   [centos] #仓库标识,可以任意</li>
<li>   name=hehe lele CentOS7         #仓库的描述信息，可以任意</li>
<li>   baseurl=file:///dvd             #指定服务端位置，file://代表本地为服务端</li>
<li>   enabled=1                     #是否启用本文件</li>
<li>   gpgcheck=0                     #是否检测红帽签名信息</li>
<li>   [root@localhost ~]# yum repolist         #列出仓库信息<br>步骤三：查询yum库中是否有firefox包<br>命令操作如下所示：</li>
<li>   [root@localhost /]# yum list | grep firefox<br>步骤四：利用yum安装bind包<br>命令操作如下所示：</li>
<li>   [root@localhost /]# yum -y install bind</li>
<li>   ……<br>步骤二：利用Yum卸载bind<br>命令操作如下所示：</li>
<li>   [root@localhost /]# yum -y remove bind</li>
<li>   ……<br>步骤四：利用yum search查询与httpd相关的包<br>命令操作如下所示：</li>
<li>   [root@localhost /]# yum search httpd</li>
<li>   ……<br>步骤四：利用yum info查询firefox包描述信息<br>命令操作如下所示：</li>
<li>   root@localhost /]# yum info firefox</li>
<li>   ……<br>三。linux内核编译与管理</li>
<li>内核<br>kernel<br>内核是系统上面的一个文件，这个文件包括了驱动主机各项硬件的检测程序与驱动模块<br>这个内核文件被命名为/boot/Vmlinux-xxx<br>内核模块放在/lib/modules/$(uname -r) 内核版本/kernel<br>更新内核的目的<br>（1）.新功能的需求<br>（2）.原本内核太过臃肿<br>（3）.与硬件搭配的稳定性<br>（4）.其他需求</li>
<li>内核源代码的解压缩，安装，查看<br><a href="https://www.linux-mips.org/pub/linux/mips/kernel/v3.x/linux-3.10.89.tar.xz">https://www.linux-mips.org/pub/linux/mips/kernel/v3.x/linux-3.10.89.tar.xz</a><br>tar Jxvf  linux-3.10.89.tar.xz  -C /usr/src/kernelsrf</li>
<li>保持干净源代码：make  mrproper </li>
<li>开始选择内核功能<br>cp  /boot/config-3.10.0-862.el7.x86_64   .config</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linuxday8防火墙以及firewalld</title>
    <url>/2021/11/11/linuxday8/</url>
    <content><![CDATA[<p>一。防火墙<br>1.启动防火墙： systemctl start firewalld<br>查看防火墙状态： systemctl status firewalld<br>停止防火墙： systemctl disable firewalld<br>禁用防火墙： systemctl stop firewalld  ， firewall-cmd –set-default-zone=trusted<br>2.配置firewalld-cmd<br>查看版本： firewall-cmd –version</p>
<p>查看帮助： firewall-cmd –help</p>
<p>显示状态： firewall-cmd –state</p>
<p>查看所有打开的端口： firewall-cmd –zone=public –list-ports</p>
<p>更新防火墙规则： firewall-cmd –reload</p>
<p>查看区域信息: firewall-cmd –get-active-zones</p>
<p>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0</p>
<p>拒绝所有包：firewall-cmd –panic-on</p>
<p>取消拒绝状态： firewall-cmd –panic-off</p>
<p>查看是否拒绝： firewall-cmd –query-panic</p>
<p>那怎么开启一个端口呢</p>
<p>添加</p>
<p>firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent永久生效，没有此参数重启后失效）</p>
<p>重新载入</p>
<p>firewall-cmd –reload</p>
<p>查看</p>
<p>firewall-cmd –zone= public –query-port=80/tcp</p>
<p>删除</p>
<p>firewall-cmd –zone= public –remove-port=80/tcp –permanent</p>
<p> 四个基本区域</p>
<p>  根据所在的网络场所区分,预设保护规则集<br>– public:仅允许访问本机的ssh dhcp ping服务<br>– trusted:允许任何访问<br>– block:阻塞任何来访请求(明确拒绝,有回应客户端)<br>– drop:丢弃任何来访的数据包(没有回应,节省服务端资源)</p>
<p>基本命令</p>
<p>  1.查看当前区域</p>
<pre><code>firewall-cmd --get-default-zone
</code></pre>
<p>  2.转换区域</p>
<pre><code>firewall-cmd --set-default-zone=&#39;区域名&#39;
</code></pre>
<p>  3.查看区域规则</p>
<pre><code>firewall-cmd --zone=&#39;区域名&#39; --list-all
</code></pre>
<p>  4.添加源</p>
<p>   firewall-cmd –zone=’区域名’ –add-source=’ip地址’<br>二。服务器硬件数据的收集<br>1.使用dmidecode查看硬件设备<br>使用dmidecode -t 1 可以查看主板信息(制造商、型号、序列号等等）<br>使用dmidecode -t 4 可以查看CPU信息(CPU数目、型号、大小、频率等等）<br>使用dmidecode -t 17 可以查看内存信息(插槽数目、内存类型、大小、频率等等）<br>使用dmidecode -t  9  可以查看系统相关插槽的格式。<br>2.硬件资源的收集和分析<br>lspci<br>lsusb<br>iostat<br>3.了解磁盘的健康状态<br>用smartctl来显示完整的/dev/sda<br>smartctl -a   /dev/sda<br>三。备份<br>1.那些数据具有备份的意义<br>操作系统本身需要备份的文件<br>【账户与系统配置文件】<br>/etc/passwd , /etc/shadow , /etc/group  , /etc/gshadow以及/home下的用户家目录<br>/etc/整个目录  /home /var/spool/mail   /var/spool/{at|cron}   /boot/  /root/   /var/lib<br>如果安装过其他软件，那么/usr/local  ,/opt也备份<br>网络服务<br>www数据：/var/www 或 /srv/www<br>mariaDB：/var/lib/mysql整个目录<br>2.完整备份<br>（1）累积备份<br>累积备份的原则：系统在进行一次完整备份后，进行一段时间的运行，比较系统与备份文件之间的差异，仅备份有差异的文件<br>而第二次累积备份则是与第一次累积备份的数据比较，也是备份有差异的数据。<br>（2）差异备份<br>原则：也是需要系统进行第一次完整备份后才能进行，每次的备份都是与原始的完整备份比较的结果</p>
]]></content>
  </entry>
  <entry>
    <title>shell02简单的shell</title>
    <url>/2021/11/03/shell02/</url>
    <content><![CDATA[<p>什么是shell</p>
<p>在Linux内核与用户之间的解释器程序</p>
<p>通常指 /bin/bash</p>
<p>负责向内核翻译及传达用户/程序指令</p>
<p>相当于操作系统的“外壳”</p>
<p>Shell的使用方式</p>
<p>交互式   —— 命令行</p>
<p>人工干预、智能化程度高</p>
<p>逐条解释执行、效率低</p>
<p>非交互式 —— 脚本</p>
<p>需要提前设计、智能化难度大</p>
<p>批量执行、效率高</p>
<p>方便在后台静悄悄地运行</p>
<p>什么是Shell脚本？</p>
<p>提前写好可执行语句，能够完成特定任务的文件</p>
<p>顺序、批量化处理</p>
<p>[root@svr7 ~]# cat /etc/shells   //查看所有解释器</p>
<p>[root@svr7 ~]# sh   //切换成sh解释器</p>
<p>sh-4.2# ls    //利用sh解释器输入命令</p>
<p>sh-4.2#exit   //退出sh解释器</p>
<p>[root@svr7 ~]#yum -y install ksh   //安装新解释器</p>
<p>[root@svr7 ~]#ksh   //进入新解释器</p>
<p>Bash的优点 : tab键、历史命令、快捷键、支</p>
<p>持别名、管道、重定向</p>
<p>脚本的编写规范</p>
<p>声明解释器<br>#!/bin/bash</p>
<p>编写注释<br>#注释内容可以是脚本的功能、作者介绍、脚本中各个参数的含义等</p>
<p>执行指令<br>ls</p>
<p>cd</p>
<p>pwd</p>
<p>   所有需要脚本执行的任务都可以逐行写在这里</p>
<p>脚本的执行方式</p>
<p>添加x权限，使用相对或者绝对路径<br>使用解释器执行脚本，会开启解释器子进程<br>bash test01.sh</p>
<p>使用source命令执行脚本，不开启解释器子进程<br>source test01.sh</p>
<p>可以在另外一个命令行终端使用pstree命令查看</p>
<p>    主进程—子进程</p>
<p>  bash—bash—test01.sh    //使用解释器执行脚本</p>
<p>  bash—test01.sh   //使用source执行脚本</p>
<hr>
<p>#!/bin/bash</p>
<p>mkdir abc</p>
<p>cd abc</p>
<p>//可以利用该脚本测试，bash执行时看不到进入abc的效果，因为bash开启了子进程，执行完任务就退出了，父进程并没有进入abc目录，如果使用source执行该脚本就可以看到进入abc目录的效果，因为是父进程亲自进入没有开启子进程。  另外开一个命令行窗口使用pstree命令可以看到具体过程</p>
<hr>
<p>编写部署yum的脚本</p>
<p>#!/bin/bash</p>
<p>#搭建yum仓库</p>
<p>mkdir /yum</p>
<p>mount /dev/cdrom /yum</p>
<p>rm -rf /etc/yum.repos.d/*.repo</p>
<p>echo “[abc] //这里由于喊出的内容是有换行所以要用引号</p>
<p>name=abcabc</p>
<p>baseurl=file:///yum</p>
<p>gpgcheck=0” &gt; /etc/yum.repos.d/abc.repo    //最后使用重定向保存到yum配置文件中</p>
<p>编写脚本，部署httpd，定义默认页面为”web_test~~~~~~”</p>
<p>#!/bin/bash</p>
<p>#部署网站服务</p>
<p>yum -y install httpd</p>
<p>systemctl restart httpd</p>
<p>echo “ web_test~~~~~~” &gt; /var/www/html/index.html</p>
<p>测试时需要临时关闭防火墙</p>
<p>systemctl stop firewalld</p>
<p>编写部署ftp服务的脚本，要求可以实现开机自动运行</p>
<p>#!/bin/bash</p>
<p>#部署ftp服务</p>
<p>yum -y install vsftpd  &amp;&gt;  /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>常量 固定不变的值（内容）</p>
<p>变量 以固定名称存放，可能发生变化的值，可以提高脚本对任务需求、运行环境变化的适应能力，方便在脚本中重复使用</p>
<p>变量的种类</p>
<p>自定义变量，定义名称可以用数字、字母、下划线，不能<br>使用数字开头，不能使用特殊符号</p>
<p>变量名称=变量的值</p>
<p>[root@localhost opt]# a=10   //定义变量(赋值)</p>
<p>[root@localhost opt]# echo $a  //调用变量，此时$a就相当于10</p>
<p>使用自定义变量要注意：</p>
<p>1，a =10     等号两边不能有空格</p>
<p>a=10  然后 a=20  多次赋值之后，仅最后一次生效<br>如果变量不需要了可以使用unset a  取消，或者a=<br>echo ${a}RMB  当变量名与后面的常量容易发生混淆时要用<br>大括号隔开</p>
<p>2，环境变量，是由系统提前定义好，使用时直接调用</p>
<p>USER当前用户名   HOME当前用户的家目录  </p>
<p>UID 当前用户的id号   PWD 当前位置  </p>
<p>SHELL 当前用户的解释器  HOSTNAME 完整主机名</p>
<p>PS1 一级提示符   PS2  二级提示符</p>
<p>PATH 存储了执行指令的路径</p>
<p>3, 预定义变量与位置变量</p>
<p>$*  $#  $$  $?   $1  $2  $3 ….</p>
<p>#!/bin/bash</p>
<p>echo $1   执行脚本后面跟的第1个位置参数</p>
<p>echo $2   执行脚本后面跟的第2个位置参数</p>
<p>echo $3   执行脚本后面跟的第3个位置参数</p>
<p>echo $*   所有的位置参数</p>
<p>echo $#   所有的位置参数的个数</p>
<p>echo $$   随机的进程号</p>
<p>echo $?   判断上一条指令是否执行成功，0是成功，非0是失败</p>
<p>编写脚本，可以创建用户abcd ，并且配置密码123456</p>
<p>#!/bin/bash</p>
<p>useradd abcd</p>
<p>echo 123456 | passwd –stdin abcd</p>
<p>改良版本，使用了位置变量</p>
<p>#!/bin/bash</p>
<p>useradd $1    //创建用户时调用第1个位置变量</p>
<p>echo $2 | passwd –stdin $1  //配置密码时调用第2个位置变量</p>
<hr>
<p>env  //查看所有的环境变量</p>
<p>env | grep HOSTNAME   //在所有的环境变量中查询HOSTNAME</p>
<p>set  //查看所有变量</p>
<p>set | grep abcd  //过滤查询</p>
<hr>
<p>变量的扩展知识</p>
<p>1，引号与反撇号</p>
<p>双引号  界定范围</p>
<p>touch “a b”  可以创建a空格b的文件</p>
<p>a=10</p>
<p>echo  “$a” 可以调用变量</p>
<p>单引号  界定范围  屏蔽特殊符号的功能</p>
<p>touch  ‘a b’  也可以创建a空格b的文件</p>
<p>echo  ‘$a’  无法调用变量，$是调用变量的特殊符号</p>
<p>其效果被屏蔽</p>
<p>`` 反撇号   调用命令执行的结果</p>
<p>a=date    定义变量时如果使用命令则不会直接识别</p>
<p>a=<code>date</code>   使用反撇号可以将命令的执行结果赋值给变量</p>
<p>a=$(date)  效果同上</p>
<p>2，使用read指令，以交互式使用脚本</p>
<p>用法：read -p “提示的信息”  变量名</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n   //执行脚本后可以看到提示信息，输入信息</p>
<p>之后会存到变量n中</p>
<p>useradd $n    //调用变量n创建刚刚定义的用户名</p>
<p>read -p “请输入密码：”  p   </p>
<p>echo $p | passwd –stdin $n</p>
<p>stty -echo  屏蔽回显</p>
<p>stty echo  恢复回显</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n</p>
<p>useradd $n</p>
<p>stty -echo</p>
<p>read -p “请输入密码：” p</p>
<p>stty echo</p>
<p>echo $p | passwd –stdin $n</p>
<p>3， export  定义全局变量，可以让子进程使用父进程定</p>
<p>义的变量</p>
<p>export  b=20   //创建变量b的同时发布为全局效果</p>
<p>export  a  //将已有的变量发布为全局效果</p>
<p>export  -n  a  //取消变量的全局效果</p>
<p>注意，测试时要在父进程创建变量，然后可以执行bash进入</p>
<p>子进程测试效果，如果要返回父进程要执行exit指令</p>
<p>shell中的运算</p>
<p>加、减、乘、除、取余</p>
<p>expr 可以运算并输出结果</p>
<p>expr 1 + 1   //注意，运算符号两边要有空格</p>
<p>expr 2 - 1</p>
<p>expr 2 * 2     //使用转义符号\可以屏蔽之后一个字符的特殊含义</p>
<p>expr 4 / 2   </p>
<p>expr 10 % 3</p>
<p>[root@svr7 opt]# a=10</p>
<p>[root@svr7 opt]# b=20</p>
<p>[root@svr7 opt]# expr $a + $b    //也支持变量的运算</p>
<p>30</p>
<p>[root@svr7 opt]# expr $a + 100</p>
<p>练习题：</p>
<p>1，如何执行Shell脚本？</p>
<p>2 自定义Shell变量时，有哪些注意事项？</p>
<p>3 编写一个Shell脚本程序，用来报告当前用户的环境信息。</p>
<p>4 简述预定义变量$$、$?、$#、$*的作用。</p>
<p>5 编写一个Shell脚本程序，能够部署ftp服务，并开启ftp默认共享的目录权限。</p>
<p>6 简述单引号、双引号、反撇号在变量赋值操作中的特点。</p>
<p>1，如何执行Shell脚本？</p>
<p>方法一：添加x权限，然后使用路径运行</p>
<p>方法二：bash 脚本文件路径</p>
<p>方法三：source 脚本文件路径</p>
<p>2 自定义Shell变量时，有哪些注意事项？</p>
<p>可以包括数字、字母、下划线，不能以数字开头</p>
<p>赋值时等号两边不要有空格</p>
<p>尽量不要使用关键字和特殊字符</p>
<p>给同一个变量多次赋值时，最后一次的赋值生效</p>
<p>3 编写一个Shell脚本程序，用来报告当前用户的环境信息。</p>
<p>新建脚本文件report.sh，执行后能够输出当前的主机名、登录用户名、所在的文件夹路径。</p>
<p>#!/bin/bash</p>
<p>echo “当前的主机名是：$HOSTNAME”</p>
<p>echo “登录用户是：$USER”</p>
<p>echo “当前位于 $PWD 文件夹下”</p>
<p>4 简述预定义变量$$、$?、$#、$*的作用。</p>
<p>$$ 保存当前运行进程号</p>
<p>$? 保存命令执行结果的（返回状态）0是成功，非0是失败</p>
<p>$# 保存位置变量的（个数）</p>
<p>$* 保存所有位置变量的（值）</p>
<p>5 编写一个Shell脚本程序，能够部署ftp服务，并开启ftp默认共享的目录权限。</p>
<p>#!/bin/bash</p>
<p>yum -y install vsftpd &amp;&gt; /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>chmod 777 /var/ftp/pub</p>
<p>6 简述单引号、双引号、反撇号在变量赋值操作中的特点。</p>
<p>双引号 “ “：可以界定范围</p>
<p>单引号 ‘ ‘：可以界定范围，还可以屏蔽特殊符号，即便 $ 也视为普通字符</p>
<p>反撇号 <code> </code>：将命令的执行输出作为变量值</p>
]]></content>
  </entry>
  <entry>
    <title>shell03shell中的运算</title>
    <url>/2021/11/03/shell03/</url>
    <content><![CDATA[<p>shell中的运算</p>
<p>2，方法二用$[ ]结构，配合echo输出，同样可以实现加 减 乘 除 取余,另外$(( ))也可以实现相同效果</p>
<p>echo $[1+1]  或者  echo $((1+1))</p>
<p>echo $[2-1]</p>
<p>echo $[2*2]</p>
<p>echo $[4/2]</p>
<p>echo $[5%3]</p>
<p>3，方法三使用let指令，不输出计算结果，专用于创建变量，或者对变量进行自增减</p>
<p>用法一：创建变量</p>
<p>let a=1+1   创建变量a</p>
<p>用法二： 变量的自增减</p>
<p>常规写法  主流写法</p>
<p>let a=a+1    let a++    变量的自增减，将变量a的值加1</p>
<p>let a=a-1  let a–    变量a减1</p>
<p>let a=a+2        let a+=2   变量a加2</p>
<p>let a=a-2  let a-=2   变量a减2</p>
<p>let a=a<em>10  let a</em>=10  变量a乘以10</p>
<p>4，使用bc 计算器，可以进行小数运算</p>
<p>echo “1.1+1” | bc    //非交互的方式使用bc工具</p>
<p>echo “10/3” | bc</p>
<p>echo “scale=3;10/3” | bc   //scale可以定义小数点</p>
<p>后面的长度</p>
<hr>
<p>条件测试：可以为脚本提供智能判断的效果</p>
<p>使用方式：test  表达式   或者    [ 表达式 ]</p>
<p>条件测试种类：</p>
<p>1， 对字符串进行判断</p>
<p>可以使用的方式有： == 两边是否相等   != 两边是否不等  </p>
<p>-z判断变量是否为空  ! -z 判断变量是否非空</p>
<p>[ a == a ]  判断字符串a是否等于a，如果相等，echo $?的返回值就是0</p>
<p>[ root == $USER ]   判断当前用户名是否叫root，如果是，返回值就是0</p>
<p>[ root != $USER ]  判断当前用户名是否不叫root，如果不叫root，返回值就是0</p>
<p>[ -z $a ] 判断变量a是否为空，如果是，返回值是0</p>
<p>[ ! -z $a ] 判，返回断变量a是否非空，如果是值是0</p>
<p>2，逻辑符号，可以连接条件测试或者指令，来决定之后如何操作</p>
<p>&amp;&amp;  之前任务成功就执行之后任务</p>
<p>||   之前任务失败就执行之后任务</p>
<p>[ root == $USER ] || exit   如果当前用户不是管理员，则退出</p>
<p>ls || ls   只执行第1个ls  </p>
<p>ls &amp;&amp; ls   连个ls都执行</p>
<p>编写脚本可以创建用户和配置密码，如果用户没有输入用户名直接敲回车则结束脚本程序</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n</p>
<p>[ -z $n ] &amp;&amp; exit   //如果没有输入用户名就退出脚本，写法一</p>
<p>[ ! -z $n ] || exit   //如果没有输入用户名就退出脚本，写法二</p>
<p>useradd $n</p>
<p>stty -echo</p>
<p>read -p “请输入密码：” p</p>
<p>stty echo</p>
<p>echo $p | passwd –stdin $n</p>
<p>逻辑符号的组合应用</p>
<p>当2个逻辑符号连用时，第二个逻辑符号后面的任务是否执行不能只看前面一个任务，要看前面所有任务的组合，比如下列情况：</p>
<p>touch a b c //创建3个测试文件</p>
<p>ls a &amp;&amp; ls b &amp;&amp; ls c  //结果是都显示，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，然后会导致第二个逻辑符号&amp;&amp;后面的ls c 也执行并且成功。</p>
<p>ls a &amp;&amp; ls b || ls c  //结果是显示a和b，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，但是由于第二个逻辑符号是||，就不会执行最后的ls c任务了</p>
<p>ls a || ls b &amp;&amp; ls c   //结果是显示a和c，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，所以就会导致第二个逻辑符号&amp;&amp;后面的ls c执行</p>
<p>ls a || ls b || ls c   //结果是显示a，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，由于这个组合算成功，所以就不会执行第二个||后面的任务了</p>
<p>练习</p>
<p>安装ftp服务时，如果是非管理员执行该脚本则给出”非管理员无法执行</p>
<p>该脚本”的提示信息并退出</p>
<p>#!/bin/bash</p>
<p>#部署ftp服务</p>
<p>[ $USER != root ] &amp;&amp; echo “非管理员无法执行该脚本”  &amp;&amp; exit</p>
<p>yum -y install vsftpd  &amp;&gt; /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>3，数字的条件测试</p>
<p>-eq等于  -ne不等于  -gt大于  -ge大于等于  -lt小于  -le小于等于 </p>
<p>[ 1 -eq 1 ]  判断1是否等于1，判断成功的话返回值是0，判断失败返回</p>
<p>值是非0</p>
<p>a=10    </p>
<p>b=20</p>
<p>[ $a -eq $b ]    //判断两个变量是否相等</p>
<p>编写脚本，每隔2分钟检查登录服务器的账户数量，如果超过3</p>
<p>人，则发报警邮件给管理员，管理员可以通过mail命令查看邮件</p>
<p>#!/bin/bash</p>
<p>n=$(who | wc -l)    //统计登录服务器的账户数量，存在变量n里</p>
<p>[ $n -gt 3 ] &amp;&amp; echo “有人入侵服务器~，牛老师来了~~~” | mail -s test root</p>
<p>脚本写完后，执行下列指令：</p>
<p>rm -rf /var/spool/mail/root   //清空邮箱(非必须)</p>
<p>[root@svr7 opt]#chmod +x test01.sh   //给脚本添加执行权限</p>
<p>[root@svr7 opt]# crontab -e   //编写计划任务</p>
<p>*/2 * * * * /opt/test01.sh     //每2分钟执行脚本</p>
<p>然后故意多登陆几个账户，每2分钟就可以收到新邮件</p>
<p>4，文件的条件测试</p>
<p>-e判断是否存在不关心文件类型   -f判断是否存在且是普通文件  </p>
<p>-d判断是否存在且是目录  </p>
<p>-r判断当前用户对文件是否能读 ，对root无效</p>
<p>-w判断当前用户对文件是否能写 ，对root无效</p>
<p>-x 判断当前用户对文件是否能执行(文件)，或者进入(目录)</p>
<p>[  -e  a  ]   当前位置如果有a文件，不关心类型，则测试成功</p>
<p>[  -f  a  ]   当前位置如果有叫a的普通文件，则测试成功</p>
<p>[  -d  a  ]   当前位置如果有叫a的目录，则测试成功</p>
<p>[  -r  a  ]   当前用户如果对a文件有读权限，则测试成功</p>
<p>[  -w  a  ]   当前用户如果对a文件有写权限，则测试成功</p>
<p>[  -x  a  ]   当前用户如果对a文件有执行(目录是进入)权限，则测试成功</p>
<hr>
<p>虽然&amp;&amp;和||可以实现逻辑组合，但如果情况比较复杂就可能需要n多个&amp;&amp;或者||，会导致脚本难写，可读性差。此时就可以使用if分支</p>
<p>if分支</p>
<p>单分支<br>if 条件测试;then   //如果条件测试成功，那就执行下面的所有指令(指令可以有很多)</p>
<p>执行指令</p>
<p>执行指令</p>
<p>执行指令</p>
<p>。。。</p>
<p>fi</p>
<p>双分支<br>if 条件测试;then     //如果条件测试成功，那就执行下面的指令1</p>
<p>执行指令1</p>
<p>else       //如果上述条件测试失败，那就执行下面的指令2</p>
<p>执行指令2</p>
<p>fi</p>
<p>ping  -c 定义ping次数   -i 定义ping间隔时间(秒)   </p>
<p>-W 如果ping不通多久反馈结果(秒)</p>
<p>练习：编写脚本测试某ip是否能ping通，但不要显示过程，仅仅显示通了或者</p>
<p>不通即可</p>
<p>ping -c 3 -i 0.1 -W 1 192.168.4.7 &amp;&gt; /dev/null     //ping的具体过程扔黑洞不看</p>
<p>if [ $? -eq 0 ];then  //使用$?可以判断上面的任务是否成功，如果等于0就</p>
<p>是成功</p>
<p>        echo “通了！”</p>
<p>    else</p>
<p>        echo “不通！”</p>
<p>fi</p>
<p>多分支，适合更复杂的情况，结果会有很多的情况<br>if 条件测试;then     //如果条件测试成功，那就执行下面的指令1</p>
<p>执行指令1</p>
<p>   elif 条件测试;then    //如果条件测试成功，那就执行下面的指令2</p>
<p>      执行指令2</p>
<p>else       //如果上述条件测试失败，那就执行下面的指令3</p>
<p>执行指令3</p>
<p>fi</p>
<p>练习：</p>
<p>#!/bin/bash</p>
<p>read -p “请输入期末考试成绩：”  n</p>
<p>if [ $n -ge 90 ];then</p>
<p>        echo “优秀！”</p>
<p>elif [ $n -ge 80 ];then</p>
<p>        echo “良好！”</p>
<p>elif [ $n -ge 60 ];then</p>
<p>        echo “及格！”</p>
<p>else</p>
<p>        echo “晚上跪键盘~”</p>
<p>fi</p>
<p>循环：</p>
<p>有时我们需要某个或者某群任务反复在服务器中执行很多次，就可以使用循环命令写成脚本，而无需手工一次次执行</p>
<p>for循环 可以定义循环次数，有限的循环</p>
<p>基本语法格式：</p>
<p>for 变量名 in 值1 值2 值3 。。。。     //此处变量名可以自定义，通常习惯用i，值的多少决定了下面do与done之间的任务执行多少次，每个值之间有空格，这里是有3个值，所以就循环执行指令3次</p>
<p>do</p>
<p>指令     </p>
<p>done</p>
<hr>
<p>#!/bin/bash</p>
<p>for i in a b c     //给了abc三个值，下面的echo任务就循环三次</p>
<p>do</p>
<p>   echo “abc”</p>
<p>done</p>
<hr>
<p>#!/bin/bash</p>
<p>for i in {1..100}  //循环100次时无需填写100个值，用此格式即可，代表1到100，一共100个值   </p>
<p>do</p>
<p>   echo “abc”</p>
<p>   echo “$i”    //执行任务时，还可以调用变量，变量的值是所有值的轮询，由于这里给了1到100的值，那第一次循环$i就是1，第二次循环$i就是2，依次类推到第100次循环$i就是100</p>
<p>done</p>
<p>编写脚本，使用ping测试192.168.4.1~192.168.4.10，并显示通了或者不通，并且统计多少台通了，多少台不通</p>
<p>#!/bin/bash</p>
<p>x=0    //定义通了的数量,没测试之前是0台</p>
<p>y=0    //定义没通的数量,没测试之前是0台</p>
<p>for i in {1..10}</p>
<p>do</p>
<p>ping -c 3 -i 0.1 -W 1 192.168.4.$i &amp;&gt; /dev/null</p>
<p>if [ $? -eq 0 ];then</p>
<p>        echo “192.168.4.$i 通了！”</p>
<p>        let x++           //每通了一次就把x+1</p>
<p>else</p>
<p>        echo “192.168.4.$i 不通！”</p>
<p>        let y++            //每不通一次就把y+1</p>
<p>fi</p>
<p>done</p>
<p>echo “$x台通了，$y台不通”</p>
<p>练习：</p>
<p>1，列出常见的整数值比较操作，并说明各自作用。</p>
<p>2，运用条件测试操作，检查当前的用户是否为root。</p>
<p>3，绘图描述if双分支结构的执行流程。</p>
<p>4，[ -z $abc ] &amp;&amp; echo “yes” || echo “no” 可以实现什么测试效果。</p>
<p>参考答案</p>
<p>1，列出常见的整数值比较操作，并说明各自作用。</p>
<p>-eq 等于</p>
<p>-ne 不等于</p>
<p>-ge 大于等于</p>
<p>-le 小于等于</p>
<p>-gt 大于</p>
<p>-lt 小于</p>
<p>2，运用条件测试操作，检查当前的用户是否为root。</p>
<p>[ $USER == “root” ] &amp;&amp; echo “yes” || echo no</p>
<p>3，绘图描述if双分支结构的执行流程。</p>
<p>if双分支结构判断一次条件，当条件成立时执行分支1、若不成立则执行分支2，如图-1所示。</p>
<p>   </p>
<p>图-1</p>
<p>4，[ -z $abc ] &amp;&amp; echo “yes” || echo “no” 可以实现什么测试效果。</p>
<p>如果变量abc是空则显示yes，否则显示no</p>
]]></content>
  </entry>
  <entry>
    <title>shell04循环</title>
    <url>/2021/11/03/shell04/</url>
    <content><![CDATA[<p>如果在for循环中用变量定义循环次数的话</p>
<p>#!/bin/bash</p>
<p>a=20</p>
<p>for i in $(seq $a)     //如果循环次数有变量那么不能写成{1..$a}，要</p>
<p>用seq指令，可以生成数字序列且支持变量</p>
<p>do</p>
<p>        echo abc</p>
<p>        echo $i</p>
<p>done</p>
<hr>
<p>while循环，可以根据条件测试决定循环次数，可以实现无限循环</p>
<p>基本语法结构：</p>
<p>while 条件测试     //如果条件测试得到成功的结果就执行下面的指令，然后再回来继续看条件测试能否成功，如果成功就继续执行指令，且可以实现无限循环，一旦发现条件测试失败了，就立刻终止循环</p>
<p>do</p>
<p>         指令</p>
<p>done</p>
<hr>
<p>另外如果想故意创造一个无限循环可以在while后面写冒号即可</p>
<p>while :                         //冒号代表测试永远正确</p>
<p>do</p>
<p>    echo abc           //循环任务</p>
<p>    sleep 0.1    //如果系统执行任务消耗cpu比较多，可以每次稍微休息一下</p>
<p>done</p>
<hr>
<p>练习：使用while编写猜数脚本</p>
<p>#!/bin/bash</p>
<p>x=$[RANDOM%100]    //RANDOM是可以得到随机数的变量，除以100取余数可以得到零到99之间的随机数，并且存到变量x中</p>
<p>y=0     //这里还可以定义猜的次数，一次没猜时是0次</p>
<p>while :     //无限循环</p>
<p>do</p>
<p>let y++    //每猜一次，把y+1</p>
<p>read -p “请输入一个整数(0-99):” n        //将用户给的数字存到变量n中</p>
<p>if [ $n -eq$x ];then      //使用if多分枝加条件测试判断n是否等于x</p>
<p>        echo “恭喜！猜对了！猜了$y次”     //如果n等于x就喊出这句话</p>
<p>        exit</p>
<p>elif [ $n -gt $x ];then                           //如果n比x大</p>
<p>        echo “猜大了！”</p>
<p>else                                                          //还有最后一种情况</p>
<p>        echo “猜小了！”</p>
<p>fi</p>
<p>done</p>
<hr>
<p>case分支</p>
<p>功能类似if，不如if强大，语句比较精简</p>
<p>基本语法格式：</p>
<p>case 调用变量名 in                          //如果调用的变量内容与下面某个模式一致，就执行模式下面的指令</p>
<p>模式1)                                 //这里的模式可以有很多</p>
<p>         执行指令;;                //指令需要用双分号结尾，如果一个模式有多个指令，那只需在该模式的最后一条指令后加双分号即可</p>
<p>模式2)</p>
<p>         执行指令;;</p>
<p>…</p>
<p>*)                        //如果上述模式都没有被匹配，那就匹配这个</p>
<p>         执行指令</p>
<p>esac</p>
<p>练习：</p>
<p>测试case分支的实际应用</p>
<p>#!/bin/bash</p>
<p>case $1 in          //使用执行脚本后的第1个位置变量作为匹配对象</p>
<p>t|T|tt)                         //如果$1是t或者T或者tt，都可以算匹配</p>
<p>    touch $2;;         //此处是创建文件的命令，后面是第二个位置变量的参数</p>
<p>m|M|mm)</p>
<p>    mkdir $2;;</p>
<p>r)</p>
<p>    rm -rf $2;;</p>
<p>*)</p>
<p>    echo “请输入t|m|r”</p>
<p>esac</p>
<hr>
<p>部署nginx服务</p>
<p>httpd是之前使用过的网站服务，除此之外nginx也可以实现搭建网站的任务</p>
<p>1，将lnmp_soft.tar.gz软件包从真实主机拖拽到虚拟机的管理员家目录，然后释放</p>
<p>[root@svr7 ~]# tar -xf lnmp_soft.tar.gz  //释放到当前目录 </p>
<p>[root@svr7 ~]# cd lnmp_soft/    //然后到释放的目录中</p>
<p>[root@svr7 lnmp_soft]# cp nginx-1.17.6.tar.gz /opt    //将nginx拷贝到opt下</p>
<p>2，安装nginx</p>
<p>由于nginx是源码包，所以需要源码编译安装</p>
<p>编写部署nginx服务的脚本思路：</p>
<p>         1）安装依赖 gcc(编译工具)，pcre-devel，openssl-devel(后两个都是nginx所需依赖包)</p>
<p>         2）释放nginx-1.17.6.tar.gz</p>
<p>         3）进入nginx-1.17.6目录</p>
<p>         4）./configure    配置</p>
<p>         5）make     编译</p>
<p>         6）make install   安装</p>
<p>将上述过程编写成部署nginx服务的脚本</p>
<p>#!/bin/bash</p>
<p>yum -y install gcc pcre-devel openssl-devel &amp;&gt; /dev/null     //安装依赖软件包</p>
<p>tar -xf nginx-1.17.6.tar.gz                  //释放tar包</p>
<p>cd nginx-1.17.6     //进入nginx目录</p>
<p>./configure      //配置</p>
<p>make      //编译</p>
<p>make install    //安装</p>
<p>写完后保存退出，并执行脚本</p>
<p>ls /usr/local/nginx/     //检查nginx如果安装成功该目录会有文件</p>
<p>/usr/local/nginx/sbin/nginx    //开启nginx服务</p>
<p>使用火狐浏览器访问虚拟机可以看到nginx网页</p>
<p>提示：不要忘记关闭防火墙</p>
<p>systemctl stop firewalld</p>
<hr>
<p>编写脚本，使用case分支控制nginx服务</p>
<p>#!/bin/bash</p>
<p>case $1 in          //使用执行脚本后的第1个位置变量作为匹配对象</p>
<p>s|start|kai)   //如果$1是s或start或kai ，那么就执行以下指令</p>
<p>    netstat -ntulp | grep -q nginx   //查询有没有开启nginx服务, -q是不输出查询结果</p>
<p>    [ $? -eq 0 ] &amp;&amp; echo “nginx已经开启” &amp;&amp; exit     //判断如果开了nginx就退出</p>
<p>    /usr/local/nginx/sbin/nginx;;     //如果没开nginx就开启</p>
<p>stop|guan)    //如果$1是stop或guan，那么就执行以下指令：</p>
<p>    /usr/local/nginx/sbin/nginx -s stop;;     //关闭nginx</p>
<p>restart|cq)    //如果$1是restart或cq，那么就执行以下指令</p>
<p>    /usr/local/nginx/sbin/nginx -s stop   //关闭nginx</p>
<p>    /usr/local/nginx/sbin/nginx;;    //开启nginx，此处相当于重启nginx</p>
<p>status|cx)     //如果$1是status或cx，那么就执行以下指令</p>
<p>    netstat -ntulp | grep -q nginx  //查询有没有开启nginx服务, -q是不输出查询结果</p>
<p>    [ $? -eq 0 ] &amp;&amp; echo “nginx正在运行中。。”  || echo “nginx未开启”;;   //根据查询结果输出nginx正在运行或者nginx未开启的提示</p>
<p>*)</p>
<p>   echo “start|stop|restart”    //如果没有匹配任何模式就是喊出使用该脚本的提示，告诉使用者$1应该敲啥，而不能随意敲。</p>
<p>esac    //结尾，固定语法，不能少</p>
<p>netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：</p>
<p>-n以数字格式显示端口号</p>
<p>-t显示TCP连接的端口</p>
<p>-u显示UDP连接的端口</p>
<p>-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口</p>
<p>-p显示监听端口的服务名称是什么（也就是程序名称）</p>
<hr>
<p>如果想在linux中修改输出文字的颜色，可以使用下列方式</p>
<p>echo -e “\033[32mABCD\033[0m”     //-e选项可以激活后面特殊字符的作用，相当于使用echo的扩展功能，\033[32m代表设置颜色为绿色，ABCD是输入内容，\033[0m代表还原颜色。</p>
<p>函数，可以将公共的语句块使用一个函数名来定义，方便后期反复调用，达到精简脚本，增加可读性的目的</p>
<p>#!/bin/bash</p>
<p>a() {          //定义函数</p>
<p>echo abc</p>
<p>echo xyz</p>
<p>}</p>
<p>a    //调用函数，相当于执行上述两个echo任务</p>
<p>a    //可以反复调用</p>
<hr>
<p>#!/bin/bash</p>
<p>a() {                //定义函数</p>
<p>echo -e “\033[$1m$2\033[0m”     //输出不同颜色的文本内容，并加入位置变量</p>
<p>}</p>
<p>a 31 ABCD    //调用时函数后面可以写位置变量的内容，31就是$1  ABCD是$2</p>
<hr>
<p>控制循环</p>
<p>通常，在执行循环任务中途如果想退出可以用exit指令，但该指令不但会退出循环，连同脚本也会一并退出，此时可以使用break与continue指令更精细的控制循环。</p>
<p>exit  可以终止循环，同时脚本也退出</p>
<p>break  可以终止循环，继续执行循环之后的任务</p>
<p>continue  可以终止当前循环，继续下一次循环</p>
<p>练习：</p>
<p>编写脚本，可以为用户进行整数求和，如果输入0则退出并显示</p>
<p>之前求和的结果</p>
<p>#!/bin/bash</p>
<p>y=0   //先定义了一个y，表示用户给的整数之和，一个都没给时就是0</p>
<p>while :</p>
<p>do</p>
<p>read -p “请输入一个整数求和(0是结束并查看结果)”  n</p>
<p>[ -z $n ] &amp;&amp; continue                 //如果n是空值，就重新循环</p>
<p>[ $n -eq 0 ] &amp;&amp; break    //如果n是0，就退出循环</p>
<p>let y+=n    //将y+n</p>
<p>done</p>
<p>echo “整数之和是$y”    //喊出结果</p>
<hr>
<p>linux中很多地方都需要这样或着那样的去使用、管理、操作字符，多掌握在linux中字符的控制方法直接决定能否写好脚本与更好的控制linux系统。</p>
<p>1，字串截取的用法：</p>
<p>${变量名:起始位置:长度}</p>
<p>a=abcdef   //创建变量，作为截取素材</p>
<p>echo ${x:1:2}   //截取bc，位置是从0开始计算，所以要从1开始</p>
<p>才能截取第二个字符b</p>
<p>echo ${x:1:1}  //从第2个字符截取，截取1位</p>
<p>echo ${x:0:2}   //从第1个字符截取，截取2位</p>
<p>编写脚本，可以获取随机的8位字符（将来可以作为为用户配置随机密码时使用）</p>
<p>#!/bin/bash</p>
<p>x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789    //定义变量</p>
<p>for i in {1..8}     //循环8次</p>
<p>do</p>
<p>n=$[RANDOM%62]   //得到0-61之间的随机数</p>
<p>b=${x:n:1}   //随机截取一个x中的字符存储到变量b中</p>
<p>pass=$pass$b  //将每次获取的随机字符存储到变量pass中</p>
<p>done</p>
<p>echo $pass   //循环完8次之后，喊出最终结果，就得到了1个8位的字符</p>
<p>练习：</p>
<p>1，简述Linux服务脚本中的case分支结构。</p>
<p>2，简述定义一个Shell函数的任意一种方法。</p>
<p>3，简述Shell环境常见的中断及退出控制指令。</p>
<p>4，使用 while 循环,统计 1+2+3+4…+100的结果。</p>
<p>提示:可以用一个独立的变量a存放求和的值。</p>
<p>5，编写脚本,通过 3 个 read 命令读取用户输入的三个任意数字,脚本对输入的三个数字求和输出。</p>
<p>6，判断当前系统启动的进程数量,如果进程数量超过 100 个,则发送邮件给 root 报警。</p>
<p>7， 编写脚本,测试当前用户对/etc/passwd 文件是否具有读、写、执行的权限,让脚本执行结果类似下面的效果。</p>
<p>参考答案：</p>
<p>1，简述Linux服务脚本中的case分支结构。</p>
<p>case 变量名 in</p>
<p>模式1)</p>
<p>执行指令 ;;</p>
<p>模式2)</p>
<p>执行指令 ;;</p>
<p>*)</p>
<p>执行指令</p>
<p>esac</p>
<p>2，简述定义一个Shell函数的任意一种方法。</p>
<p>函数名() {</p>
<p>执行指令</p>
<p>}</p>
<p>3，简述Shell环境常见的中断及退出控制指令。</p>
<p>break：跳出当前所在的循环，执行循环之后的语句。</p>
<p>continue:跳过循环内余下的语句，执行下一次循环。</p>
<p>exit:退出脚本</p>
<p>4，使用 while 循环,统计 1+2+3+4…+100的结果。</p>
<p>提示:可以用一个独立的变量a存放求和的值。</p>
<p>#!/bin/bash</p>
<p>a=0</p>
<p>for i in {1..100}</p>
<p>do</p>
<p>let a+=i</p>
<p>done</p>
<p>echo $a</p>
<p>5，编写脚本,通过 3 个 read 命令读取用户输入的三个任意数字,脚本对输入的三个数字求和输出。</p>
<p>#!/bin/bash</p>
<p>read -p “请输入数字” num1</p>
<p>read -p “请输入数字” num2</p>
<p>read -p “请输入数字” num3</p>
<p>echo $[num1+num2+num3]</p>
<p>6，判断当前系统启动的进程数量,如果进程数量超过 100 个,则发送邮件给 root 报警。</p>
<p>(ps aux命令可以查看进程,wc -l可以统计数量)</p>
<p>#!/bin/bash</p>
<p>num=<code>ps aux | wc -l</code></p>
<p>[ $num -gt 100 ] &amp;&amp; echo “进程超过100啦～” | mail -s Warning root</p>
<p>7， 编写脚本,测试当前用户对/etc/passwd 文件是否具有读、写、执行的权限,让脚本执行结果类似下面的效果。</p>
<p>当前用户对/etc/passwd 有读权限</p>
<p>当前用户对/etc/passwd 有写权限</p>
<p>当前用户对/etc/passwd 无执行权限</p>
<p>#!/bin/bash</p>
<p>file=/etc/passwd</p>
<p>[ -r /etc/passwd ] &amp;&amp; echo “当前用户对$file 有读权限” || echo “当前用户对$file 没有读权限”</p>
<p>[ -w /etc/passwd ] &amp;&amp; echo “当前用户对$file 有写权限” || echo “当前用户对$file 没有写权限”</p>
<p>[ -x /etc/passwd ] &amp;&amp; echo “当前用户对$file 有执行权限” || echo “当前用户对$file 没有执行权限”</p>
]]></content>
  </entry>
  <entry>
    <title>shell05 awk和sed</title>
    <url>/2021/11/13/shell05/</url>
    <content><![CDATA[<p>1，grep  搜索</p>
<p>sed   增删改查</p>
<p>awk   精确搜索<br>2，字符串的替换</p>
<p>${变量名称/被替换内容/新内容}</p>
<p>a=1234              //定义素材</p>
<p>echo ${a/3/6}    //把3换成6</p>
<p>a=11223344    //定义素材</p>
<p>echo ${a/3/6}    //把3换成6,默认只换一个</p>
<p>echo ${a//3/6}   //使用两个/可以实现把所有3换成6</p>
<p>echo ${a//3/}   //把所有3换成空，相当于删除</p>
<p> 3，字符串的删除</p>
<p>${变量名称#被删除的内容}   从左往右删除    掐头</p>
<p>${变量名称%被删除的内容}   从右往左删除    去尾</p>
<p>a=abcdefg</p>
<p>echo ${a#abc} //从左往右删除到c</p>
<p>echo ${a#*c}             //效果同上，更精简</p>
<p>echo ${a#abcde}  //从左往右删除到e</p>
<p>echo ${a#*e}  //效果同上，更精简</p>
<p>a=abcxyzabcxyz </p>
<p>echo ${a#*b}   //从左往右删除到第一个b</p>
<p>echo ${a##*b}   //从左往右删除到最后一个b</p>
<p>a=abcdef</p>
<p>echo ${a%def}   //从右往左删除def</p>
<p>echo ${a%d*}    //效果同上，更精简</p>
<p>a=abcdefabcdef</p>
<p>echo ${a%%d*}   //从右往左删除到最后一个d</p>
<p>sed  流式编辑器，可以对文档进行非交互式增删改查，逐行处理</p>
<p>使用方式：</p>
<p>1，前置指令 | sed 选项 定址符 指令</p>
<p>2，sed 选项 定址符 指令  被处理的文档</p>
<p>选项： -n 屏蔽默认输出 -r 支持扩展正则  -i 写入文件</p>
<p>指令：p输出  d删除  s替换<br>sed    s 替换   （）粘贴   p  查看 d 删除  n 屏蔽  </p>
<p>还有 a行下追加   i行上添加   c替换整行</p>
<p>sed -n ‘1p’ user         //输出第1行</p>
<p>sed -n ‘2p’ user    //输出第2行</p>
<p>sed -n ‘3p’ user    //输出第3行</p>
<p>sed -n ‘2,4p’ user   //输出第2~4行</p>
<p>sed -n ‘2,+1p’ user  //输出第2行以及后面1行</p>
<p>sed -n ‘2p;4p’ user  //输出第2行，第4行</p>
<p>sed -n ‘/^root/p’ user  //在sed中使用正则表达式输出以root开</p>
<p>头的行，匹配的内容要写在两个斜杠中间</p>
<p>grep “^root” user  //效果同上</p>
<p>egrep “^root|^bin” user  //找root或者bin开头的行 </p>
<p>sed -nr ‘/^root|^bin/p’ user  //在sed中查找，-r使用扩展正</p>
<p>则，效果同上</p>
<p>sed -n ‘=’ user    //查看所有行号</p>
<p>sed -n ‘$=’ user   //查看最后一行的行号，相当于查看文档</p>
<p>总共有几行</p>
<p>sed  ‘1d’ user   //删第1行</p>
<p>sed  ‘d’ user   //删所有</p>
<p>sed  ‘3d’ user  //删第3行</p>
<p>sed  ‘2,5d’ user   //删2~5行</p>
<p>sed  ‘4,+2d’ user  //删4行以及后面2行</p>
<p>sed  ‘1d;3d’ user   //删第1行，第3行</p>
<p>sed  ‘$d’ user   //删除最后一行</p>
<p>sed -n ‘$p’ user  //查看最后一行</p>
<p>sed -n ‘1!p’ user   //查看除了第1行以外的行, !代表取反</p>
<p>sed  ‘/root/d’  user  //删除含有root的行</p>
<p>sed ‘1!d’ user  //删掉除第1行以外的行</p>
<p><a href="https://gitee.com/tedu-nsd-linux/nsd2009">https://gitee.com/tedu-nsd-linux/nsd2009</a></p>
<p>regular.pdf    正则表达式练习题</p>
<p>regular_express.txt   正则表达式练习素材</p>
<p>练习：</p>
<p>1 简述grep工具的-q选项的含义（egrep同样适用）。</p>
<p>2 正则表达式中的+、？、*分别表示什么含义？</p>
<p>3 如何编写正则表达式匹配11位的手机号？</p>
<p>4 简述sed定址符的作用及表示方式。</p>
<p>参考答案：</p>
<p>1 简述grep工具的-q选项的含义（egrep同样适用）。</p>
<p>选项-q的作用是静默、无任何输出，效果类似于正常的grep操作添加了&amp;&gt; /dev/null来屏蔽输出</p>
<p>2 正则表达式中的+、？、*分别表示什么含义？</p>
<p>这三个字符用来限制前面的关键词的匹配次数，含义分别如下：</p>
<p>•       +：最少匹配一次，比如a+可匹配a、aa、aaa等</p>
<p>•       ？：最多匹配一次，比如a?可匹配零个或一个a</p>
<p>•       <em>：匹配任意多次，比如a</em>可匹配零个或任意多个连续的a</p>
<p>3 如何编写正则表达式匹配11位的手机号？</p>
<p>准备测试文件：</p>
<p>1.      [root@svr5 ~]# cat tel.txt</p>
<p>2.      01012315</p>
<p>3.      137012345678</p>
<p>4.      13401234567</p>
<p>5.      10086</p>
<p>6.      18966677788</p>
<p>提取包含11位手机号的行：</p>
<p>1.      [root@svr5 ~]# egrep ‘^1[0-9]{10}$’ tel.txt</p>
<p>2.      13401234567</p>
<p>3.      18966677788</p>
<p>4 简述sed定址符的作用及表示方式。</p>
<p>作用：定址符（执行指令的条件）控制sed需要处理文本的范围；不加则逐行处理所有行</p>
<p>表示方式：定址符可以使用行号或正则表达式</p>
<p>awk 选项 条件 指令 被处理文档</p>
<p>选项  -F  指定分隔符</p>
<p>指令  print 输出   </p>
<p>awk ‘{print}’ nssw.txt    //输出文档所有内容</p>
<p>awk ‘/the/{print}’ nssw.txt      //输出有the的行</p>
<p>awk ‘/root/{print}’ /etc/passwd    //输出有root的行</p>
<p>df -h | awk ‘//$/{print}’   //先使用df指令输出磁盘相关</p>
<p>信息，然后交给awk输出含有/结尾的行</p>
<p>$0所有列  $1第1列  $2第2列  $3  …. </p>
<p>NR行号   NF列号</p>
<p>awk ‘{print $0,$1}’ nssw.txt  //找所有行的所有列和第1列</p>
<p>awk ‘{print NR}’ nssw.txt  //输出每行的行号</p>
<p>awk -F: ‘{print $1 “ 的家目录是 “ $6}’  user  //使用冒号作为分隔符,输出</p>
<p>第1列，第6列，中间加常量，常量要使用双引号</p>
]]></content>
  </entry>
  <entry>
    <title>linux应急实战</title>
    <url>/2022/01/04/linux%E5%BA%94%E6%80%A5%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<pre><code>                                                           Linux入侵排查
</code></pre>
<p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系<br>统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回<br>或减少经济损失。<br>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些Linux服务器入侵排查的思路。<br>1.入侵思路排察<br>1.1账户安全<br>（1）./etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>account:password:UID:GID:GECOS:directory:shell<br>用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell<br>注意：无密码只允许本机登陆，远程不允许登陆<br>（2）、影子文件/etc/shadow<br>root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV<br>9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::<br>用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之<br>后的宽限天数：账号失效时间：保留</p>
<p>用户组的所有信息都存放在/etc/group文件中<br>组名:口令:组标识号:组内用户列表 </p>
<p>命令： who 查看当前登录用户（tty本地登陆 pts远程登录）<br>            w 查看系统信息，想知道某一时刻用户的行为<br>           uptime 查看登陆多久、多少用户，负载<br>入侵排查<br>1.查询特权用户（uid为0）<br> awk -F: ‘$3==0{print $1}’   /etc/passwd<br>2、查询可以远程登录的帐号信息<br> awk   ‘/$1|$6/{print $1}’   /etc/shadow<br>3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限<br> more /etc/sudoers | grep -v “^#|^$” | grep “ALL=(ALL)”<br>4、禁用或删除多余及可疑的帐号<br>usermod -L user 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头<br>userdel user 删除user用户<br>userdel -r user 将删除user用户，并且将/home目录下的user目录一并删除</p>
<p>1.2历史命令<br>通过.bash_history查看帐号执行过的系统命令<br>1、root的历史命令<br>histroy<br>2、打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令<br>为历史的命令增加登录的IP地址、执行命令时间等信息：<br>1）保存1万条命令<br>sed -i ‘s/^HISTSIZE=1000/HISTSIZE=10000/g’ /etc/profile<br>2）在/etc/profile的文件尾部添加如下行数配置信息：<br>######jiagu history xianshi#########<br>USER_IP=<code>who -u am i 2&gt;/dev/null | awk &#39;&#123;print $NF&#125;&#39; | sed -e &#39;s/[()]//g&#39;</code><br>if [ “$USER_IP” = “” ]<br>then<br>USER_IP=<code>hostname</code><br>fi<br>export HISTTIMEFORMAT=”%F %T $USER_IP <code>whoami</code> “<br>shopt -s histappend<br>export PROMPT_COMMAND=”history -a”<br>######### jiagu history xianshi ##########<br>3）source /etc/profile让配置生效<br>生成效果： 1 2018-07-10 19:45:39 192.168.204.1 root source /etc/profile<br>3、历史操作命令的清除：history -c<br>但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录。</p>
<p>入侵排察<br>进入用户目录下<br>cat .bash_history &gt;&gt; history.txt<br>1.3检查异常端口<br>PID 代表进程标识号。<br>使用netstat 网络连接命令，分析可疑端口、IP、PID<br>netstat -antlp|more<br>查看下pid所对应的进程文件路径，<br>运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号）<br>1.4检查异常进程<br>使用ps  aux   |  grep pid  分析进程<br>1.5检查开机启动项<br>运行级别<br>0         关机<br>1     单机模式<br>2     不安全的命令行模式<br>3      安全的命令行模式<br>4      系统保留<br>5      图形模式<br>6      重启动<br>查看运行级别命令 runlevel<br>系统默认允许级别<br>vi   /etc/inittab<br>id=3：initdefault 系统开机后直接进入哪个运行级别<br>开机启动配置文件<br>/etc/rc.local<br>/etc/rc.d/rc[0<del>6].d<br>例子:当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链<br>接即可<br>root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh<br>此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行<br>级别加载时需要关闭的。<br>入侵排查：<br>启动项文件： more /etc/rc.local /etc/rc.d/rc[0</del>6].d ls -l /etc/rc.d/rc3.d/<br>1.6、利用crontab创建计划任务<br>基本命令<br>-l  列出某个用户cron服务的详细内容<br>-r  删除每个用户cront任务<br>-e   使用编译器编译当前的crontab文件。<br>crontab -e 使用编辑器编辑当前的crontab文件<br>如：*/1 * * * * echo “hello world” &gt;&gt; /tmp/test.txt 每分钟写入文件<br>入侵排查<br>重点关注以下目录中是否存在恶意脚本<br>/var/spool/cron/*<br>/etc/crontab<br>/etc/cron.d/*<br>/etc/cron.daily/*<br>/etc/cron.hourly/*<br>/etc/cron.monthly/*<br>/etc/cron.weekly/<br>/etc/anacrontab<br>/var/spool/anacron/*<br>小技巧：<br>more /etc/cron.daily/* 查看目录下所有文件<br>1.7检查服务<br>服务自启动<br>第一种修改方法：<br>chkconfig [–level 运行级别] [独立服务名] [on|off]<br>chkconfig –level 2345 httpd on 开启自启动<br>chkconfig httpd on （默认level是2345）<br>Linux chkconfig 命令用于检查，设置系统的各种服务。<br>–add 　增加所指定的系统服务，让 chkconfig 指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。<br>–del 　删除所指定的系统服务，不再由 chkconfig 指令管理，并同时在系统启动的叙述文件内删除相关数据。<br>–level&lt;等级代号&gt; 　指定读系统服务要在哪一个执行等级中开启或关毕。<br>列出chkconfig 所知道的所有命令。</p>
<h1 id="chkconfig-–list"><a href="#chkconfig-–list" class="headerlink" title="chkconfig –list"></a>chkconfig –list</h1><p>第二种修改方法：<br>修改/etc/re.d/rc.local 文件<br>加入 /etc/init.d/httpd start<br>第三种修改方法：<br>使用ntsysv命令管理自启动，可以管理独立服务和xinetd服务。<br>日志默认存放位置：/var/log/<br>查看日志配置情况：more /etc/rsyslog.conf</p>
]]></content>
  </entry>
  <entry>
    <title>web安全01</title>
    <url>/2022/01/10/web%E5%AE%89%E5%85%A8day01/</url>
    <content><![CDATA[<p>第一节<br>1.交换机<br>什么是交换机：<br>交换机是用来连接局域网的主要设备<br>交换机能够根据以太网帧中目的地址只能的转发数据，因此交换机工作在数据链路层。<br>交换机工作原理：<br>交换机的转发原理：<br>（1）.初始状态<br>（2）.MAC地址学习<br>（3）.广播位置数据帧<br>（4）.接收方回应<br>（5）.交换机实现单播通信<br>转发，学习，广播，更新<br>交换机里面有 ARP (地址解析协议) 缓存表：根据 IP 地址获取物理地址的 TCP/IP 协议。<br>里面存放了 IP 地址、MAC 地址。主机发送信息时将包含 IP 地址的 ARP 请求广播到局域网上的所有主机，并接受返回消息，以此来确定目标的物理地址，收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一段时间，下次请求时直接查询 ARP 表以节约资源<br>2.路由器<br>路由器里面由路由表：包含三个元素，目的地址，掩码，下一跳地址，功能是路由寻址，对不同的网络之间的数据包进行存储、分组转发处理。<br>是连接两个或多个网络的硬件设备，在网络间起到网关的作用，分析不同类型网络传来的数据包的目的地址，把非 TCP/IP 网络的地址转换成 TCP/IP 地址，或者反之；<br>再根据选定的路由算法把各数据包按最佳路线传送到指定位置。<br>路由器原理及配置：<br>什么是路由器：</p>
<ol>
<li>将数据包从一个网络发送到另一个网络<br>(1)    需要依靠路由器来完成<br>(2)    路由器只关心网络的状态，决定最佳路径</li>
<li>路由器可以根据路由表选择最佳路径<br>(1)    每个路由器都维护这一张路由表，这是路由器转发数据包的关键<br>(2)    每条路由表记录指明了：到达某个子网或主机应从路由器的那个物理接口发送，通过此接口可达该路径的下一个路由器的地址（或直接相连网络中的目标主机地址）</li>
</ol>
<p>如何获得路由表：</p>
<ol>
<li>静态、默认路由<br>(1)    由管理员在路由器上手工指定<br>(2)    适合分支机构、家具办公等小型网络</li>
<li>动态路由<br>(1)    根据网络拓扑或流量变化，由路由器通过路由协议自动设置<br>(2)    适合ISP服务厂商、广域网、园区网等大型网络<br>静态路由：</li>
<li>主要特点：<br>(1)    有管理员手工配置，为单向条目<br>(2)    通信双方的边缘路由器都需要指定，否则会导致数据包有去无回<br>路由器和交换机的对比</li>
</ol>
<p>*路由器工作在网络层<br>*交换机工作在数据链路层<br>3.访问控制列表 ACL (包过滤)<br>访问控制列表<br>应用于路由器接口的指令列表，用于指定哪些数据包可以接收转发，那些数据包需要拒绝<br>acl的作用<br>（1）提供网络访问的基本安全手段<br>（2）可以控制数据流量<br>（3)控制通信量<br>4.设备与层对应的关系<br>应用层               计算机/防火墙<br>传输层               防火墙<br>网络层               路由器<br>数据链路层        交换机<br>物理层               网卡<br>物理层：传输比特流数据。将 1、0 转化为电流强弱来进行传输，达到目的地之后在转化成 1、0。主要定义物理设备标准，如网线的接口类型，各种传输介质的传输速率。<br>数据链路层：传输数据帧。接收来自物理层的比特流的数据，通过差错控制等方法传输到网络层，也接收来自上层的数据，封装成数据帧的形式转发到物理层，以便提供可靠的数据传输。主要功能为建立逻辑连接、进行硬件地址寻址、差错校验等功能。<br>网络层：传输数据包。主要是进行逻辑地址寻址，实现不同网络之间的物理选择。<br>传输层：传输报文。向用户提供可靠的端到端的差错控制和流量控制，保证报文的正确传输。主要功能为定义传输数据的协议端口号，以及流量控制和差错校验。<br>会话层：负责建立、管理和终止表示层实体之间的对话。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密。<br>应用层：提供用户接口，使得用户能够与网络进行交互式联系，实现各种服务，完成和实现用户请求的各种服务。</p>
]]></content>
  </entry>
  <entry>
    <title>web安全笔记day02</title>
    <url>/2022/01/14/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day02/</url>
    <content><![CDATA[<p>一。数据封装过程<br>应用层     PDU<br>传输层     数据<br>网络层     报文<br>数据链路层    帧<br>物理层      比特<br>（1）封装：<br>数据要通过网络进行传输，要从高层一层一层的向下传输，如果一个主机要传送数据到别的主机，则先把数据装到一个特殊的协议报头中，整个过程叫封装。<br>比如数据在表示层向下传输，先经过传输层封装一个 TCP/UDP 头，再经过网络层封装一个 IP 头，继续向下传输经过数据链路层时再封装一个 MAC 头，最后在物理层转化为比特流进行传输。<br>（2）解封装：<br>封装的逆向过程即为解封装。数据封装成帧后，发到传输介质上，达到目标主机后，每层协议剥掉相应的头部，最后将应用层数据交给应用程序处理。<br>比如比特流在物理层向上传输，先经过数据链路层解封成帧并剥掉 MAC 头，再经过网络层解封成报文并剥掉 IP 头，继续向上传输经过传输层解封成数据并剥掉 TCP/UDP 头，最后传输给应用层。<br>TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 IP 协议、ICMP 协议、TCP 协议、以及 http、ftp、pop3、https 协议等，网络中的计算机都采用这套协议族进行互联。<br>二。协议<br>（1）ping命令<br>ping命令 用来测试主机之间网络的连通性。<br> 执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。<br>网络层的协议有 ICMP、IP 和 ARP(地址解析协议)，<br>传输层的协议有 TCP 和 UDP、<br>应用层的协议有 HTTP、HTTPS、FTP、DNS、SMTP、POP3、Telnet、SSH 和 TFTP 协议。<br>（2）ARP协议<br>在局域网中，当主机或者其他网络设备有数据要发送给另一个主机或者设备的时候，必须要知道对方的 IP 地址或者 MAC 地址，而 ARP 协议就是将 IP 地址转换成 MAC (物理) 地址的协议。</p>
<p>地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送 ARP 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 ARP 缓存；由此攻击者就可以向某一主机发送伪 ARP 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 ARP 欺骗。</p>
<p>ARP报文：ARP 报文分为 ARP 请求报文和 ARP 应答报文<br>（3）ip协议<br>在 TCP/IP 协议中，使用 IP 协议传输数据的包被称为 IP 数据包，每个数据包都有包含 IP 协议规定的内容，这些内容被称为 IP 数据报文或者 IP 数据报，这些 IP 数据报文由首部和数据两部分组成。首部的前一部分为固定长度，共 20 字节，是所有 IP 数据报必须具有的，而另一部分为可选部分，其长度是可变的。<br>（4）ICMP 协议<br>ICMP 协议用于用户在 IP 主机、路由器之间传递控制消息，判断网络是否连通、主机是否可达、路由是否可用等。<br>ICMP 本意是希望对 IP 包无法传输时提供报告，这些差错报告帮助了发送方了解为什么无法传递，网络发送了什么问题，以及确定应用程序的后续操作。<br>ICMP 协议是 IP 协议的一个子协议，ICMP 报文包含在 IP 数据报中，IP 报头在 ICMP 报文的最前面。<br>一个 ICMP 报文至少包括: IP 报头 (至少 20 字节)、ICMP 报头 (至少 8 字节) 和 ICMP 报文 (属于 ICMP 报文的数据部分)，当 IP 报头中的协议字段为 1 时说明这是一个 ICMP 报文。<br>（5）tcp协议<br>TCP 协议是一种面向连接的、可靠的、基于字节流的、全双工的传输层通信协议。TCP 协议是 TCP/IP 体系结构中最主要的传输层协议<br>TCP 三次握手和四次挥手<br>（6）udp协议<br>UDP 协议是一种面向无连接的、 不可靠的、基于报文的传输层通信协议。不需要向 TCP 那样需要服务器监听，也不必等待客户端与服务端建立连接。<br>(7)DNS协议<br>DNS 协议是用来将域名解析到 IP 地址的一种协议，基于 TCP 和 UDP 的协议，端口号为 53，用户到服务器采用 UDP，服务器通信采用 TCP。可以通过 nslookup 命令来查询域名对应的 IP 地址。<br>（8）http协议<br>HTTP 协议是超文本传输协议，是客户端浏览器或者其他程序与 Web 服务器之间的应用层通信协议，通过 HTTP 实现数据在 Internet 上的发送和接收<br>（9）https协议<br>HTTPS 协议基于 HTTP 协议，通过 SSL 或者 TLS 来提供加密处理数据，验证对方身份和保证数据完整性。</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday11权限和（软和硬）连接</title>
    <url>/2021/11/13/linuxday11%E6%9D%83%E9%99%90%E5%92%8Cchmod/</url>
    <content><![CDATA[<p>权限</p>
<p>一、环境准备</p>
<p> 还原快照，开启CentOS7虚拟机，利用root登录</p>
<p>二、挂载光驱设备</p>
<p>1.图形将光盘文件放入，虚拟机光驱设备</p>
<p>2.mount进行挂载</p>
<p>]# mkdir  -p   /os/centos</p>
<p>]# mount    /dev/cdrom       /os/centos</p>
<p>]# ls     /os/centos</p>
<p>3.构建Yum仓库</p>
<p>]# rm  -rf   /etc/yum.repos.d/*</p>
<p>]# vim   /etc/yum.repos.d/dvd.repo</p>
<p>[xixi]</p>
<p>name=haha</p>
<p>baseurl=file:///os/centos</p>
<p>enabled=1</p>
<p>gpgcheck=0</p>
<p>]# yum   -y   install   gcc     #测试安装软件</p>
<p>三、命令的补充</p>
<p>制作连接(链接)文件（快捷方式）<br>软连接：ln  -s   /路径/源数据    /路径/快捷方式名</p>
<p>]# ls  /etc/sysconfig/network-scripts/</p>
<p>]# ln -s /etc/sysconfig/network-scripts/     /ns</p>
<p>]# ls /</p>
<p>]# ls -l   /ns      #查看快捷方式的详细信息</p>
<p>]# ls   /ns</p>
<p>软连接优势：1.可以对目录制作快捷方式   2.可以跨分区</p>
<p>软连接缺点：源数据消失，快捷方式不可用</p>
<p>硬链接：ln    /路径/源数据     /路径/快捷方式名</p>
<p>]# rm -rf   /opt/*</p>
<p>]# echo 123  &gt;  /opt/A</p>
<p>]# ln -s  /opt/A    /opt/B   #软连接</p>
<p>]# ls /opt/</p>
<p>]# ln   /opt/A     /opt/C    #硬链接</p>
<p>]# ls   /opt/</p>
<p>]# cat   /opt/B      #查看软连接    </p>
<p>]# cat   /opt/C      #查看硬链接    </p>
<p>]# rm -rf  /opt/A</p>
<p>]# ls   /opt/</p>
<p>]# cat   /opt/B      #软连接不可用</p>
<p>cat: /opt/B: 没有那个文件或目录</p>
<p>]# cat   /opt/C      #硬链接可用</p>
<p>硬链接优点：源数据消失，快捷方式仍然可用</p>
<p>硬链接缺点：1.不可以对目录制作快捷方式   2.不可以跨分区</p>
<p>zip归档压缩(跨平台压缩格式)<br>归档+压缩操作<br>zip  [-r]  备份文件.zip   被归档的文档…<br>]# zip  -r   /root/test.zip      /home/    /boot/</p>
<p>]# ls   /root/</p>
<p>释放归档+解压操作<br>unzip  备份文件.zip  [-d 目标文件夹] <br>]# mkdir   /bh</p>
<p>]# unzip   /root/test.zip        -d     /bh</p>
<p>]# ls   /bh</p>
<p>四、用户相关配置文件</p>
<p>配置文件来源<br>新建用户时，根据 /etc/skel 模板目录复制<br>]# touch   /etc/skel/hahaxixi.txt</p>
<p>]# touch   /etc/skel/maohehaozi.txt</p>
<p>]# touch   /etc/skel/shukehebeita.txt</p>
<p>]# ls  -A   /etc/skel/</p>
<p>]# useradd   tom</p>
<p>]# ls  -A   /home/tom/</p>
<p>主要的初始配置文件<br>~/.bash_profile：每次登录系统时执行<br>~/.bashrc：每次开启新的命令行终端时执行</p>
<p>全局配置文件：/etc/bashrc、/etc/profile</p>
<p>]# vim    /root/.bashrc    #定义永久的别名</p>
<p>alias    hn=’hostname’</p>
<p>新开一个终端进行验证</p>
<p>]# hn</p>
<p>localhost.localdomain</p>
<p>]# vim    /etc/bashrc      #影响全体用户</p>
<p>alias    xixi=’echo    xixihahahehe’</p>
<p>新开一个终端进行验证            </p>
<p>[root@localhost ~]# xixi</p>
<p>[root@localhost ~]# su - tom</p>
<p>[tom@localhost ~]$ xixi</p>
<p>[tom@localhost ~]$ exit</p>
<p>[root@localhost ~]#</p>
<p>五、基本权限和归属</p>
<p>基本权限<br>访问权限<br>读取：允许查看内容-read   r<br>写入：允许修改内容-write   w<br>可执行：允许运行和切换-excute  x<br>针对文本文件<br>        r：查看内容cat   less  head  tail  grep</p>
<p>        w：修改内容vim   &gt;&gt;   &gt;</p>
<p>        x：Shell脚本  Python脚本</p>
<p>归属关系<br>所有者：拥有此文件/目录的用户-user<br>所属组：拥有此文件/目录的组-group<br>其他用户：除所有者、所属组以外的用户-other</p>
<p>zhangsan (所有者)   zhangsan(所属组)        1.txt</p>
<p>执行 ls  -l .. .. 命令查看<br>权限位   硬连接数   属主   属组   大小   最后修改时间   文件/目录名称</p>
<p>    以-开头表示文本文件</p>
<p>    以d开头表示目录</p>
<p>    以l开头表示快捷方式</p>
<p>]# ls  -l   /etc/passwd</p>
<p>]# ls  -l   /etc/shadow</p>
<p>]# ls  -ld  /etc</p>
<p>]# ls  -ld   /root</p>
<p>]# ls  -ld   /tmp    #默认具备特殊权限的目录</p>
<p>六、权限的设置</p>
<p>chmod命令<br>格式：chmod  [ugoa] [+-=][rwx]  文件…<br>常用命令选项<br>-R：递归修改权限</p>
<p>]# mkdir    /nsd01</p>
<p>]# chmod   u-w  /nsd01   #单独修改所有者权限</p>
<p>]# ls   -ld   /nsd01</p>
<p>]# chmod    g+w    /nsd01  #单独修改所属组权限</p>
<p>]# ls   -ld   /nsd01</p>
<p>]# chmod   o=—   /nsd01   #单独修改其他人权限</p>
<p>]# ls   -ld   /nsd01</p>
<p>]# chmod   u=rwx,g-w,o=rx    /nsd01</p>
<p>]# ls   -ld   /nsd01</p>
<p>]# chmod   a=rwx  /nsd01   #所有人赋予rwx权限</p>
<p>]# ls   -ld   /nsd01</p>
<p>]# mkdir -p   /opt/aa/bb/cc</p>
<p>]# ls   -ld   /opt/aa</p>
<p>]# ls   -ld   /opt/aa/bb/</p>
<p>]# ls   -ld   /opt/aa/bb/cc</p>
<p>]# chmod -R  o=—   /opt/aa    #递归设置权限</p>
<p>]# ls   -ld   /opt/aa</p>
<p>]# ls   -ld   /opt/aa/bb/</p>
<p>]# ls   -ld   /opt/aa/bb/cc/</p>
<p>Linux判断用户具备的权限:  <br>首先判断用户对于该数据，所处的角色(顺序：所有者&gt;所属组&gt;其他人  原则是匹配及停止)<br>查看相应角色的权限位</p>
<p>对于目录权限的影响：        </p>
<p>     r：可以查看目录下内容</p>
<p>     w：可以新建、删除、改名此目录下内容</p>
<p>     x：可以cd切换到此目录(一个用户能否切换到目录只和x执行权限有关)</p>
<p>案例1：设置基本权限</p>
<p>1）以root身份新建/nsddir1/目录，在此目录下新建readme.txt文件</p>
<p>[root@localhost ~]# mkdir /nsddir1</p>
<p>[root@localhost ~]# echo 123456 &gt; /nsddir1/readme.txt</p>
<p>[root@localhost ~]# cat /nsddir1/readme.txt</p>
<p>2）使用户zhangsan能够修改readme.txt文件内容</p>
<p>[root@localhost ~]# chmod  o+w  /nsddir1/readme.txt</p>
<p>3）使用户zhangsan不可以修改readme.txt文件内容</p>
<p>[root@localhost ~]# chmod  o-w  /nsddir1/readme.txt</p>
<p>4）使用户zhangsan能够在此目录下创建/删除子目录</p>
<p>[root@localhost ~]# chmod  o+w   /nsddir1/</p>
<p>[root@localhost ~]# ls  -ld  /nsddir1/</p>
<p>5）调整此目录的权限，使任何用户都不能进入，然后测试用户zhangsan是否还能修改readme.txt（测试结果不能，对父目录没有权限）</p>
<p>[root@localhost ~]# chmod  a-x   /nsddir1/</p>
<p>6）为此目录及其下所有文档设置权限 rwxr-x—</p>
<p>[root@localhost ~]# chmod -R u=rwx,g=rx,o=—  /nsddir1/</p>
<p>七、归属的设置</p>
<p>chown命令<br>chown  属主  文件…<br>chown  属主:属组  文件…<br>chown  :属组  文件…<br>常用命令选项<br>-R：递归修改归属关系<br>]# mkdir   /nsd04</p>
<p>]# useradd   kenji         #创建用户kenji</p>
<p>]# groupadd   tmooc   #创建组tmooc</p>
<p>]# ls  -ld   /nsd04</p>
<p>]# chown  kenji:tmooc   /nsd04</p>
<p>]# ls  -ld   /nsd04</p>
<p>]# chown   zhangsan   /nsd04   #设置所有者</p>
<p>]# ls  -ld    /nsd04</p>
<p>]# chown   :root   /nsd04    #设置所属组</p>
<p>]# ls  -ld    /nsd04</p>
<p>案例：</p>
<p>实现lisi用户可以读取/etc/shadow文件内容，您有几种方法？</p>
<p>   1.利用其他用户</p>
<p>    ]# chmod  o+r   /etc/shadow</p>
<p>   2.利用所属组</p>
<p>]# chown   :lisi    /etc/shadow</p>
<p>]# chmod  g+r   /etc/shadow</p>
<p>   3.利用所有者</p>
<p>]# chown   lisi    /etc/shadow</p>
<p>]# chmod  u+r   /etc/shadow</p>
<p>八、权限数字表示</p>
<p>权限位的8进制数表示<br>r、w、x分别对应4、2、1，后3组分别求和</p>
<p>]# mkdir   /nsd06</p>
<p>]# ls  -ld   /nsd06</p>
<p>]# chmod   700   /nsd06</p>
<p>]# ls -ld /nsd06</p>
<p>]# chmod   750   /nsd06</p>
<p>]# ls -ld /nsd06</p>
<p>]# chmod   007   /nsd06</p>
<p>]# ls -ld /nsd06</p>
<p>新建文件/目录的默认权限<br>一般文件默认均不给 x 执行权限<br>其他取决于 umask（权限掩码） 设置<br>文件默认权限为644<br>目录默认权限为755</p>
<p>九、附加权限（特殊权限）</p>
<p>粘滞位，Sticky Bit 权限<br>占用其他人（Other）的 x 位<br>显示为 t 或 T，取决于其他人是否有 x 权限<br>适用于目录，用来限制用户滥用写入权<br>在设置了粘滞位的文件夹下，即使用户有写入权限，也不能删除或改名其他用户文档</p>
<p>]# mkdir    /home/public        </p>
<p>]# chmod   777   /home/public</p>
<p>]# ls   -ld   /home/public</p>
<p>]# chmod  o+t  /home/public    #赋予特殊权限</p>
<p>]# ls  -ld  /home/public</p>
<p>SGiD权限<br>占用属组（Group）的 x 位<br>显示为 s 或 S，取决于属组是否有 x 权限<br>对目录有效<br>在一个具有SGID权限的目录下，新建的文档会自动继承此目录的属组身份</p>
<p>]# mkdir    /nsd14</p>
<p>]# chown   :tmooc    /nsd14</p>
<p>]# ls   -ld   /nsd14</p>
<p>]# mkdir    /nsd14/abc01</p>
<p>]# ls   -ld    /nsd14/abc01    #查看所属组</p>
<p>]# chmod   g+s   /nsd14     #赋予特殊权限SGID</p>
<p>]# ls   -ld    /nsd14</p>
<p>]# mkdir   /nsd14/abc02     </p>
<p>]# ls   -ld    /nsd14/abc02      #查看所属组</p>
]]></content>
  </entry>
  <entry>
    <title>linux补充知识</title>
    <url>/2022/01/16/linux%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>关闭selinux ： setenforce  0<br>selinux 三种模式<br>1.enforcing   强制模式   1<br>2.permissive  宽松模式  0<br>3.disabled   关闭模式<br>关闭防火墙：firewall-cmd –set-default-zone=trusted<br>systemctl stop firewalld<br>变量<br>环境变量env<br>set观察所有变量<br>PS1    提示字符的设置<br>列如PS1=’[\u@\h\w\A##]$‘<br>\u目前用户的账号名称。<br>\h<br>\w完整的工作名称<br>\A显示时间，为24小时格式。<br>#执行的第几个命令<br>$ 提示符</p>
<p>export 也是变量的<br>locale 语系变量<br>修改：cat /etc/locale.conf</p>
<p>declare 声明变量类型<br>declare -i sum=10+10 声明整数变量<br> echo ${sum}<br>20<br>declare -x sum  声明环境变量<br>export | grep sum </p>
<p>-a数组，-r不能被更改<br>ulimit  文件大小限制<br>通配符<br>*代表任意个字符<br>？代表一个字符<br>【0-9】，代表0-9<br>^取反</p>
<p>&amp;&amp;与  只有前面正确，才会进行后面的操作<br>|| 或 只有前面错误，才会今后后面操作</p>
<p>cut 主要作用是将同一行的数据进行分解<br>列：echo    ${PATH} | cut   -d ‘:’  -f  3,5</p>
<p>grep 过滤查找 -v取反 -n 显示行号</p>
<p>last 列出目前和过去登入系统用户的相关信息。</p>
<p>sort  排序 -t ‘:’ 分隔符<br>-k 用第几排排序<br>uniq 将重复的列出显示<br>wc计数</p>
<p>字符转换符 tr  -d 删除 -s替换<br>col 将文件里的 tab 换成 空格键<br>join 将相同数据的那行加在一起<br>paste  直接将俩行贴在一起<br>expand 将tab 转换成空格键<br>划分命令split 将大的文件划为小的文件<br>参数代换xargs 产生某个命令的参数 </p>
]]></content>
  </entry>
  <entry>
    <title>nginxday1</title>
    <url>/2022/01/19/nginxday1/</url>
    <content><![CDATA[<p>1.安装nginx<br>1）使用源码包安装nginx软件包</p>
<ol>
<li>   [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        #安装依赖包</li>
<li>   [root@proxy ~]# useradd -s /sbin/nologin nginx</li>
<li>   [root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz</li>
<li>   [root@proxy ~]# cd  nginx-1.12.2</li>
<li>   [root@proxy nginx-1.12.2]# ./configure   \</li>
<li>   –prefix=/usr/local/nginx   \                #指定安装路径</li>
<li>   –user=nginx   \                            #指定用户</li>
<li>   –group=nginx  \                            #指定组</li>
<li>   –with-http_ssl_module                    #开启SSL加密功能</li>
<li></li>
<li>   [root@proxy nginx-1.12.2]# make &amp;&amp; make install     #编译并安装<br>2）nginx命令的用法</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx                    #启动服务</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            #关闭服务</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        #重新加载配置文件</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -V                #查看软件信息<br>netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：</li>
</ol>
<p>-a显示所有端口的信息<br>-n以数字格式显示端口号<br>-t显示TCP连接的端口<br>-u显示UDP连接的端口<br>-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口<br>-p显示监听端口的服务名称是什么（也就是程序名称）<br>如果80端口被占用需要使用kill  -9 杀死进程。<br>nginx服务默认通过TCP 80端口监听客户端请求：</p>
<ol>
<li>   root@proxy ~]# netstat  -anptu  |  grep nginx</li>
<li>   tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx<br>3）测试首页文件<br>Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：</li>
<li>   [root@client ~]# curl <a href="http://192.168.4.5/">http://192.168.4.5</a><br>步骤二：客户端访问测试<br>1）分别使用浏览器和命令行工具curl测试服务器页面<br>如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。</li>
<li>   [root@client ~]# firefox <a href="http://192.168.4.5/">http://192.168.4.5</a></li>
<li>[root@client ~]# curl <a href="http://192.168.4.5/">http://192.168.4.5</a><br>案例2：用户认证</li>
<li>1 问题<br>沿用练习一，通过调整Nginx服务端配置，实现以下目标：</li>
<li>   访问Web页面需要进行用户认证</li>
<li>   用户名为：tom，密码为：123456</li>
<li>2 方案<br>通过Nginx实现Web页面的认证，需要修改Nginx配置文件，在配置文件中添加auth语句实现用户认证。最后使用htpasswd命令创建用户及密码即可。效果如图-2所示。</li>
</ol>
<p>图-2<br>2.3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：修改Nginx配置文件<br>1）修改/usr/local/nginx/conf/nginx.conf</p>
<ol>
<li>   [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf</li>
<li>   .. ..</li>
<li>   server {</li>
<li><pre><code>       listen       80;
</code></pre>
</li>
<li><pre><code>       server_name  localhost;
</code></pre>
</li>
<li><pre><code>       auth_basic &quot;Input Password:&quot;;                        //认证提示符信息
</code></pre>
</li>
<li><pre><code>       auth_basic_user_file  &quot;/usr/local/nginx/pass&quot;;        //认证的密码文件
</code></pre>
</li>
<li><pre><code>       location / &#123;
</code></pre>
</li>
<li><pre><code>           root   html;
</code></pre>
</li>
<li><pre><code>           index  index.html index.htm;
</code></pre>
</li>
<li><pre><code>       &#125;
</code></pre>
</li>
<li><pre><code> &#125;
</code></pre>
2）生成密码文件，创建用户及密码<br>使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。</li>
<li>   [root@proxy ~]# yum -y install  httpd-tools</li>
<li>   [root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件</li>
<li>   New password: </li>
<li>   Re-type new password: </li>
<li>   Adding password for user tom</li>
<li>   [root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项</li>
<li>   New password: </li>
<li>   Re-type new password: </li>
<li>   Adding password for user jerry</li>
<li>   [root@proxy ~]# cat /usr/local/nginx/pass<br>3）重新加载配置</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    </li>
<li>   #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：</li>
<li>   #[error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)<br>步骤二：客户端测试<br>1）登录192.168.4.10客户端主机进行测试<br>如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。<br>或者直接使用真实主机的火狐也可以。</li>
<li>   [root@client ~]# firefox <a href="http://192.168.4.5/">http://192.168.4.5</a>                    //输入密码后可以访问<br>3 案例3：基于域名的虚拟主机</li>
<li>1 问题<br>沿用练习二，配置基于域名的虚拟主机，实现以下目标：</li>
<li>   实现两个基于域名的虚拟主机，域名分别为<a href="http://www.a.com和www.b.com/">www.a.com和www.b.com</a></li>
<li>   对域名为<a href="http://www.a.com的站点进行用户认证,用户名称为tom,密码为123456/">www.a.com的站点进行用户认证，用户名称为tom，密码为123456</a></li>
<li>2 方案<br>修改Nginx配置文件，添加server容器实现虚拟主机功能；对于需要进行用户认证的虚拟主机添加auth认证语句。<br>虚拟主机一般可用分为：基于域名、基于IP和基于端口的虚拟主机。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：修改配置文件<br>1）修改Nginx服务配置，添加相关虚拟主机配置如下</li>
<li>   [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf</li>
<li>   .. ..</li>
<li>   server {</li>
<li><pre><code>       listen       80;                                      //端口
</code></pre>
</li>
<li><pre><code>       server_name  www.a.com;                                //域名
</code></pre>
</li>
<li>   auth_basic “Input Password:”;                        //认证提示符</li>
<li><pre><code>       auth_basic_user_file &quot;/usr/local/nginx/pass&quot;;        //认证密码文件
</code></pre>
</li>
<li>   location / {</li>
<li><pre><code>           root   html;                                    //指定网站根路径
</code></pre>
</li>
<li><pre><code>           index  index.html index.htm;
</code></pre>
</li>
<li><pre><code>      &#125;
</code></pre>
</li>
<li></li>
<li>   }</li>
<li>   … …</li>
<li></li>
<li><pre><code>   server &#123;
</code></pre>
</li>
<li><pre><code>       listen  80;                                        //端口
</code></pre>
</li>
<li><pre><code>       server_name  www.b.com;                                //域名
</code></pre>
</li>
<li>   location / { </li>
<li>   root   www;                                 //指定网站根路径</li>
<li>   index  index.html index.htm;</li>
<li>   }</li>
<li>   }<br>2）创建网站根目录及对应首页文件</li>
<li>   [root@proxy ~]# mkdir /usr/local/nginx/www</li>
<li>   [root@proxy ~]# echo “www” &gt; /usr/local/nginx/www/index.html<br>3）重新加载配置</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload</li>
<li>   #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：</li>
<li>   #[error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)<br>步骤二：客户端测试<br>1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析</li>
<li><pre><code>[root@client ~]# vim /etc/hosts
</code></pre>
</li>
<li>   192.168.4.5    <a href="http://www.a.com/">www.a.com</a>  <a href="http://www.b.com/">www.b.com</a><br>2）登录192.168.4.10客户端主机进行测试<br>注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。</li>
<li>   [root@client ~]# firefox <a href="http://www.a.com/">http://www.a.com</a>            //输入密码后可以访问</li>
<li>   [root@client ~]# firefox <a href="http://www.b.com/">http://www.b.com</a>            //直接访问<br>提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。<br>步骤三：扩展课外实验：其他类型的虚拟主机</li>
<li>基于端口的虚拟主机（参考模板）</li>
<li>   server {</li>
<li><pre><code>       listen       8080;                        //端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;          //域名
</code></pre>
</li>
<li><pre><code>       ......
</code></pre>
</li>
<li>   }</li>
<li><pre><code>   server &#123;
</code></pre>
</li>
<li><pre><code>       listen       8000;                         //端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;           //域名
</code></pre>
</li>
<li><pre><code>     .......
</code></pre>
</li>
<li>   }</li>
<li>基于IP的虚拟主机（参考模板）</li>
<li>   server {</li>
<li><pre><code>       listen       192.168.0.1:80;              //IP地址与端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;          //域名
</code></pre>
</li>
<li><pre><code> ... ...
</code></pre>
</li>
<li>   }</li>
<li><pre><code>   server &#123;
</code></pre>
</li>
<li><pre><code>       listen       192.168.0.2:80;             //IP地址与端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;
</code></pre>
</li>
<li>   … …</li>
<li>   }<br>4 案例4：SSL虚拟主机</li>
<li>1 问题<br>沿用练习三，配置基于加密网站的虚拟主机，实现以下目标：</li>
<li>   域名为<a href="http://www.c.com/">www.c.com</a></li>
<li>   该站点通过https访问</li>
<li>   通过私钥、证书对该站点所有数据加密</li>
<li>2 方案<br>源码安装Nginx时必须使用–with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。<br>加密算法一般分为对称算法、非对称算法、信息摘要。<br>对称算法有：AES、DES，主要应用在单机数据加密。<br>非对称算法有：RSA、DSA，主要应用在网络数据加密。<br>信息摘要：MD5、sha256，主要应用在数据完整性校验。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：配置SSL虚拟主机<br>1）生成私钥与证书</li>
<li>   [root@proxy ~]# cd /usr/local/nginx/conf</li>
<li>   [root@proxy ~]# openssl genrsa &gt; cert.key                            //生成私钥</li>
<li>   [root@proxy ~]# openssl req -new -x509 -key cert.key &gt; cert.pem      //生成证书<br>2）修改Nginx配置文件，设置加密网站的虚拟主机</li>
<li>   [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf</li>
<li>   … …    </li>
<li>   server {</li>
<li><pre><code>       listen       443 ssl;
</code></pre>
</li>
<li><pre><code>       server_name            www.c.com;
</code></pre>
</li>
<li><pre><code>       ssl_certificate      cert.pem;         #这里是证书文件
</code></pre>
</li>
<li><pre><code>       ssl_certificate_key  cert.key;         #这里是私钥文件
</code></pre>
</li>
<li></li>
<li><pre><code>       ssl_session_cache    shared:SSL:1m;
</code></pre>
</li>
<li><pre><code>       ssl_session_timeout  5m;
</code></pre>
</li>
<li></li>
<li><pre><code>       ssl_ciphers  HIGH:!aNULL:!MD5;
</code></pre>
</li>
<li><pre><code>       ssl_prefer_server_ciphers  on;
</code></pre>
</li>
<li></li>
<li><pre><code>       location / &#123;
</code></pre>
</li>
<li><pre><code>           root   html;
</code></pre>
</li>
<li><pre><code>           index  index.html index.htm;
</code></pre>
</li>
<li><pre><code>       &#125;
</code></pre>
</li>
<li><pre><code>   &#125;
</code></pre>
3）重新加载配置</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload</li>
<li>   #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：</li>
<li>   #[error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)<br>步骤二：客户端验证<br>1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析</li>
<li>   [root@client ~]# vim /etc/hosts</li>
<li>   192.168.4.5    <a href="http://www.c.com/">www.c.com</a>  <a href="http://www.a.com/">www.a.com</a>   <a href="http://www.b.com/">www.b.com</a><br>2）登录192.168.4.10客户端主机进行测试</li>
<li>   [root@client ~]# firefox <a href="https://www.c.com/">https://www.c.com</a>           </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python笔记day1</title>
    <url>/2022/01/21/python%E7%AC%94%E8%AE%B0day1/</url>
    <content><![CDATA[<p>Python语法结构：</p>
<ol>
<li>   python代码块通过缩进对齐表示代码逻辑而不是使用大括号</li>
<li>   缩进表达一个语句属于哪一个代码块</li>
<li>   缩进风格<br>(1) 1或2：可能不够，很难确定代码语句属于哪一个代码块<br>(2) 8至10：可能太多，如果代码内嵌的层次太多，就会使得待py代码很难阅读<br>(3) 4个空格：非常流行，范。罗萨姆支持的风格</li>
<li>   缩进相同的一组语句结构一个代码块，称之为代码组</li>
<li>   首行以关键字开始，以冒号：结束，该行之后的以行或者多行代码构成代码组（细节注意）</li>
<li>   如果代码只有一行，可以将其直接写在冒号后面，但是这样的写法可读性差，不推荐<br>注释及续行：</li>
<li>首要说明：尽管Python是可读性最好的语言之一，这并不意味这程序员在代码中就不写注释。</li>
<li>和很多Unix脚本类似，Python注释语句从#字符开始</li>
<li>注释可以子啊以行的任何地方开始，解释器会忽略该行#之后的所有内容</li>
<li>一行过长的语句可以使用反斜杠\分解成几行<br>同行多个语句： 【了解】</li>
<li>分号；允许你将多个语句写在同一行上</li>
<li>但是这些语句不能在这行开始一个新的代码块</li>
<li>因为可读对变差，所以不推荐使用<br>简单命令<br>输出（打印）print<br>print（’hello world!’）<br>print (‘hello’+’world!’)<br>print (‘hello’,’world!’)<br>print(‘hello’,’world!’,sep=’***’,end=’’)<br>输入 input<br>num=input（“number：”）<br>进入python 直接输入python<br>运行python文件是列如：python log.py<br>退出exit（）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>shell01正则表达式</title>
    <url>/2021/11/03/shell01%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式，使用若干符号配合某工具实现对文档的过滤、查</p>
<p>找、修改等功能</p>
<p>head -5 /etc/passwd &gt; user   //准备素材</p>
<p>grep bin user   //找有bin的行</p>
<p>grep ^bin user        //找以bin开头的行</p>
<p>grep bash user   //找有bash的行</p>
<p>grep bash$ user   //找以bash结尾的行</p>
<p>vim user     //编辑文档添加空行</p>
<p>grep  -n  ^$  user   //找空行，加n选项可以显示行号</p>
<p>grep “[root]” user   //找root四个字符任意一个</p>
<p>grep “[rot]” user         //效果同上，找rot任意一个字符</p>
<p>grep “rot” user   //找连续的rot字符串</p>
<p>grep “[a-z]” user   //找所有小写字母</p>
<p>grep “[A-Z]” user   //找所有大写字母</p>
<p>grep “[a-Z]” user   //找所有字母</p>
<p>grep “[0-9]” user   //找所有数字</p>
<p>grep “[^a-Z]” user  //找字母之外的内容，^写在[]里是取反效果</p>
<p>grep “r..t” user   //找rt之间有2个任意字符的行</p>
<p>grep “r…t” user  //找rt之间有3个任意字符的行，没有匹配内容，就无输出    </p>
<p>grep “<em>“ user  //错误用法，</em>号是匹配前一个字符任意次，不能单独使用</p>
<p>grep “ro*t” user  //找rt，中间的o有没有都行，有几次都行</p>
<p>grep “.” user   //找任意单个字符，文档中每个字符都可以理解为任意字符</p>
<p>grep “.<em>“ user  //找任意，包括空行 .与</em>的组合在正则中相当于通配符的效果</p>
<p>   grep “ro{2,4}t” user   //找rt，中间的o可以是2~4个<br>   grep “ro{2,}t” user         //找rt，中间的o可以是2个以及2个以</p>
<p>上</p>
<p>   grep “ro{3,7}t” user //找rt，中间的o可以是3~7个，没有匹</p>
<p>配条件就没有任何显示</p>
<p>   grep “ro{3,}t” user  //找rt，中间的o可以是3个以及3个以</p>
<p>上</p>
<p>   grep “ro{2}t” user  //找rt，中间的o必须是2个</p>
<pre><code>grep &quot;ro\&#123;1,\&#125;t&quot; user    //找1次以及1次以上的o
</code></pre>
<p> egrep “ro{1,}t” user   //效果同上,egrep支持扩展正则，或者grep -E</p>
<p> egrep “ro+t” user     //效果同上，最精简</p>
<pre><code>grep &quot;roo\&#123;0,1\&#125;t&quot; user   //第二个o要出现0~1次
</code></pre>
<p>egrep “roo{0,1}t” user  //效果同上</p>
<p>egrep “roo?t” user   //效果同上，最精简<br>      grep “ro{2}t” user    //找o出现2次的<br>egrep “ro{2}t” user    //效果同上</p>
<p>egrep “^root|^bin” user   //找root或者以bin开头的行</p>
<p>egrep “^(root|bin)” user   //效果同上</p>
<p>egrep “\bthe\b” abc             //找the，前后不允许出现数</p>
<p>字，字母，下划线</p>
]]></content>
  </entry>
  <entry>
    <title>web安全笔记day03</title>
    <url>/2022/01/20/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day03/</url>
    <content><![CDATA[<p>信息收集：<br>信息收集是指通过各种方式获取所需要的信息，以便我们在后续的渗透过程更好的进行。因为只有我们掌握了目标网站或目标 主机足够多的信息之后，我们才能更好地对其进行漏洞检测。<br>主动信息收集<br>    优点: 精准、灵活<br>    缺点: 与目标直接交互，暴露自身<br>被动信息收集<br>    优点: 无交互、可以统一统计、工具化爬取<br>    缺点: 数据具有时效性，不精准，误差高<br>主要收集的内容：<br>    1. 服务器的配置信息，banner指纹<br>    2. 只要和网站关联的信息都要尽量去收集，包括网站注册人，网站关联公司，网站系统架构，网站关联子域名，网站开放服务以及开放端口等<br>谷歌黑语法<br>intitle:关键字  <del>搜索网页标题中含有关键字的网页</del><br>intext:关键字   <del>搜索站点正文中含有关键字的网页</del><br>inurl:关键字    <del>搜索URL中包含有指定字符串的网址</del><br>site:域名       <del>在指定站点内查找相关的内容</del><br>filetype:文件   <del>搜索指定类型的文件</del><br>github-dorks    <a href="https://github.com/techgaun/github-dorks">https://github.com/techgaun/github-dorks</a><br>github-dork.py是一个简单的python工具，可以搜索您的存储库或您的组织/用户存储库。它目前不是一个完美的工具，但提供了基本功能，可以针对文本文件中指定的dorks自动搜索存储库。<br>子域名信息收集<br>子域名是某个主域的二级域名或者多级域名或者其他域名，在防御措施严密的情况下无法直接拿下主域，那么可以用迂回战术拿下子域名，然后无限靠近主域。一台服务器上有很多个站点，这些站点之间没有必然的联系，是相互独立的，使用的是不同的域名（甚至端口都不同），但是它们却共存在一台服务器上。</p>
]]></content>
  </entry>
  <entry>
    <title>python笔记day02</title>
    <url>/2022/01/23/python%E7%AC%94%E8%AE%B0day02/</url>
    <content><![CDATA[<p>Python变量<br>变量名约定：</p>
<ol>
<li>第一个字符只能是大小写字母或者下划线</li>
<li>后续字符只能是大小写字母或者数字或者下划线</li>
<li>区分大小写<br>Python是动态类型语言，既不需要预先声明变量的类型<br>变量的定义：<br>一、推荐采用的全名方法</li>
<li>变量名全部采用的小写的字母</li>
<li>简短、有意义</li>
<li>多个单词间用下划线分隔</li>
<li>变量名用名词，函数名要用谓词（动词+名词）</li>
<li>类名采用驼峰形式<br>二、变量的赋值</li>
<li>变量的类型和值在赋值那一刻被初始化</li>
<li>变量赋通等号来执行</li>
<li>Python也支持增量赋值<br>三、运算符</li>
<li>标准算术运算符</li>
</ol>
<ul>
<li><ul>
<li><ul>
<li> /  //   %   **</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>比较运算符<br>&lt;  &lt;=   &gt;   &gt;=   ==    !=</li>
<li>逻辑运算符<br>And    not   or  </li>
</ol>
<p>基本数字类型：</p>
<ol>
<li>int：有符号整数</li>
<li>bool：布尔值</li>
</ol>
<p>-True：1<br>-False：0<br>3. float：浮点数<br>4. Complex：复数<br>数字表示方式：</p>
<ol>
<li>Python默认以十进制数显示</li>
<li>数字以0o或者0O开头表示为8进制数</li>
<li>数字以0x或者0X开头表示为16进制数</li>
<li>数字以0b或者0B开头表示为2进制数<br>定义字符串：</li>
<li>Python中字符串被定义为引号之间的字符集合</li>
<li>Python支持使用成对的单引号或者双引号</li>
<li>无论单引号，还是双引号，表示的意义相同</li>
<li>Python还支持三引号（三个来连续的单引号或者双引号），可以用来高喊特殊字符</li>
<li>Python不区分字符和字符串<br>字符串的切割：</li>
<li>使用索引运算符[]和切片运算符[:]可得到字符串</li>
<li>第一个字符的索引是0，最后一个字符的索引是-1</li>
<li>子字符串包含切片中的起始下标，但不包含结束下标。<br>字符串连接的操作：</li>
<li>使用+号可以将多个字符串拼接在一起</li>
<li>使用*号可以将一个字符串重复多次<br>定义列表：</li>
<li>可以将列表当成普通的“数组”，它能保存任意数量任已类型的python对象</li>
<li>像字符串一样，列表也支持下表和切片操作</li>
<li>列表中的项目可以改变<br>在2.7版本里输入是raw_input  3.0版本是input<br>linux系统升级python版本<br>(1)查看python原来的版本<br>python -V<br>（2）下载python安装包并解压<br>wget <a href="https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz">https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz</a><br>tar -xf Python-3.7.2.tgz<br>mv Python-3.7.2 python3<br>（3）进入解压的python内进行配置并安装<br>cd python3<br>./configure –prefix=/usr/local/python3 --with-ssl --enable-optimizations<br>make<br>make install<br>（4）安装完成后修改默认的python版本<br>cd /usr/bin<br>mv python python.bak<br>ln -s /usr/local/python3/bin/python3 /usr/bin/python   软连接<br>（5）安装完成<br>python -V<h1 id="输出结果：Python-3-7-2"><a href="#输出结果：Python-3-7-2" class="headerlink" title="输出结果：Python 3.7.2"></a>输出结果：Python 3.7.2</h1>列如<br>给文件创建（硬链接），为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同<br>ln log2013.log ln2013</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux磁盘和vim</title>
    <url>/2022/01/26/linux%E7%A3%81%E7%9B%98%E5%92%8Cvim/</url>
    <content><![CDATA[<p>一。磁盘<br>在linux下，需要使用一块硬盘。</p>
<p>需要进行以下四步：</p>
<p>识别硬盘—–分区规划—-格式化—-挂载<br>步骤一：分区规划</p>
<p>MBR模式分区</p>
<p>要求：a.最多有四个区。一般分为1～4个主分区或者0～3个主分区+1个扩展分区（n个逻辑分区）</p>
<pre><code>      b.最大支持容量为2.2TB的磁盘

      c.扩展分区不能格式化
</code></pre>
<p>1.ext2<br>linux的正统文件系统为ext2<br>blkid   这个命令可以显示出目前系统被格式化的设备。<br>dumpe2fs  查询ext系统超级区块信息的命令</p>
<p>2.inode<br>（1）文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区sector，每个扇区存储512字节。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块block。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个sector组成一个block。<br>（2）文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做inode，中文译名为索引节点，也叫i节点。因此，一个文件必须占用一个inode，但至少占用一个block。<br>（3）inode包含很多的文件元信息，但不包含文件名，例如：字节数、属主UserID、属组GroupID、读写执行权限、时间戳等。</p>
<p>而文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用inode号码识别文件。对于系统来说文件名只是inode号码便于识别的别称。<br>（4）ls  -i 可以列出文件的inode<br>（5）df -i查看硬盘分区的inode总数和已使用情况<br>3.xfs文件系统<br>（1）从centos 7开始，默认的文件系统从ext4变成了xfs<br>（2）df -T  可以查看挂载点<br>4.磁盘与目录的容量<br>（1）df 列出文件系统的整体磁盘使用量   df -h  df -aT<br>（2）du 查看文件系统的磁盘的使用量<br>5.磁盘分区<br>（1）lsblk  列出系统上所有的磁盘列表<br>       parted  列出磁盘的分区类型和分区信息<br>（2）gdisk/fdisk<br>《1》    采用默认的 msdos 分区模式<br>fdisk分区工具用来建立msdos分区方案，其交互模式中的主要指令如下：<br>•    m：列出指令帮助<br>•    p：查看当前的分区表信息<br>•    n：新建分区<br>•    d：删除分区<br>•    q：放弃分区更改并退出<br>•    w：保存对分区表所做的更改<br>《2》mkfs.ext4   格式化成ext4类型  和 mkfs.xfs  格式化成xfs类型<br>《3》配置开机自动挂载<br>vim  /etc/fstab</p>
<p>/dev/sdb2       /mnt/part2      ext4    defaults        0 0<br>《4》创建挂载点，并验证挂载配置<br>mkdir  /mnt/part2                 //创建挂载点</p>
<p> mount  -a                         //挂载fstab中的可用设备</p>
<p> df  -hT  /mnt/part2/                 //检查文档所在的文件系统及设备</p>
<p>Filesystem      Type  Size  Used Avail Use% Mounted on<br>/dev/sdb2      ext4  1.9G  5.9M  1.8G   1% /mnt/part2<br>（3）分区扩展swap<br>mkswap  /dev/sdd1  格式化成swap文件系统<br>swapon   -s  未启用之前，查看swap空间组成成员<br>swapon  /dev/sdd1  启用/dev/sdd1交换分区<br>（4）文件扩展swap空间<br>Swap空间来源于硬盘空间，这个思路不变。我们可以换种方式，来扩展Swap空间。就是可以创建一个大的文件，文件占用的是磁盘空间，再将这个文件格式化使用。这个方式是可行的，但难点在于文件怎么生成呢？我们可以用dd这条命令。<br>例如 dd if=/dev/zero of=/opt/swap.db bs=1M count=2048 ，相关说明如下：<br>•    dd：为命令字。<br>•    if：读取数据的来源是哪，而/dev/zero是一个特殊的设备它可以产生无限的数据，常用来与dd命令搭配使用。<br>•    of：将数据写入到哪里去，可以是其他设备，也可以是指定路径下的一个文件名。<br>•    bs：每次读取和写入数据的大小为1M。<br>•    count：为读取和写入的次数为2048次。<br>使用dd命令创建一个大小为2048MB的交换文件，放在/opt/swap.db<br>将swap.db文件格式化成Swap文件系统  mkswap /opt/swap.db<br>启用swap.db文件，查看Swap空间大小 swapon /opt/swap.db   swapon -s<br>停用swap.db文件，查看Swap空间大小  swapoff /opt/swap.db      swapon -s<br>二。vim<br>命令模式常用操作：<br>•    1G 或 gg ，跳转到文件的首行<br>•    G ，跳转到文件的末尾行<br>•    yy、#yy ，复制光标处的一行、#行<br>•    p、P ，粘贴到光标处之后、之前<br>•    x 或 Delete键 ，删除光标处的单个字符<br>•    dd、#dd ，删除光标处的一行、#行<br>•    d^、d$ ，从光标处之前删除至行首/行尾<br>•    /word 向后查找字符串“word”，再按n/N跳至后/前一个结果<br>•    u ，撤销最近的一次操作<br>•    U ，撤销对当前行的所有修改<br>•    Ctrl + r 取消前一次撤销操作<br>•    ZZ 保存修改并退出<br>末行模式常用操作：<br>•    :s/old/new ，替换当前行第一个“old”<br>•    :s/old/new/g ，替换当前行所有的“old”<br>•    :n,m s/old/new/g ，替换第n-m行所有的“old”<br>•    :% s/old/new/g ，替换文件内所有的“old”<br>•    :w /root/newfile ，另存为其它文件<br>•    :r /etc/filesystems ，读入其他文件内容<br>•    :set nu|nonu ，显示/不显示行号<br>•    :set ai|noai ，启用/关闭自动缩进</p>
]]></content>
  </entry>
  <entry>
    <title>linux逻辑卷管理</title>
    <url>/2022/01/28/linux%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>物理卷——————》卷组——————》逻辑卷<br>一。lvm创建工具基本用法：<br>创建卷组：vgcreate  卷组名  物理设备<br>列如：vgcreate  systemvg  /dev/sdb1<br>查看卷组：vgscan<br>创建逻辑卷：lvcreate  -L 大小  -n 逻辑卷名  卷组名<br>列如： lvcreate  -L  180MiB  -n  vo  systemvg<br>查看逻辑卷：lvscan<br>ACTIVE            ‘/dev/systemvg/vo’      [180.00 MiB] inherit<br>二。扩展逻辑卷的大小<br>对于已经格式化好的逻辑卷，在扩展大小以后，必须通知内核新大小。<br>如果此逻辑卷上的文件系统是EXT3/EXT4类型，需要使用resize2fs工具；<br>如果此逻辑卷上的文件系统是XFS类型，需要使用xfs_growfs。<br>步骤一：确认逻辑卷vo的信息<br>（1）找出逻辑卷所在卷组   lvscan<br>2）查看该卷组的剩余空间是否可满足扩展需要  vgdisplay  systemvg<br> VG Size               196.00 MiB                          //卷组总大小<br> Free  PE / Size       4 / 16.00 MiB                      //剩余空间大小<br>此例中卷组systemvg的总大小都不够300MiB、剩余空间才16MiB，因此必须先扩展卷组。只有剩余空间足够，才可以直接扩展逻辑卷大小<br>步骤二：扩展卷组<br>将提前准备的分区/dev/sdb5添加到卷组systemvg    vgextend  systemvg  /dev/sdb5、<br>确认卷组新的大小  vgdisplay  systemvg<br>VG Size               692.00 MiB                          //总大小已变大<br>Free  PE / Size       128 / 512.00 MiB                  //剩余空间已达512MiB<br>步骤三：扩展逻辑卷大小<br>1）将逻辑卷/dev/systemvg/vo的大小调整为300MiB<br>lvextend  -L 300MiB  /dev/systemvg/vo<br>2）确认调整结果  lvscan<br>3）刷新文件系统大小<br>确认逻辑卷vo上的文件系统类型：</p>
<ol>
<li>   [root@server0 ~]# blkid  /dev/systemvg/vo<br>选择合适的工具刷新大小：</li>
<li>   [root@server0 ~]# resize2fs  /dev/systemvg/vo<br>确认新大小（约等于300MiB）：</li>
<li>   [root@server0 ~]# mount  /dev/systemvg/vo  /vo/</li>
<li>   [root@server0 ~]# df  -hT  /vo</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux部署lnmp</title>
    <url>/2022/01/29/linux%E9%83%A8%E7%BD%B2lnmp/</url>
    <content><![CDATA[<p>一。部署lnmp<br>目前的网站一般都会有动态和静态数据，默认nginx仅可以处理静态数据，用户访问任何数据都是直接返回对应的文件，如果如果访问的是一个脚本的话，就会导致直接返回一个脚本给用户，而用户没有脚本解释器，也看不懂脚本源代码！网站拓扑如图-1所示。<br>因此需要整合LNMP（Linux、Nginx、MySQL、PHP）实现动态网站效果。<br>LNMP在CentOS系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。<br>操作过程中需要安装的软件列表如下：<br>•    nginx<br>•    mariadb、mariadb-server、mariadb-devel<br>•    php、php-fpm、php-mysql<br>备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。</p>
<ol>
<li>在虚拟机安装nginx依赖包：yum -y install gcc pcre-devel  zlib-devel  openssl-devel</li>
<li> 解压nginx软件包并且进入软件包目录： tar -xf nginx-1.12.2.tar.gz      cd nginx-1.12.2/    </li>
<li>源码编译安装： ./configure   –with-http_ssl_module （编译）<br>make  &amp;&amp; make install（安装）  </li>
<li>安装php和mariadb软件包：  yum -y install php  php-mysql  mariadb   mariadb-devel  mariadb-server    </li>
<li>安装PHP依赖包：yum -y install php-fpm</li>
<li>修改nginx配置文件：vim /usr/local/nginx/conf/nginx.conf<br> location / {<pre><code>         root   html;
         index  index.php  index.html   index.htm;
</code></pre>
 #设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户<pre><code>     &#125;
</code></pre>
</li>
</ol>
<p>(1)    取消65~71行注释，删除69行内容。<br>(2)    在下面内容之上添加：<br>①    缓存php生成的页面内容,8个16k：fastcgi_buffers  8  16k；<br>②    缓存php生成的头部信息：fastcgi_buffer_size  32k；<br>③    连接PHP的超时时间：fastcgi_connect_tinmeout  300;<br>④    发送请求的超时时间：fasticgi_send_timeout   300;<br>⑤    读取请求的超时时间：fasticgi_read_timeout  300;<br>      fastcgi_buffers 8 16k;<br>      fastcgi_buffer_size 32k;<br>      fastcgi_connect_timeout 300;<br>      fastcgi_send_timeout 300;<br>      fastcgi_read_timeout 300;<br>location ~ .php$ {<br>  root           html;<br>  fastcgi_pass   127.0.0.1:9000;<br> fastcgi_index  index.php;<br> include        fastcgi.conf;<br>   }<br>7. 启动数据库服务：systemctl start mariadb<br>8. 启动php服务：systemctl start php-fpm<br>9.启动nginx服务： /usr/local/nginx/sbin/nginx   重启nginx服务  /usr/local/nginx/sbin/nginx -s reload<br>9. 关闭防火墙：firewall-cmd  –set-defult-zone=trusted（如果没有安装防火墙就就会提示未找到命令）<br>10. 关闭SElinux：setenforce 0（敲完命令会提示setenforce: SELinux is disabled就证明SElinux已经关闭）<br>11.<br>1）添加php测试页面：vim /usr/local/nginx/html/test.php<br>内容是<br><?php
$i=33;
echo $i;
?><br>2）创建PHP测试页面,连接并查询MariaDB数据库。<br>可以参考lnmp_soft/php_scripts/mysql.php:<br>    [root@proxy ~]# vim /usr/local/nginx/html/mysql.php<br>    <?php
    $mysqli = new mysqli('localhost','root','123456','mysql');
    //注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
    //localhost是数据库的域名或IP，mysql是数据库的名称
    if (mysqli_connect_errno()){
        die('Unable to connect!'). mysqli_connect_error();
    }
    $sql = "select * from user";
    $result = $mysqli->query($sql);
    while($row = $result->fetch_array()){
        printf("Host:%s",$row[0]);
        printf("</br>");
        printf("Name:%s",$row[1]);
        printf("</br>");
    }
    ?><br>客户端使用浏览器访问服务器PHP首页文档，检验是否成功：<br>[root@client ~]# firefox <a href="http://192.168.4.5/test.php">http://192.168.4.5/test.php</a><br>[root@client ~]# firefox <a href="http://192.168.4.5/mysql.php">http://192.168.4.5/mysql.php</a></p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫实例day01</title>
    <url>/2022/02/05/python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8Bday01/</url>
    <content><![CDATA[<p>一。爬虫第一步（下载python和pycharm）<br>   （1）  需要到python的官方网站下载python的安装包。python官网的链接地址：<a href="https://www.python.org/">https://www.python.org</a><br>   （2）  打开官方网站，光标移到Downloads，选择windows<br>   （3）  根据不同的操作系统，选择不同版本的安装包。每一个版本提供了三个下载链接，依次是基于网页的安装程序、可执行的安装程序、程序的压缩文件。通常选择下载可执行的安装程序。32位的操作系统请选择windows x86，64位操作系统请选择windows x86-64。<br>   （4）  打开命令行，输入python 回车，出现python的版本信息并进入编辑页面。输入print(“Hello World”)，打印Hello World。输入exit() 退出编辑页面     。<br>   （5）   下载pycharm，Pycharm的官网下载地址是一个英文网站：<a href="https://www.jetbrains.com/pycharm/download/#section=windows%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%97%B6%E6%9C%89%E6%94%B6%E8%B4%B9%E5%92%8C%E5%85%8D%E8%B4%B9%E4%B8%A4%E4%B8%AA%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9">https://www.jetbrains.com/pycharm/download/#section=windows，下载时有收费和免费两个两个版本可以选择</a> Professional(专业版，收费)和Community(社区版，免费)，一般来说，我们使用Community版本就够了，除非你需要用 Python 进行 Django等Web开发时才需要用到专业版。这里我们下载免费社区版。<br>二。下载模块<br>（1）在pycharm命令行（terminal）下载  pip  install  requests<br>pip  install  bs4（python专用网页解析器）<br>pip  install  re （正则表达式）系统本身就有的<br>pip install  lxml（html和xml和XPath解析方式）<br>XPath是最常用最高效的解析方式<br>from selenium import webdriver （selenium是Selenium是一个用电脑模拟人操作浏览器网页，可以实现自动化，测试等！）<br>（2）查看pip已经有的模块 pip  list<br>（3）升级pip  python -m pip install –upgrade<br>pip  -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a> –trusted-host pypi.douban.com<br>三。简单的实例（爬取<a href="http://www.baidu.com的网页数据,第一个爬虫)/">www.baidu.com的网页数据，第一个爬虫）</a></p>
<p>（1）import requests<br>#导入requests 模块<br>、、、<br>u = ‘<a href="https://www.baidu.com/&#39;">https://www.baidu.com/&#39;</a>   （要爬取的网页）<br> h = {<br>    “User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Edg/97.0.1072.76”</p>
<p>}（头文件）<br>response = requests.get(url=u, headers=h)<br>print(response.content.decode())  （打印原代码）</p>
<p>print(response.request.headers) （查看头文件）<br>、、、<br>（2）import requests<br>#导入requests 模块<br>u = ‘<a href="https://www.baidu.com/&#39;">https://www.baidu.com/&#39;</a>   （要爬取的网页）<br> h = {<br>    “User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Edg/97.0.1072.76”<br>}（头文件）<br>response = request.get（url = u，headers = h）.text<br>print(response)<br>四。 requests.get (百度经验，第二个爬虫）<br>import requests</p>
<p>u = “<a href="https://jingyan.baidu.com/search?&quot;">https://jingyan.baidu.com/search?&quot;</a><br>m = input(“请输入你要搜索的关键字:”)<br>p = {</p>
<p> “word” :”w”<br> }</p>
<p>r = requests.get(url = u,params= p  ).text</p>
<p>print(r)<br>with open(“wzw\”+m+”.text”,”w”)as f:<br>    f.write(r)</p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫实例day02</title>
    <url>/2022/02/05/python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8Bday02/</url>
    <content><![CDATA[<p>一。第三个爬虫，爬一张照片（保存到本地：with open）<br>import requests<br>ur1 = ‘<a href="https://www.wahaotu.com/uploads/allimg/202010/1603608302633418.jpg&#39;">https://www.wahaotu.com/uploads/allimg/202010/1603608302633418.jpg&#39;</a><br>response = requests.get(ur1)</p>
<p>print(response.content)</p>
<p>with open(‘海贼王02.jsp’,’wb’) as f:<br>#命名为海贼王02.jsp  ，wb：二进制文件<br>    f.write(response.content)<br>二。爬贴吧网页，第四个爬虫<br>import requests</p>
<p>url = “<a href="https://tieba.baidu.com/f?kw=%7B%7D&amp;pn=%7B%7D&quot;">https://tieba.baidu.com/f?kw={}&amp;pn={}&quot;</a><br>w = input(“请输入你要搜索的贴吧名字:”)</p>
<p>url_list = [url.format(w,i * 50) for i in range(5)]   遍历url 列表<br>print(url_list)<br>h = {<br>    “User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Edg/97.0.1072.76”</p>
<p>}<br>for item_url in url_list :   遍历url列表为 item_url<br>    response =requests.get(item_url,headers=h)</p>
<pre><code>file_name =&quot;贴吧&quot; + w + &quot;第&#123;&#125;页&quot;.format(url_list.index(item_url) + 1) + &quot;.html&quot;
with  open(file_name,&quot;w&quot;,encoding=&#39;utf-8&#39;) as f:
    f.write(response.content.decode())
</code></pre>
<p>三。爬贴吧网页（面向对象）有类和对象<br>（1）格式<br>import requests</p>
<p>class tieba_spider(object):   #  tieba_spider 贴吧名字随便起<br>    def  <strong>init</strong>(self):   # init 初始化的方法逻辑代码<br>        pass<br>    def  run(self):<br>        pass</p>
<p>if  <strong>name</strong> == ‘<strong>min</strong>‘:<br>    text = input(“请输入贴吧的名字：”)<br>    spider = tieba_spider(text)<br>    spider.run()</p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫实例day04</title>
    <url>/2022/02/08/python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8Bday04/</url>
    <content><![CDATA[<p>一。第7个爬虫，爬取抖音视频<br>import requests<br>import re</p>
<p>url = ‘<a href="https://www.douyin.com/video/7059655603584617743&#39;">https://www.douyin.com/video/7059655603584617743&#39;</a></p>
<p>headers = {<br>    ‘cookie’: ‘  在网页上查找   ‘,<br>    ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36’<br>}</p>
<p>response = requests.get(url=url, headers=headers)</p>
<p>title = re.findall(‘<title data-react-helmet="true">(.<em>?)</title>‘, response.text)[0]    找出标题<br>href = re.findall(‘src(.</em>?)vr%3D%2’, response.text)[1]      找出视频的连接是相当于加密的url<br>video_url = requests.utils.unquote(href).replace(‘“:”‘, ‘https:’)     生成新的播放链接url<br>video_content = requests.get(url=video_url, headers=headers).content<br>with open (‘asd\‘+title + ‘.mp4’, mode=’wb’) as f:<br>    f.write(video_content)<br>二。爬取批量抖音视频，第8个爬虫<br>from selenium import webdriver #导入库<br> 固定格式（1）滑动页面，只有滑动所有的页面，才能获得所有的网址。<br>def drop_down():<br>    for x in range(1,100,4):<br>        time.sleep(1)<br>        j = x / 9<br>        js = ‘document.documentElement.scrollTop = document.documentElement.scrollHeight * %f’ % j<br>        driver.execute_script(js)<br>固定格式（2）用正则表达式把标题里不符合格式的化成”<em>“<br>def chang_title(title):<br>    pattorn = re.compile(r”[/\:*?&quot;&lt;&gt;|]”)<br>    new_tiltle = re.sub(pattorn, “</em>“, title)<br>    return new_tiltle<br> new_title = chang_title(title)  #定义标头</p>
<p>#Selenium库是一个用电脑模拟人操作浏览器网页，可以实现自动化，测试等！<br>driver = webdriver.Chrome() #爬取的是Google浏览器<br>driver.get(‘要爬取的视频网页’)<br>time.sleep(3)#是间隔3秒。需要手动的滑动验证码<br>#需要下载google对应版本的chromedriver.exe<br>#chromedriver.exe的下载网站是 <a href="https://chromedriver.chromium.org/downloads">https://chromedriver.chromium.org/downloads</a></p>
<p>list = driver.find_elements_by_css_selector(‘  div.knrjsN15 &gt; div:nth-child(2)&gt;ul li’)  # (找出每个视频的网址’selector’)<br>for li in list:<br>    li_url = li.find_element_by_css_selector(‘a’).get_attribute(‘href’)    #（遍历list，存入到li_url里 element是一个。elements是多个）  </p>
<pre><code>headers = &#123;
    &#39;cookie&#39;: “ 在网页里找  ”
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36&#39;
&#125;  （请求头cookie和User-Agent ，做伪装。伪装成浏览器）

response = requests.get(url=li_url, headers=headers)  （请求网址li_url）

title = re.findall(&#39;&lt;title data-react-helmet=&quot;true&quot;&gt;(.*?)&lt;/title&gt;&#39;, response.text)[0]
href = re.findall(&#39;src(.*?)vr%3D%2&#39;, response.text)[1]
video_url = requests.utils.unquote(href).replace(&#39;&quot;:&quot;&#39;, &#39;https:&#39;)
video_content = requests.get(url=video_url, headers=headers).content
new_title = chang_title(title)
with open(&#39;asd\\&#39; + new_title + &#39;.mp4&#39;, mode=&#39;wb&#39;) as f:
    f.write(video_content)
    print(&quot;在下载&quot;,title)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>pyhon爬虫实例day03</title>
    <url>/2022/02/07/python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8Bday03/</url>
    <content><![CDATA[<p>一。批量爬取图片。第5个爬虫<br>import requests<br>import re</p>
<p>ur1 = ‘<a href="https://cn.bing.com/images/search?q=%E6%B5%B7%E8%B4%BC%E7%8E%8B%E5%A4%A7%E5%92%8C&amp;form=HDRSC2&amp;first=1&amp;tsc=ImageBasicHover&#39;">https://cn.bing.com/images/search?q=海贼王大和&amp;form=HDRSC2&amp;first=1&amp;tsc=ImageBasicHover&#39;</a><br>response = requests.get(ur1)</p>
<p>pa = re.compile(‘class=”img_cont hoff”.<em>?src=”(.</em>?)”‘,re.S)<br>re = re.findall(pa,response.text)</p>
<p>num = 1<br>for img_url in re:<br>    response = requests.get(img_url)<br>    with open(‘img/%d海贼王大和.jsp’%num, ‘wb’) as f:<br>        f.write(response.content)<br>        print(“已经下载%d张”%num)<br>        num = num + 1<br>re.compile()是用来优化正则的，它将正则表达式转化为对象，re.search(pattern, string)的调用方式就转换为 pattern.search(string)的调用方式，多次调用一个正则表达式就重复利用这个正则对象，可以实现更有效率的匹配<br>1).re.I(re.IGNORECASE): 忽略大小写<br>2).re.M(MULTILINE): 多行模式，改变’^’和’$’的行为<br>3).re.S(DOTALL): 点任意匹配模式，改变’.’的行为  (这次用到的模式就是这个)<br>4).re.L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定<br>5).re.U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性<br>6).re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释<br>二。爬起点网小说。第6个爬虫<br>import requests<br>from bs4 import BeautifulSoup</p>
<p>def get_novel_chopters():<br>    root_url = ‘<a href="https://book.qidian.com/info/1031954817/#Catalog&#39;">https://book.qidian.com/info/1031954817/#Catalog&#39;</a><br>    r = requests.get(root_url)<br>    r.encoding = “gdk”<br>    soup = BeautifulSoup(r.text, “html.parser”)<br>    data = []                                       （找到整本书里面的title和href。href是url）<br>    for h2 in soup.find_all(“h2”):         （找所有的h2）<br>        link = h2.find(“a”)    （h2.底下的a）<br>        if not link:<br>            continue<br>        data.append((“https:%s” % link[‘href’], link[‘title’]))      （匹配href，和title）<br>    return data</p>
<p>def get_chopter_content(url):<br>    r = requests.get(url)<br>    r.encoding = ‘gdk’<br>    soup = BeautifulSoup(r.text, “html.parser”)<br>    return soup.find(“div”, class_=”read-content j_readContent”).get_text()        （找div里面的文字）</p>
<p>nover = get_novel_chopters()<br>total = len(nover)<br>idx = 0<br>for chopter in nover:<br>    idx += 1<br>    print(idx, total)<br>    url, title = chopter<br>    with open(‘wzw\‘ + “%s.txt” % title, “w”) as f:<br>        f.write(title)<br>        f.write(get_chopter_content(url))</p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫基本知识</title>
    <url>/2022/02/10/python%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>爬虫基础：<br>pip install 包名 -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a> –trusted-host pypi.douban.com<br>1http基本原理<br>（1）url，统一资源标识符<br>客户端向服务器发送一个request（请求）<br>服务器向客户端发送一个respose（响应）<br>（2）请求<br>请求方法 ：get和post<br>请求网址：url<br>请求头：ua和cookie等<br>请求体<br>（3）响应<br>200  成功     400  错误请求  401  未授权    403   禁止访问    404    未找到<br>2web网页基础<br>（1）网页的组成<br>1.html<br>2.css<br>3.JavaScript<br>爬虫的基本原理：<br>（1）获取网页：urllib，requests<br>（2）提取信息：re，bs4（Beautifulsoup),pyueryimport,xpath(etree)，parsel（css）<br>  (3)  保存数据：可以用open 保存到txt，json，csv，还可以保存到数据库MySQL，mongoDB，redis等<br>md5算法信息摘要<br>‘’’<br>import hashlib</p>
<p>str01 = ‘pyth12345’<br>md5 = hashlib.md5()<br>md5.update(str01.encode())<br>result  = md5.hexdigest()<br>print(result)<br>‘’’</p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫day05</title>
    <url>/2022/02/08/python%E7%88%AC%E8%99%AB%E7%94%A8%E5%88%B0%E7%9A%84%E5%BA%93/</url>
    <content><![CDATA[<p>python爬虫库总结<br>（1）selenium   （用来爬抖音视频，谷歌浏览器） 是动态渲染页面的爬虫<br>用来模拟人工滑动，页面的情况<br>from selenium import webdriver<br>Chrome浏览器驱动：chromedriver , taobao备用地址<br>driver = webdriver.Chrome()    # Chrome浏览器<br>元素定位<br>find_element_by_css_selector() 格式： div.knrjsN15 &gt; div:nth-child(2)&gt;ul li<br>find_element_by_xpath()   格式 //*[@id=”root”]/div/div[2]/div/div/div[4]/div[1]/div[2]/ul/li[1]<br>（2）bs4库 （用来爬小说，爬取音乐）<br>from bs4 import BeautifulSoup </p>
<p>BeautifulSoup是将HTML代码当做一个便签树来处理，BeautifulSoup对应一个HTML/XML文档的全部内容 。其中的每一个标签的结构如下：<br>soup = BeautifulSoup(r.text, “html.parser”)<br> data = []<br>    for h2 in soup.find_all(“h2”):   #  找所有的h2<br>        link = h2.find(“a”)               #遍历h2下面的a<br>        if not link:<br>            continue<br>        data.append((“https:%s” % link[‘href’], link[‘title’]))<br>    return data<br>除了find_all()方法，还有find()方法，只不过find()方法返回的是单个的标签，也就是第一个匹配的标签，而find_all()方法返回的是所有匹配的标签组成的列表。<br>（3）xpath库<br>pip install lxml<br>from lxml import etree<br>使用Xpath解析HTML文本<br>html = etree.HTML(text, etree.HTMLParser())<br>result = html.xpath(‘/html/head/title/text()’)<br>print(result)<br>（4）pyquery<br>from pyquery import PyQuery as pq    # 将字符串初始化为pyquery对象<br>doc = pq(response)<br>    figure = doc(‘.  ‘).items()  #查找class里的东西<br>    for i in figure:<br>        video_url = i.attr(‘href’)       遍历figure 找到href里的视频连接</p>
<p>doc = pq(text)<br>print(doc(‘b’))<br>运行结果：<br><b link="af"/><br><b link="bba"/><br>（5）re 正则表达式<br>(.*?)<br>re.compile(,re.S)<br>re.findall()<br>re.sub(‘’,’’,’’)<br>(6)  parsel<br>selector = parsel.Selector(rea)<br>lis = selector.css(‘.grid_view li’)   #’.grid_view li’ 是在class =grid_view下的li<br>title = ls.css(‘.info .hd span.title:nth-child(1)::text’).get()  #:nth-child(1)查找第一个<br>（7）csv 保存为csv格式<br>import csv<br>f = open(‘豆瓣top250.csv’, mode=’a’, encoding=’utf-8-sig’, newline=’’)<br>csv_writer=csv.DictWriter(f, fieldnames=[     #写的所有的开头<br>    ‘标题’,<br>    ‘导演’,<br>    ‘演员’,<br>    ‘电影年份’,<br>    ‘国家’,<br>    ‘类型’,<br>    ‘电影简介’,<br>    ‘电影评分’,<br>    ‘评价人数’<br>])<br>csv_writer.writeheader()  #在代码开头写是csv是头文件<br>csv_writer.writerow(dit) #在结尾写是写如csv要传入的东西<br>（8）josnpath 数据提取方法，提取josn数据<br> ‘’’<br>import jsonpath<br>import requests<br>import json<br>url = ‘<a href="https://www.lagou.com/lbs/getAllCitySearchLabels.json&#39;">https://www.lagou.com/lbs/getAllCitySearchLabels.json&#39;</a><br>headers = {<br>    ‘user-agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36’<br>}</p>
<p>resa =requests.get(url=url,headers=headers)<br>city_data=resa.content.decode()<br>print(city_data)<br>city_data_dict = json.loads(city_data)<br>print(jsonpath.jsonpath(city_data_dict,”$..B..name”) )</p>
<p>‘’’</p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫实例day06</title>
    <url>/2022/02/09/python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8Bday05/</url>
    <content><![CDATA[<p>一。第九个爬虫，爬腾讯视频<br>import requests<br>import pprint      # pprint 是“pretty printer”的简写，因此它的含义便是：（相当）美观的打印。<br>import re        #正则表达式<br>import json     #json数据<br>from tqdm import tqdm      #显示下载的进度条<br>url = ‘<a href="https://vd.l.qq.com/proxyhttp&#39;">https://vd.l.qq.com/proxyhttp&#39;</a></p>
<p>data = {“因为是post的所以要有data，每个视频连接的data是不一样的”<br>}<br>headers = {<br>    ‘user-agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36’<br>}     #请求头<br>response = requests.post(url=url, json=data, headers=headers)    #请求网页，post的方式。<br>html_data = response.json()[‘vinfo’]     #筛选‘vinfo’的内容<br>m3u8_url = re.findall(‘url(.*?),’,html_data)[3].split(‘“‘)[2]   #用正则表达式匹配url（），要的（）里的内容，要的是第四个。要三个字符”后面的内容。<br>#pprint.pprint(html_data)<br>m3u8_data = requests.get(url=m3u8_url).text    #请求网页m3u8_url,获取text<br>m3u8_data = re.sub(‘#EXTM3U’,’’,m3u8_data)     #用re.sub把”#EXTM3U”替换成空白<br>m3u8_data = re.sub(‘#EXT-X-VERSION:\d’,’’,m3u8_data)<br>m3u8_data = re.sub(‘#EXT-X-MEDIA-SEQUENCE:\d’,’’,m3u8_data)<br>m3u8_data = re.sub(‘#EXT-X-TARGETDURATION:\d+’,’’,m3u8_data)<br>m3u8_data = re.sub(‘#EXT-X-PLAYLIST-TYPE:VOD’,’’,m3u8_data)<br>m3u8_data = re.sub(‘#EXTINF:\d+.\d+,’,’’,m3u8_data)<br>m3u8_data = re.sub(‘#EXT-X-ENDLIST’,’’,m3u8_data).split()    #split Python split() 通过指定分隔符对字符串进行切片<br>for ts in tqdm(m3u8_data):<br>    ts_url = ‘<a href="https://apd-6dc457641b263c90dce7c5ab8b7c4718.v.smtcdns.com/moviets.tc.qq.com/ACgoZ1rSyLeXt-5O_1qnlBtM57gJEpfDuwb50lggB0vE/uwMROfz2r5xgoaQXGdGnC2df645GziNP4fCTXzcc9dfItw5M/lgeZDzgYIrLpIdbJgAIVZll_g3QXNnU4vUCCyGTKUr_pbDsLFy5en7WZxqPEGRG_3buVk0iCBSFA6xsoeR4-jv4RShcuya3Q3yWcfIeie2hFrB4yyDa3Kpw4huiEwRt_QztFQiKfp9OG6_TXczD2Qxf0CJKbd0j_R9lTsm1dJ0gXzvYBnBf7lQ/&#39;">https://apd-6dc457641b263c90dce7c5ab8b7c4718.v.smtcdns.com/moviets.tc.qq.com/ACgoZ1rSyLeXt-5O_1qnlBtM57gJEpfDuwb50lggB0vE/uwMROfz2r5xgoaQXGdGnC2df645GziNP4fCTXzcc9dfItw5M/lgeZDzgYIrLpIdbJgAIVZll_g3QXNnU4vUCCyGTKUr_pbDsLFy5en7WZxqPEGRG_3buVk0iCBSFA6xsoeR4-jv4RShcuya3Q3yWcfIeie2hFrB4yyDa3Kpw4huiEwRt_QztFQiKfp9OG6_TXczD2Qxf0CJKbd0j_R9lTsm1dJ0gXzvYBnBf7lQ/&#39;</a> + ts<br>    ts_content = requests.get(url=ts_url).content    #遍历ts ，加上https：// +ts，请求页面，变成content格式，二进制格式<br>    with open(‘wzw\‘+’斗罗大陆.mp4’,mode=’ab+’) as f:     #保存到本地<br>        f.write(ts_content)<br>print(‘下载完成’)</p>
]]></content>
  </entry>
  <entry>
    <title>javascript动态渲染页面爬取</title>
    <url>/2022/02/21/javascript%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p>一。Splash的使用<br>（1）安装<br>在linux系统上安装docker<br>第一步：关闭selinux和防火墙<br>第二步：wget -qO- <a href="https://get.docker.com/">https://get.docker.com</a> | sh<br>第三步：用docker version命令查看docker版本<br>第四步：用service docker start命令启动docker服务<br>第五步： docker info查看docker存储位置<br>用docker安装splash<br>docker pull scrapinghub/splash<br>docker run -d -p 8050:8050 scrapinghub/splash<br>#通过浏览器访问8050端口验证安装是否成功：http：//127.0.0.1:8050/<br>(3)Python包Scrapy-Splash安装<br>pip3 install scrapy-splash</p>
]]></content>
  </entry>
  <entry>
    <title>javaScript动态渲染页面爬取2</title>
    <url>/2022/02/22/javaScript%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%88%AC%E5%8F%962/</url>
    <content><![CDATA[<p>一.selenim的使用<br>（1）安装pip install selenium<br>用来模拟人工滑动，页面的情况<br>from selenium import webdriver<br>Chrome浏览器驱动：chromedriver , taobao备用地址<br>下载谷歌相对应版本的chromedriver.exe<br>然后放在python文件夹里<br>（2）。使用<br>driver = webdriver.Chrome()    # Chrome浏览器</p>
<p>driver对象的常用属性和方法：<br>driver.page_soure当前标签页的网页源代码<br>driver.current_url 当前标签页的url<br> 重点   driver.close()关闭当前标签页<br>driver.forward()页面前进<br>driver.back()页面后退<br>重点* driver.quit()关闭浏览器<br>driver.save_screenshot(‘截图.png’))<br>重点* .click模拟鼠标点击<br>重点  .send_keys(‘舔要输入的东西’)<br>列如：browser.find_element_by_css_selector(‘.username input[type=”text”]’).send_keys(‘admin’)<br>元素定位<br>find_element_by_css_selector() 格式： div.knrjsN15 &gt; div:nth-child(2)&gt;ul li<br>find_element_by_xpath()   格式 //*[@id=”root”]/div/div[2]/div/div/div[4]/div[1]/div[2]/ul/li[1]<br>find_element_by_id(“su”) 格式id=”su”<br>driver.find_element_by_link_text(“地图”).click()查找标签<br>————————————————————————<br>登录的<br>iframe标签<br>switch_to.frame(找id)<br>switch_to.frame(0)<br>句柄–一种特殊的智能指针：指向当前页面的指针<br>句柄是：driver.window_handles<br>传入句柄：switch_to.window(句柄)</p>
]]></content>
  </entry>
  <entry>
    <title>redis基本操作</title>
    <url>/2022/03/12/redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在linux系统里安装redis<br>（1）wget <a href="http://download.redis.io/releases/redis-5.0.7.tar.gz">http://download.redis.io/releases/redis-5.0.7.tar.gz</a><br>（2）tar -zvxf redis-5.0.7.tar.gz<br>安装yum   install gcc-c++<br>（3）mv /root/redis-5.0.7 /usr/local/redis<br>（4）make &amp;&amp;make install<br>（5）在 /usr/local/bin里创建 kconfig<br>mkdir kconfig</p>
<p> cp  /usr/local/redis/redis.conf kconfig/<br>修改redis.conf<br> daemonize yes  ##  136行把no换成yes  以后台方式启动。</p>
<p>(6) 启动server<br>redis-server   kconfig/redis.conf<br>（7）启动cli  redis-cli -p 6379<br>redis默认16个数据库，编号为0~15<br>select 数据库编号<br>dbsize  获取当前数据库键值的数量<br>flushdb  清空当前数据库<br>flushall   清空所有数据库<br>set   k1  v1   （key value）   get 查看<br>mset  k1  v1  k2  v2 （key value）</p>
<p>keys 格式   查看符合指定格式的key，*为通配符<br>exists key1  查看是否存在一个或多个key<br>type  key  查看key的value的数据类型<br>del 删除key建<br>rename 重命名key值<br>renamenx  key1  key2  只有key2不存在时重命名key1<br>move k1 3 移动k1到数据库3<br>copy  key1  key2  将key1拷贝给key2</p>
]]></content>
  </entry>
  <entry>
    <title>redis知识（2）</title>
    <url>/2022/03/15/redis%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>list列表</p>
]]></content>
  </entry>
  <entry>
    <title>redis主从服务</title>
    <url>/2022/03/16/redis%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>环境配置<br>只配置从库，不配置从库<br>info replication #查看当前库的信息</p>
<h1 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h1><p>role:master    角色：主库<br>connected_slaves:0  没有从机<br>复制3个配置文件<br>（1）端口<br>（2）pid名字<br>（3）log文件名字<br>（4）dump.rdb 名字<br>修改配置文件<br>（1）port 6379  #92行<br>（2）pidfile /var/run/redis_6379.pid  #158行<br>（3）logfile “6379.log”   #171行<br>（4）dbfilename dump6379.rdb   #253行<br>一主（79）二从（80,81）<br>认老大：SLAVEOF  127.0.0.1  6379<br>———————————————————————————<br>role:slave<br>master_host:127.0.0.1<br>master_port:6379<br>———————————————————————————<br>role:master<br>connected_slaves:2<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=196,lag=0<br>slave1:ip=127.0.0.1,port=6381,state=online,offset=196,lag=0<br>———————————————————————————<br>主机可以写，从机不能写只能读。<br>测试：主机断开连接，从机依旧连接到主机，但是没有写操作，这个时候，主机如果回来了，从机依然可以直接获取主机写的信息。<br>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值。</p>
<p>复 制 原 理<br>Slave 启 动 成 功 连 接 到 master 后 会 发 送 一 个 sync 同 步 命 令<br>Master 接 到 命 令 , 启 动 后 台 的 存 盘 进 程 , 同 时 收 集 所 有 接 收 到 的 用 于 修 改 数 据 集 命 令 , 在 后 台 进 程 执 行 完 毕 之 后 , master 案 传 送<br>整 个 数 据 文 件 到 slave , 并 完 成 一 次 完 全 同 步 .<br>全 量 复 制 : 而 slave 服 务 在 接 收 到 数 据 库 文 件 数 据 后 , 将 其 存 盘 五 加 载 到 内 存 中 .<br>增 量 复 制 : Master 继 续 案 新 的 所 有 收 集 到 的 修 改 命 令 依 次 传 给 slave , 完 成 同 步<br>但 是 只 要 是 重 新 连 接 master , 一 次 完 全 同 步 ( 全 量 复 制 ) 将 被 自 动 执 行</p>
<p>层层链路<br>m  —s：m —-s</p>
<p>如果没有老大了，在从机里选一个主机。</p>
<p>SLAVEOF  no  one</p>
]]></content>
  </entry>
  <entry>
    <title>redis哨兵模式</title>
    <url>/2022/03/17/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>哨兵模式可以监控主机是否故障，如果故障了根据投票将从库转换成主库。（sentinel）<br>哨兵是一个独立的进程，其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行多个redis实例。</p>
<p>多哨兵模式，哨兵互相监控。<br>写哨兵配置文件：<br> vim sentinel.conf<br>                            被监控主机名称      host            port       1<br>sentinel monitor  myredis             127.0.0.1      6379     1<br>启动服务<br>redis-sentinel   kconfig/sentinel.conf<br>如果主机节点断了，这个时候就会随机选一个从机当主机</p>
<p>可以查看哨兵日志<br>如果主机回来了，只能当从机</p>
<p>哨 兵 模 式</p>
<p>优 点 :</p>
<p>1、 哨 兵 集 群 , 基 于 主 从 复 制 模 式 , 所 有 的 主 从 配 置 优 点 , 它 全 有</p>
<p>2、 主 从 可 以 切 换 , 故 障 可 以 转 移 , 系 统 的 可 用 性 就 会 更 好</p>
<p>3、 哨 兵 模 式 就 是 主 从 模 式 的 升 级 , 手 动 到 自 动 , 更 加 健 壮 !</p>
<p>缺点 2</p>
<p>1、Redis 不 好 啊 在 线 扩 容 的 , 集 群 容 量 一 旦 到 达 上 限 , 在 线 扩 容 就 十 分 麻 烦 !<br>2、 实 现 哨 兵 模 式 的 配 置 其 实 是 很 麻 烦 的 , 里 面 有 很 多 选 择 !</p>
<p>哨兵模式的配置：<br>port  26379<br>哨兵模式sentinel实例运行的端口 默认是26379<br>哨兵模式的工作目录：<br>dir /tmp<br>主要配置（最主要）<br>sentinel monitor  myredis             127.0.0.1      6379     1</p>
]]></content>
  </entry>
  <entry>
    <title>redis缓存穿透与雪崩</title>
    <url>/2022/03/17/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<p>服务器高可用问题</p>
<p>（1）缓存穿透（查不到）<br>缓存穿透就是，一个用户想要查询一个数据，发现redis数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会使数据库的压力变大，这就也是缓存穿透。<br>布隆过滤器<br>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式储存，在控制层先进行校验，不符合的丢弃，从而避免存储系统的查询压力。<br>缓存空对象<br>（2）缓存击穿（量太大，缓存过期！）<br>设置热点数据永不过期<br>加互斥锁<br>使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可，这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。<br>（3）缓存雪崩<br>一般指一段时间，缓存集中过期失效，redis 宕机！</p>
<p>解决问题：<br>1.redis高可用<br>多设置几台redis，搭建集群（异地多活！）<br>2.限流降级<br>这 个 解 决 方 案 的 思想 是 ,在缓存失效后，通 过 加 锁 或 者 队 列 来 控 制 读 数 据 库 写 缓 存 的 线 程 数 量 , 比 如 对 某 个 key 只 允 许 一 个 线 程 查 询 数 据 和 写 缓 存 , 其 他 线 程 等 待。</p>
<p>3.数据预热<br>数据加热的含义就是子啊正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
  </entry>
</search>
