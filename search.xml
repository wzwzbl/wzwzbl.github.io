<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>linuxday1</title>
    <url>/2021/11/03/day1/</url>
    <content><![CDATA[<p>一、基本命令<br>1.1 关机和重启<br>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p>
<p>1.2 帮助命令<br>–help命令<br>  shutdown –help：<br>  ifconfig  –help：查看网卡信息</p>
<p>man命令（命令说明书）<br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p>
<p>二、目录操作命令<br>2.1 目录切换 cd<br>命令：cd 目录</p>
<p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p>
<p>2.2 目录查看 ls [-al]<br>命令：ls [-al]</p>
<p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p>
<p>2.3 目录操作【增，删，改，查】<br>2.3.1 创建目录【增】 mkdir<br>命令：mkdir 目录</p>
<p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</p>
<p>2.3.2 删除目录或文件【删】rm<br>命令：rm [-rf] 目录</p>
<p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p>
<p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p>
<p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p>
<p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</p>
<p>2.3.3 目录修改【改】mv 和 cp<br>一、重命名目录<br>    命令：mv 当前目录  新目录<br>    例如：mv aaa bbb    将目录aaa改为bbb<br>    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</p>
<p>二、剪切目录<br>    命令：mv 目录名称 目录的新位置<br>    示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面     mv /usr/tmp/aaa /usr<br>    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p>
<p>三、拷贝目录<br>    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归<br>    示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面     cp /usr/tmp/aaa  /usr<br>    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</p>
<p>2.3.4 搜索目录【查】find<br>命令：find 目录 参数 文件名称<br>示例：find /usr/tmp -name ‘a*’    查找/usr/tmp目录下的所有以a开头的目录或文件</p>
<p>三、文件操作命令<br>3.1 文件操作【增，删，改，查】<br>3.1.1 新建文件【增】touch<br>命令：touch 文件名<br>示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</p>
<p>3.1.2 删除文件 【删】 rm<br>命令：rm -rf 文件名</p>
<p>3.1.3 修改文件【改】 vi或vim<br>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p>
<ol>
<li>命令行模式command mode）<br>   控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>   命令行模式下的常用命令：<br>   【1】控制光标移动：↑，↓，j<br>   【2】删除当前行：dd<br>   【3】查找：/字符<br>   【4】进入编辑模式：i o a<br>   【5】进入底行模式：:</li>
<li>编辑模式（Insert mode）<br>   只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>   编辑模式下常用命令：<br>   【1】ESC 退出编辑模式到命令行模式；</li>
<li>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：<br>  【1】退出编辑：   :q<br>  【2】强制退出：   :q!<br>  【3】保存并退出：  :wq</li>
</ol>
<p>打开文件</p>
<p>命令：vi 文件名<br>示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</p>
<p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</p>
<p>编辑文件</p>
<p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p>
<p>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p>
<p>保存或者取消编辑</p>
<p>保存文件：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑</p>
<p>取消编辑：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p>
<p>3.1.4 文件的查看【查】<br>文件的查看命令：cat/more/less/tail</p>
<p>cat：看最后一屏</p>
<p>示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容<br>cat sudo.conf</p>
<p>more：百分比显示</p>
<p>示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>more sudo.conf</p>
<p>less：翻页查看</p>
<p>示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>less sudo.conf</p>
<p>tail：指定行数或者动态查看</p>
<p>示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束<br>tail -10 sudo.conf</p>
<p>3.2 权限修改<br>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>
<p>示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是-rw——-</p>
<p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限</p>
<p>   421  421  421</p>
<ul>
<li> rw-   —     —</li>
</ul>
<p>命令：chmod +x aaa.txt或者采用8421法命令：chmod 100 aaa.txt<br>四、压缩文件操作<br>4.1 打包和压缩<br>Windows的压缩文件的扩展名  .zip/.rar<br>linux中的打包文件：aa.tar<br>linux中的压缩文件：bb.gz<br>linux中打包并压缩的文件：.tar.gz</p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>
<p>命令：tar -zcvf 打包压缩后的文件名 要打包的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名</p>
<p>示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar<br>tar -zcvf ab.tar aa.txt bb.txt<br>或：tar -zcvf ab.tar  *</p>
<p>4.2 解压<br>命令：tar [-zxvf] 压缩文件<br>其中：x：代表解压<br>示例：将/usr/tmp 下的ab.tar解压到当前目录下<br>五、查找命令<br>5.1 grep<br>grep命令是一种强大的文本搜索工具</p>
<p>使用实例：</p>
<p>ps -ef | grep sshd  查找指定ssh服务进程 ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 ps -ef | grep sshd -c 查找指定进程个数<br>5.2 find<br>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p>
<p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>5.3 locate<br>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。如果数据库中没有查询的数据，则会报出locate: can not stat () `/var/lib/mlocate/mlocate.db’: No such file or directory该错误！updatedb即可！</p>
<p>yum -y install mlocate 如果是精简版CentOS系统需要安装locate命令</p>
<p>使用实例：</p>
<p>updatedblocate /etc/sh 搜索etc目录下所有以sh开头的文件 locate pwd 查找和pwd相关的所有文件<br>5.4 whereis<br>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p>
<p>使用实例：</p>
<p>whereis ls    将和ls文件相关的文件都查找出来<br>5.5 which<br>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p>使用实例：</p>
<p>which pwd  查找pwd命令所在路径 which java  查找path中java的路径<br>六、su、sudo<br>6.1 su<br>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。<br>九、定时任务指令crontab 配置<br>crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。</p>
<p>crontab安装： yum install crontabs<br>9.1 命令格式<br>crontab [-u user] file</p>
<p>crontab [-u user] [ -e | -l | -r ]</p>
<p>参数说明：</p>
<p>-u user：用来设定某个用户的crontab服务  </p>
<p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件</p>
<p>并载入crontab。</p>
<p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前</p>
<p>用户的crontab文件。</p>
<p>-l：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前</p>
<p>用户的crontab文件内容。</p>
<p>-r：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab</p>
<p>文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>9.2 配置说明、实例<br>命令：*   *    *   *   *   command  </p>
<p>解释：分  时  日  月  周  命令</p>
<p>第1列表示分钟1～59 每分钟用*或者 */1表示    </p>
<p>第2列表示小时0～23（0表示0点）</p>
<p>第3列表示日期1～31  </p>
<p>第4列表示月份1～12  </p>
<p>第5列标识号星期0～6（0表示星期天）  </p>
<p>第6列要运行的命令<br>十、其他命令<br>10.1 查看当前目录：pwd<br>命令：pwd     查看当前目录路径</p>
<p>10.2 查看进程：ps -ef<br>命令：ps -ef    查看所有正在运行的进程</p>
<p>10.3 结束进程：kill<br>命令：kill pid 或者 kill -9 pid(强制杀死进程)           pid:进程号</p>
<p>10.4 网络通信命令：<br>ifconfig：查看网卡信息</p>
<p>命令：ifconfig 或 ifconfig | more</p>
<p>ping：查看与某台机器的连接情况</p>
<p>命令：ping ip</p>
<p>netstat -an：查看当前系统端口</p>
<p>命令：netstat -an</p>
<p>搜索指定端口<br>命令：netstat -an | grep 8080</p>
<p>10.5 配置网络<br>命令：setup</p>
<p>10.6 重启网络<br>命令：service network restart</p>
<p>10.7 切换用户<br>命令：su - 用户名</p>
<p>10.8 关闭防火墙<br>命令：chkconfig iptables off<br>10.9 修改文件权限<br>命令：chmod 777</p>
<p>10.10 清屏<br>命令：ctrl + l</p>
<p>10.11 vi模式下快捷键<br>esc后:</p>
<p>保存并退出快捷键：shift+z+z</p>
<p>光标跳到最后一行快捷键：shift+g</p>
<p>删除一行：dd</p>
<p>复制一行内容：y+y</p>
<p>粘贴复制的内容：p</p>
<p>十一、Linux项目部署<br>11.1 安装jdk1.8<br>先卸载open-jdk</p>
<p>java -version<br>rpm -qa | grep java</p>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64<br>rpm -e –nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64</p>
<p>开始安装：<br>mkdir /usr/local/src/java<br>rz 上传jdk tar包<br>tar -zxvf jdk-8u181-linux-x64.tar.gz</p>
<p>yum install glibc.i686</p>
<p>配置环境变量：<br> vi /etc/profile</p>
<p> 在末尾行添加<br>  #set java environment<br>  JAVA_HOME=/usr/local/src/jdk8/jdk1.8.0_181<br>  CLASSPATH=.:$JAVA_HOME/lib.tools.jar<br>  PATH=$JAVA_HOME/bin:$PATH<br>  export JAVA_HOME CLASSPATH PATH</p>
<p>保存退出<br>source /etc/profile  使更改的配置立即生效<br>java -version  查看JDK版本信息，如果显示出1.8证明成功</p>
<p>11.2 安装MySQL5.6<br>11.2.1 上传MySQL5.6的tar包<br>创建目录：mkdir /usr/local/src/mysql5.6</p>
<p>上传：MySQL-5.6.34-1.rhel5.x86_64.rpm-bundle.tar 到上面的目录中</p>
<p>11.2.2 安装<br>第一步：解压</p>
<pre><code> 命令：tar -xvf MySQL-5.6.34-1.rhel5.x86_64.rpm-bundle.tar
</code></pre>
<p>第二步：检测是否已经安装了mysql</p>
<pre><code> 命令：rpm -qa | grep mysql   

 如果已经安装了，将其卸载，如：

 rpm -e --nodeps  mysql-libs-5.1.71-1.el6.x86_64
</code></pre>
<p>第三步：安装MySQL的服务端</p>
<pre><code> 命令：rpm -ivh MySQL-server-5.6.34-1.rhel5.x86_64.rpm
</code></pre>
<p>第四步：安装MySQL的客户端</p>
<pre><code> 命令：rpm -ivh MySQL-client-5.6.34-1.rhel5.x86_64.rpm
</code></pre>
<p>第五步：查看MySQL服务运行状态</p>
<pre><code> 命令：service mysql status
</code></pre>
<p>第六步：启动MySQL服务</p>
<pre><code> 命令：service mysql start
</code></pre>
<p>第七步：使用root账号登录mysql<br>注意：这个密码是不安全的，所有需要修改初始密码。</p>
<p>使用密码登录mysql账号：mysql -uroot -p<br>修改root密码：SET PASSWORD = PASSWORD(‘root’);<br>11.2.3 开机自动启动设置<br>加入到系统服务：</p>
<p>chkconfig –add mysql</p>
<p>自动启动：</p>
<p>chkconfig mysql on</p>
<p>查询列表：</p>
<p>chkconfig</p>
<p>说明：都没关闭（off）时是没有自动启动。</p>
<p>11.2.4 开启远程访问<br>登录：</p>
<p>mysql -uroot –proot</p>
<p>设置远程访问（使用root密码）：</p>
<p>grant all privileges on <em>.</em> to ‘root’ @’%’ identified by ‘root’;</p>
<p>flush privileges;</p>
<p>退出mysql，在centos环境下打开3306防火墙</p>
<p>/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p>
<p>/etc/rc.d/init.d/iptables save</p>
<p>/etc/init.d/iptables status</p>
<p>11.3 安装tomcat部署项目<br>准备工作：将web项目打成war包，改名为ROOT.war</p>
<p>11.3.1 创建ucenter用户<br>一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；</p>
<p>创建ucenter用户：</p>
<p>useradd -d /ucenter ucenter</p>
<p>设置密码：</p>
<p>passwd ucenter （密码 ucenter）</p>
<p>切换用户：</p>
<p>su - ucenter</p>
<p>11.3.2 安装Tomcat<br>tomcat只要解压就可以使用。</p>
<p>1、创建web目录<br>mkdir /ucenter/web</p>
<p>2、上传apache-tomcat-7.0.57.tar.gz</p>
<p>3、解压：tar -xvf apache-tomcat-7.0.57.tar.gz</p>
<p>4、重命名：mv apache-tomcat-7.0.57 itcast-usermanage</p>
<p>5、启动tomcat：<br>     cd itcast-usermanage/bin/<br>     ./startup.sh 或者 sh startup.sh</p>
<p>6、查看日志：<br>     tail -f ../logs/catalina.out</p>
<p>7、查看效果 <a href="http://192.168.0.160:8080/">http://192.168.0.160:8080/</a><br>8、防火墙打开 8080 端口<br>     /sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT</p>
<pre><code> /etc/rc.d/init.d/iptables save
</code></pre>
<p>11.3.3 部署用户管理项目<br>1、上传usermanage.sql和ROOT.war到/ucenter/web</p>
<p>2、执行数据库脚本</p>
<pre><code> cat user_manager.sql | mysql -uroot -p123456
</code></pre>
<p>3、部署web程序</p>
<p>3.1 删除webapps下的所有文件</p>
<pre><code> cd /ucenter/web/usermanage/webapps

 rm -rf *
</code></pre>
<p>3.2 拷贝ROOT.war到webapps</p>
<pre><code> cp /ucenter/web/ROOT.war .
</code></pre>
<p>3.3 重新启动tomcat</p>
<pre><code> cd ../bin/

 sh startup.sh &amp;&amp; tail -f ../logs/catalina.out
</code></pre>
<p>3.4 启动浏览器测试</p>
<p>注意事项：Centos环境下部署项目中文乱码问题解决方案</p>
<pre><code>今天在一台新的CentOS机器上使用c3p0连接池操作mysql数据库出现中文乱码问题，具体表现为：查询时无中文乱码问题，写数据时中文乱码，查看了机器上数据库字符集也是UTF8，应该不会出现中文乱码才对，最后在c3p0配置文件中 jdbcUrl后加上：?useUnicode=true&amp;amp;characterEncoding=UTF8 中文就不会乱码了。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>shell03</title>
    <url>/2021/11/03/shell03/</url>
    <content><![CDATA[<p>shell中的运算</p>
<p>2，方法二用$[ ]结构，配合echo输出，同样可以实现加 减 乘 除 取余,另外$(( ))也可以实现相同效果</p>
<p>echo $[1+1]  或者  echo $((1+1))</p>
<p>echo $[2-1]</p>
<p>echo $[2*2]</p>
<p>echo $[4/2]</p>
<p>echo $[5%3]</p>
<p>3，方法三使用let指令，不输出计算结果，专用于创建变量，或者对变量进行自增减</p>
<p>用法一：创建变量</p>
<p>let a=1+1   创建变量a</p>
<p>用法二： 变量的自增减</p>
<p>常规写法  主流写法</p>
<p>let a=a+1    let a++    变量的自增减，将变量a的值加1</p>
<p>let a=a-1  let a–    变量a减1</p>
<p>let a=a+2        let a+=2   变量a加2</p>
<p>let a=a-2  let a-=2   变量a减2</p>
<p>let a=a<em>10  let a</em>=10  变量a乘以10</p>
<p>4，使用bc 计算器，可以进行小数运算</p>
<p>echo “1.1+1” | bc    //非交互的方式使用bc工具</p>
<p>echo “10/3” | bc</p>
<p>echo “scale=3;10/3” | bc   //scale可以定义小数点</p>
<p>后面的长度</p>
<hr>
<p>条件测试：可以为脚本提供智能判断的效果</p>
<p>使用方式：test  表达式   或者    [ 表达式 ]</p>
<p>条件测试种类：</p>
<p>1， 对字符串进行判断</p>
<p>可以使用的方式有： == 两边是否相等   != 两边是否不等  </p>
<p>-z判断变量是否为空  ! -z 判断变量是否非空</p>
<p>[ a == a ]  判断字符串a是否等于a，如果相等，echo $?的返回值就是0</p>
<p>[ root == $USER ]   判断当前用户名是否叫root，如果是，返回值就是0</p>
<p>[ root != $USER ]  判断当前用户名是否不叫root，如果不叫root，返回值就是0</p>
<p>[ -z $a ] 判断变量a是否为空，如果是，返回值是0</p>
<p>[ ! -z $a ] 判，返回断变量a是否非空，如果是值是0</p>
<p>2，逻辑符号，可以连接条件测试或者指令，来决定之后如何操作</p>
<p>&amp;&amp;  之前任务成功就执行之后任务</p>
<p>||   之前任务失败就执行之后任务</p>
<p>[ root == $USER ] || exit   如果当前用户不是管理员，则退出</p>
<p>ls || ls   只执行第1个ls  </p>
<p>ls &amp;&amp; ls   连个ls都执行</p>
<p>编写脚本可以创建用户和配置密码，如果用户没有输入用户名直接敲回车则结束脚本程序</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n</p>
<p>[ -z $n ] &amp;&amp; exit   //如果没有输入用户名就退出脚本，写法一</p>
<p>[ ! -z $n ] || exit   //如果没有输入用户名就退出脚本，写法二</p>
<p>useradd $n</p>
<p>stty -echo</p>
<p>read -p “请输入密码：” p</p>
<p>stty echo</p>
<p>echo $p | passwd –stdin $n</p>
<p>逻辑符号的组合应用</p>
<p>当2个逻辑符号连用时，第二个逻辑符号后面的任务是否执行不能只看前面一个任务，要看前面所有任务的组合，比如下列情况：</p>
<p>touch a b c //创建3个测试文件</p>
<p>ls a &amp;&amp; ls b &amp;&amp; ls c  //结果是都显示，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，然后会导致第二个逻辑符号&amp;&amp;后面的ls c 也执行并且成功。</p>
<p>ls a &amp;&amp; ls b || ls c  //结果是显示a和b，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，但是由于第二个逻辑符号是||，就不会执行最后的ls c任务了</p>
<p>ls a || ls b &amp;&amp; ls c   //结果是显示a和c，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，所以就会导致第二个逻辑符号&amp;&amp;后面的ls c执行</p>
<p>ls a || ls b || ls c   //结果是显示a，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，由于这个组合算成功，所以就不会执行第二个||后面的任务了</p>
<p>练习</p>
<p>安装ftp服务时，如果是非管理员执行该脚本则给出”非管理员无法执行</p>
<p>该脚本”的提示信息并退出</p>
<p>#!/bin/bash</p>
<p>#部署ftp服务</p>
<p>[ $USER != root ] &amp;&amp; echo “非管理员无法执行该脚本”  &amp;&amp; exit</p>
<p>yum -y install vsftpd  &amp;&gt; /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>3，数字的条件测试</p>
<p>-eq等于  -ne不等于  -gt大于  -ge大于等于  -lt小于  -le小于等于 </p>
<p>[ 1 -eq 1 ]  判断1是否等于1，判断成功的话返回值是0，判断失败返回</p>
<p>值是非0</p>
<p>a=10    </p>
<p>b=20</p>
<p>[ $a -eq $b ]    //判断两个变量是否相等</p>
<p>编写脚本，每隔2分钟检查登录服务器的账户数量，如果超过3</p>
<p>人，则发报警邮件给管理员，管理员可以通过mail命令查看邮件</p>
<p>#!/bin/bash</p>
<p>n=$(who | wc -l)    //统计登录服务器的账户数量，存在变量n里</p>
<p>[ $n -gt 3 ] &amp;&amp; echo “有人入侵服务器~，牛老师来了~~~” | mail -s test root</p>
<p>脚本写完后，执行下列指令：</p>
<p>rm -rf /var/spool/mail/root   //清空邮箱(非必须)</p>
<p>[root@svr7 opt]#chmod +x test01.sh   //给脚本添加执行权限</p>
<p>[root@svr7 opt]# crontab -e   //编写计划任务</p>
<p>*/2 * * * * /opt/test01.sh     //每2分钟执行脚本</p>
<p>然后故意多登陆几个账户，每2分钟就可以收到新邮件</p>
<p>4，文件的条件测试</p>
<p>-e判断是否存在不关心文件类型   -f判断是否存在且是普通文件  </p>
<p>-d判断是否存在且是目录  </p>
<p>-r判断当前用户对文件是否能读 ，对root无效</p>
<p>-w判断当前用户对文件是否能写 ，对root无效</p>
<p>-x 判断当前用户对文件是否能执行(文件)，或者进入(目录)</p>
<p>[  -e  a  ]   当前位置如果有a文件，不关心类型，则测试成功</p>
<p>[  -f  a  ]   当前位置如果有叫a的普通文件，则测试成功</p>
<p>[  -d  a  ]   当前位置如果有叫a的目录，则测试成功</p>
<p>[  -r  a  ]   当前用户如果对a文件有读权限，则测试成功</p>
<p>[  -w  a  ]   当前用户如果对a文件有写权限，则测试成功</p>
<p>[  -x  a  ]   当前用户如果对a文件有执行(目录是进入)权限，则测试成功</p>
<hr>
<p>虽然&amp;&amp;和||可以实现逻辑组合，但如果情况比较复杂就可能需要n多个&amp;&amp;或者||，会导致脚本难写，可读性差。此时就可以使用if分支</p>
<p>if分支</p>
<p>单分支<br>if 条件测试;then   //如果条件测试成功，那就执行下面的所有指令(指令可以有很多)</p>
<p>执行指令</p>
<p>执行指令</p>
<p>执行指令</p>
<p>。。。</p>
<p>fi</p>
<p>双分支<br>if 条件测试;then     //如果条件测试成功，那就执行下面的指令1</p>
<p>执行指令1</p>
<p>else       //如果上述条件测试失败，那就执行下面的指令2</p>
<p>执行指令2</p>
<p>fi</p>
<p>ping  -c 定义ping次数   -i 定义ping间隔时间(秒)   </p>
<p>-W 如果ping不通多久反馈结果(秒)</p>
<p>练习：编写脚本测试某ip是否能ping通，但不要显示过程，仅仅显示通了或者</p>
<p>不通即可</p>
<p>ping -c 3 -i 0.1 -W 1 192.168.4.7 &amp;&gt; /dev/null     //ping的具体过程扔黑洞不看</p>
<p>if [ $? -eq 0 ];then  //使用$?可以判断上面的任务是否成功，如果等于0就</p>
<p>是成功</p>
<p>        echo “通了！”</p>
<p>    else</p>
<p>        echo “不通！”</p>
<p>fi</p>
<p>多分支，适合更复杂的情况，结果会有很多的情况<br>if 条件测试;then     //如果条件测试成功，那就执行下面的指令1</p>
<p>执行指令1</p>
<p>   elif 条件测试;then    //如果条件测试成功，那就执行下面的指令2</p>
<p>      执行指令2</p>
<p>else       //如果上述条件测试失败，那就执行下面的指令3</p>
<p>执行指令3</p>
<p>fi</p>
<p>练习：</p>
<p>#!/bin/bash</p>
<p>read -p “请输入期末考试成绩：”  n</p>
<p>if [ $n -ge 90 ];then</p>
<p>        echo “优秀！”</p>
<p>elif [ $n -ge 80 ];then</p>
<p>        echo “良好！”</p>
<p>elif [ $n -ge 60 ];then</p>
<p>        echo “及格！”</p>
<p>else</p>
<p>        echo “晚上跪键盘~”</p>
<p>fi</p>
<p>循环：</p>
<p>有时我们需要某个或者某群任务反复在服务器中执行很多次，就可以使用循环命令写成脚本，而无需手工一次次执行</p>
<p>for循环 可以定义循环次数，有限的循环</p>
<p>基本语法格式：</p>
<p>for 变量名 in 值1 值2 值3 。。。。     //此处变量名可以自定义，通常习惯用i，值的多少决定了下面do与done之间的任务执行多少次，每个值之间有空格，这里是有3个值，所以就循环执行指令3次</p>
<p>do</p>
<p>指令     </p>
<p>done</p>
<hr>
<p>#!/bin/bash</p>
<p>for i in a b c     //给了abc三个值，下面的echo任务就循环三次</p>
<p>do</p>
<p>   echo “abc”</p>
<p>done</p>
<hr>
<p>#!/bin/bash</p>
<p>for i in {1..100}  //循环100次时无需填写100个值，用此格式即可，代表1到100，一共100个值   </p>
<p>do</p>
<p>   echo “abc”</p>
<p>   echo “$i”    //执行任务时，还可以调用变量，变量的值是所有值的轮询，由于这里给了1到100的值，那第一次循环$i就是1，第二次循环$i就是2，依次类推到第100次循环$i就是100</p>
<p>done</p>
<p>编写脚本，使用ping测试192.168.4.1~192.168.4.10，并显示通了或者不通，并且统计多少台通了，多少台不通</p>
<p>#!/bin/bash</p>
<p>x=0    //定义通了的数量,没测试之前是0台</p>
<p>y=0    //定义没通的数量,没测试之前是0台</p>
<p>for i in {1..10}</p>
<p>do</p>
<p>ping -c 3 -i 0.1 -W 1 192.168.4.$i &amp;&gt; /dev/null</p>
<p>if [ $? -eq 0 ];then</p>
<p>        echo “192.168.4.$i 通了！”</p>
<p>        let x++           //每通了一次就把x+1</p>
<p>else</p>
<p>        echo “192.168.4.$i 不通！”</p>
<p>        let y++            //每不通一次就把y+1</p>
<p>fi</p>
<p>done</p>
<p>echo “$x台通了，$y台不通”</p>
<p>练习：</p>
<p>1，列出常见的整数值比较操作，并说明各自作用。</p>
<p>2，运用条件测试操作，检查当前的用户是否为root。</p>
<p>3，绘图描述if双分支结构的执行流程。</p>
<p>4，[ -z $abc ] &amp;&amp; echo “yes” || echo “no” 可以实现什么测试效果。</p>
<p>参考答案</p>
<p>1，列出常见的整数值比较操作，并说明各自作用。</p>
<p>-eq 等于</p>
<p>-ne 不等于</p>
<p>-ge 大于等于</p>
<p>-le 小于等于</p>
<p>-gt 大于</p>
<p>-lt 小于</p>
<p>2，运用条件测试操作，检查当前的用户是否为root。</p>
<p>[ $USER == “root” ] &amp;&amp; echo “yes” || echo no</p>
<p>3，绘图描述if双分支结构的执行流程。</p>
<p>if双分支结构判断一次条件，当条件成立时执行分支1、若不成立则执行分支2，如图-1所示。</p>
<p>   </p>
<p>图-1</p>
<p>4，[ -z $abc ] &amp;&amp; echo “yes” || echo “no” 可以实现什么测试效果。</p>
<p>如果变量abc是空则显示yes，否则显示no</p>
]]></content>
  </entry>
  <entry>
    <title>shell01</title>
    <url>/2021/11/03/shell01/</url>
    <content><![CDATA[<p>正则表达式，使用若干符号配合某工具实现对文档的过滤、查</p>
<p>找、修改等功能</p>
<p>head -5 /etc/passwd &gt; user   //准备素材</p>
<p>grep bin user   //找有bin的行</p>
<p>grep ^bin user        //找以bin开头的行</p>
<p>grep bash user   //找有bash的行</p>
<p>grep bash$ user   //找以bash结尾的行</p>
<p>vim user     //编辑文档添加空行</p>
<p>grep  -n  ^$  user   //找空行，加n选项可以显示行号</p>
<p>grep “[root]” user   //找root四个字符任意一个</p>
<p>grep “[rot]” user         //效果同上，找rot任意一个字符</p>
<p>grep “rot” user   //找连续的rot字符串</p>
<p>grep “[a-z]” user   //找所有小写字母</p>
<p>grep “[A-Z]” user   //找所有大写字母</p>
<p>grep “[a-Z]” user   //找所有字母</p>
<p>grep “[0-9]” user   //找所有数字</p>
<p>grep “[^a-Z]” user  //找字母之外的内容，^写在[]里是取反效果</p>
<p>grep “r..t” user   //找rt之间有2个任意字符的行</p>
<p>grep “r…t” user  //找rt之间有3个任意字符的行，没有匹配内容，就无输出    </p>
<p>grep “<em>“ user  //错误用法，</em>号是匹配前一个字符任意次，不能单独使用</p>
<p>grep “ro*t” user  //找rt，中间的o有没有都行，有几次都行</p>
<p>grep “.” user   //找任意单个字符，文档中每个字符都可以理解为任意字符</p>
<p>grep “.<em>“ user  //找任意，包括空行 .与</em>的组合在正则中相当于通配符的效果</p>
<p>grep “ro{2,4}t” user   //找rt，中间的o可以是2~4个</p>
<p>grep “ro{2,}t” user         //找rt，中间的o可以是2个以及2个以</p>
<p>上</p>
<p>grep “ro{3,7}t” user //找rt，中间的o可以是3~7个，没有匹</p>
<p>配条件就没有任何显示</p>
<p>grep “ro{3,}t” user  //找rt，中间的o可以是3个以及3个以</p>
<p>上</p>
<p>grep “ro{2}t” user  //找rt，中间的o必须是2个</p>
<p>grep “ro{1,}t” user    //找1次以及1次以上的o</p>
<p>egrep “ro{1,}t” user   //效果同上,egrep支持扩展正则，或者grep -E</p>
<p>egrep “ro+t” user     //效果同上，最精简</p>
<p>grep “roo{0,1}t” user   //第二个o要出现0~1次</p>
<p>egrep “roo{0,1}t” user  //效果同上</p>
<p>egrep “roo?t” user   //效果同上，最精简</p>
<p>grep “ro{2}t” user    //找o出现2次的</p>
<p>egrep “ro{2}t” user    //效果同上</p>
<p>egrep “^root|^bin” user   //找root或者以bin开头的行</p>
<p>egrep “^(root|bin)” user   //效果同上</p>
<p>egrep “\bthe\b” abc             //找the，前后不允许出现数</p>
<p>字，字母，下划线</p>
]]></content>
  </entry>
  <entry>
    <title>shell04</title>
    <url>/2021/11/03/shell04/</url>
    <content><![CDATA[<p>如果在for循环中用变量定义循环次数的话</p>
<p>#!/bin/bash</p>
<p>a=20</p>
<p>for i in $(seq $a)     //如果循环次数有变量那么不能写成{1..$a}，要</p>
<p>用seq指令，可以生成数字序列且支持变量</p>
<p>do</p>
<p>        echo abc</p>
<p>        echo $i</p>
<p>done</p>
<hr>
<p>while循环，可以根据条件测试决定循环次数，可以实现无限循环</p>
<p>基本语法结构：</p>
<p>while 条件测试     //如果条件测试得到成功的结果就执行下面的指令，然后再回来继续看条件测试能否成功，如果成功就继续执行指令，且可以实现无限循环，一旦发现条件测试失败了，就立刻终止循环</p>
<p>do</p>
<p>         指令</p>
<p>done</p>
<hr>
<p>另外如果想故意创造一个无限循环可以在while后面写冒号即可</p>
<p>while :                         //冒号代表测试永远正确</p>
<p>do</p>
<p>    echo abc           //循环任务</p>
<p>    sleep 0.1    //如果系统执行任务消耗cpu比较多，可以每次稍微休息一下</p>
<p>done</p>
<hr>
<p>练习：使用while编写猜数脚本</p>
<p>#!/bin/bash</p>
<p>x=$[RANDOM%100]    //RANDOM是可以得到随机数的变量，除以100取余数可以得到零到99之间的随机数，并且存到变量x中</p>
<p>y=0     //这里还可以定义猜的次数，一次没猜时是0次</p>
<p>while :     //无限循环</p>
<p>do</p>
<p>let y++    //每猜一次，把y+1</p>
<p>read -p “请输入一个整数(0-99):” n        //将用户给的数字存到变量n中</p>
<p>if [ $n -eq$x ];then      //使用if多分枝加条件测试判断n是否等于x</p>
<p>        echo “恭喜！猜对了！猜了$y次”     //如果n等于x就喊出这句话</p>
<p>        exit</p>
<p>elif [ $n -gt $x ];then                           //如果n比x大</p>
<p>        echo “猜大了！”</p>
<p>else                                                          //还有最后一种情况</p>
<p>        echo “猜小了！”</p>
<p>fi</p>
<p>done</p>
<hr>
<p>case分支</p>
<p>功能类似if，不如if强大，语句比较精简</p>
<p>基本语法格式：</p>
<p>case 调用变量名 in                          //如果调用的变量内容与下面某个模式一致，就执行模式下面的指令</p>
<p>模式1)                                 //这里的模式可以有很多</p>
<p>         执行指令;;                //指令需要用双分号结尾，如果一个模式有多个指令，那只需在该模式的最后一条指令后加双分号即可</p>
<p>模式2)</p>
<p>         执行指令;;</p>
<p>…</p>
<p>*)                        //如果上述模式都没有被匹配，那就匹配这个</p>
<p>         执行指令</p>
<p>esac</p>
<p>练习：</p>
<p>测试case分支的实际应用</p>
<p>#!/bin/bash</p>
<p>case $1 in          //使用执行脚本后的第1个位置变量作为匹配对象</p>
<p>t|T|tt)                         //如果$1是t或者T或者tt，都可以算匹配</p>
<p>    touch $2;;         //此处是创建文件的命令，后面是第二个位置变量的参数</p>
<p>m|M|mm)</p>
<p>    mkdir $2;;</p>
<p>r)</p>
<p>    rm -rf $2;;</p>
<p>*)</p>
<p>    echo “请输入t|m|r”</p>
<p>esac</p>
<hr>
<p>部署nginx服务</p>
<p>httpd是之前使用过的网站服务，除此之外nginx也可以实现搭建网站的任务</p>
<p>1，将lnmp_soft.tar.gz软件包从真实主机拖拽到虚拟机的管理员家目录，然后释放</p>
<p>[root@svr7 ~]# tar -xf lnmp_soft.tar.gz  //释放到当前目录 </p>
<p>[root@svr7 ~]# cd lnmp_soft/    //然后到释放的目录中</p>
<p>[root@svr7 lnmp_soft]# cp nginx-1.17.6.tar.gz /opt    //将nginx拷贝到opt下</p>
<p>2，安装nginx</p>
<p>由于nginx是源码包，所以需要源码编译安装</p>
<p>编写部署nginx服务的脚本思路：</p>
<p>         1）安装依赖 gcc(编译工具)，pcre-devel，openssl-devel(后两个都是nginx所需依赖包)</p>
<p>         2）释放nginx-1.17.6.tar.gz</p>
<p>         3）进入nginx-1.17.6目录</p>
<p>         4）./configure    配置</p>
<p>         5）make     编译</p>
<p>         6）make install   安装</p>
<p>将上述过程编写成部署nginx服务的脚本</p>
<p>#!/bin/bash</p>
<p>yum -y install gcc pcre-devel openssl-devel &amp;&gt; /dev/null     //安装依赖软件包</p>
<p>tar -xf nginx-1.17.6.tar.gz                  //释放tar包</p>
<p>cd nginx-1.17.6     //进入nginx目录</p>
<p>./configure      //配置</p>
<p>make      //编译</p>
<p>make install    //安装</p>
<p>写完后保存退出，并执行脚本</p>
<p>ls /usr/local/nginx/     //检查nginx如果安装成功该目录会有文件</p>
<p>/usr/local/nginx/sbin/nginx    //开启nginx服务</p>
<p>使用火狐浏览器访问虚拟机可以看到nginx网页</p>
<p>提示：不要忘记关闭防火墙</p>
<p>systemctl stop firewalld</p>
<hr>
<p>编写脚本，使用case分支控制nginx服务</p>
<p>#!/bin/bash</p>
<p>case $1 in          //使用执行脚本后的第1个位置变量作为匹配对象</p>
<p>s|start|kai)   //如果$1是s或start或kai ，那么就执行以下指令</p>
<p>    netstat -ntulp | grep -q nginx   //查询有没有开启nginx服务, -q是不输出查询结果</p>
<p>    [ $? -eq 0 ] &amp;&amp; echo “nginx已经开启” &amp;&amp; exit     //判断如果开了nginx就退出</p>
<p>    /usr/local/nginx/sbin/nginx;;     //如果没开nginx就开启</p>
<p>stop|guan)    //如果$1是stop或guan，那么就执行以下指令：</p>
<p>    /usr/local/nginx/sbin/nginx -s stop;;     //关闭nginx</p>
<p>restart|cq)    //如果$1是restart或cq，那么就执行以下指令</p>
<p>    /usr/local/nginx/sbin/nginx -s stop   //关闭nginx</p>
<p>    /usr/local/nginx/sbin/nginx;;    //开启nginx，此处相当于重启nginx</p>
<p>status|cx)     //如果$1是status或cx，那么就执行以下指令</p>
<p>    netstat -ntulp | grep -q nginx  //查询有没有开启nginx服务, -q是不输出查询结果</p>
<p>    [ $? -eq 0 ] &amp;&amp; echo “nginx正在运行中。。”  || echo “nginx未开启”;;   //根据查询结果输出nginx正在运行或者nginx未开启的提示</p>
<p>*)</p>
<p>   echo “start|stop|restart”    //如果没有匹配任何模式就是喊出使用该脚本的提示，告诉使用者$1应该敲啥，而不能随意敲。</p>
<p>esac    //结尾，固定语法，不能少</p>
<p>netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：</p>
<p>-n以数字格式显示端口号</p>
<p>-t显示TCP连接的端口</p>
<p>-u显示UDP连接的端口</p>
<p>-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口</p>
<p>-p显示监听端口的服务名称是什么（也就是程序名称）</p>
<hr>
<p>如果想在linux中修改输出文字的颜色，可以使用下列方式</p>
<p>echo -e “\033[32mABCD\033[0m”     //-e选项可以激活后面特殊字符的作用，相当于使用echo的扩展功能，\033[32m代表设置颜色为绿色，ABCD是输入内容，\033[0m代表还原颜色。</p>
<p>函数，可以将公共的语句块使用一个函数名来定义，方便后期反复调用，达到精简脚本，增加可读性的目的</p>
<p>#!/bin/bash</p>
<p>a() {          //定义函数</p>
<p>echo abc</p>
<p>echo xyz</p>
<p>}</p>
<p>a    //调用函数，相当于执行上述两个echo任务</p>
<p>a    //可以反复调用</p>
<hr>
<p>#!/bin/bash</p>
<p>a() {                //定义函数</p>
<p>echo -e “\033[$1m$2\033[0m”     //输出不同颜色的文本内容，并加入位置变量</p>
<p>}</p>
<p>a 31 ABCD    //调用时函数后面可以写位置变量的内容，31就是$1  ABCD是$2</p>
<hr>
<p>控制循环</p>
<p>通常，在执行循环任务中途如果想退出可以用exit指令，但该指令不但会退出循环，连同脚本也会一并退出，此时可以使用break与continue指令更精细的控制循环。</p>
<p>exit  可以终止循环，同时脚本也退出</p>
<p>break  可以终止循环，继续执行循环之后的任务</p>
<p>continue  可以终止当前循环，继续下一次循环</p>
<p>练习：</p>
<p>编写脚本，可以为用户进行整数求和，如果输入0则退出并显示</p>
<p>之前求和的结果</p>
<p>#!/bin/bash</p>
<p>y=0   //先定义了一个y，表示用户给的整数之和，一个都没给时就是0</p>
<p>while :</p>
<p>do</p>
<p>read -p “请输入一个整数求和(0是结束并查看结果)”  n</p>
<p>[ -z $n ] &amp;&amp; continue                 //如果n是空值，就重新循环</p>
<p>[ $n -eq 0 ] &amp;&amp; break    //如果n是0，就退出循环</p>
<p>let y+=n    //将y+n</p>
<p>done</p>
<p>echo “整数之和是$y”    //喊出结果</p>
<hr>
<p>linux中很多地方都需要这样或着那样的去使用、管理、操作字符，多掌握在linux中字符的控制方法直接决定能否写好脚本与更好的控制linux系统。</p>
<p>1，字串截取的用法：</p>
<p>${变量名:起始位置:长度}</p>
<p>a=abcdef   //创建变量，作为截取素材</p>
<p>echo ${x:1:2}   //截取bc，位置是从0开始计算，所以要从1开始</p>
<p>才能截取第二个字符b</p>
<p>echo ${x:1:1}  //从第2个字符截取，截取1位</p>
<p>echo ${x:0:2}   //从第1个字符截取，截取2位</p>
<p>编写脚本，可以获取随机的8位字符（将来可以作为为用户配置随机密码时使用）</p>
<p>#!/bin/bash</p>
<p>x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789    //定义变量</p>
<p>for i in {1..8}     //循环8次</p>
<p>do</p>
<p>n=$[RANDOM%62]   //得到0-61之间的随机数</p>
<p>b=${x:n:1}   //随机截取一个x中的字符存储到变量b中</p>
<p>pass=$pass$b  //将每次获取的随机字符存储到变量pass中</p>
<p>done</p>
<p>echo $pass   //循环完8次之后，喊出最终结果，就得到了1个8位的字符</p>
<p>练习：</p>
<p>1，简述Linux服务脚本中的case分支结构。</p>
<p>2，简述定义一个Shell函数的任意一种方法。</p>
<p>3，简述Shell环境常见的中断及退出控制指令。</p>
<p>4，使用 while 循环,统计 1+2+3+4…+100的结果。</p>
<p>提示:可以用一个独立的变量a存放求和的值。</p>
<p>5，编写脚本,通过 3 个 read 命令读取用户输入的三个任意数字,脚本对输入的三个数字求和输出。</p>
<p>6，判断当前系统启动的进程数量,如果进程数量超过 100 个,则发送邮件给 root 报警。</p>
<p>7， 编写脚本,测试当前用户对/etc/passwd 文件是否具有读、写、执行的权限,让脚本执行结果类似下面的效果。</p>
<p>参考答案：</p>
<p>1，简述Linux服务脚本中的case分支结构。</p>
<p>case 变量名 in</p>
<p>模式1)</p>
<p>执行指令 ;;</p>
<p>模式2)</p>
<p>执行指令 ;;</p>
<p>*)</p>
<p>执行指令</p>
<p>esac</p>
<p>2，简述定义一个Shell函数的任意一种方法。</p>
<p>函数名() {</p>
<p>执行指令</p>
<p>}</p>
<p>3，简述Shell环境常见的中断及退出控制指令。</p>
<p>break：跳出当前所在的循环，执行循环之后的语句。</p>
<p>continue:跳过循环内余下的语句，执行下一次循环。</p>
<p>exit:退出脚本</p>
<p>4，使用 while 循环,统计 1+2+3+4…+100的结果。</p>
<p>提示:可以用一个独立的变量a存放求和的值。</p>
<p>#!/bin/bash</p>
<p>a=0</p>
<p>for i in {1..100}</p>
<p>do</p>
<p>let a+=i</p>
<p>done</p>
<p>echo $a</p>
<p>5，编写脚本,通过 3 个 read 命令读取用户输入的三个任意数字,脚本对输入的三个数字求和输出。</p>
<p>#!/bin/bash</p>
<p>read -p “请输入数字” num1</p>
<p>read -p “请输入数字” num2</p>
<p>read -p “请输入数字” num3</p>
<p>echo $[num1+num2+num3]</p>
<p>6，判断当前系统启动的进程数量,如果进程数量超过 100 个,则发送邮件给 root 报警。</p>
<p>(ps aux命令可以查看进程,wc -l可以统计数量)</p>
<p>#!/bin/bash</p>
<p>num=<code>ps aux | wc -l</code></p>
<p>[ $num -gt 100 ] &amp;&amp; echo “进程超过100啦～” | mail -s Warning root</p>
<p>7， 编写脚本,测试当前用户对/etc/passwd 文件是否具有读、写、执行的权限,让脚本执行结果类似下面的效果。</p>
<p>当前用户对/etc/passwd 有读权限</p>
<p>当前用户对/etc/passwd 有写权限</p>
<p>当前用户对/etc/passwd 无执行权限</p>
<p>#!/bin/bash</p>
<p>file=/etc/passwd</p>
<p>[ -r /etc/passwd ] &amp;&amp; echo “当前用户对$file 有读权限” || echo “当前用户对$file 没有读权限”</p>
<p>[ -w /etc/passwd ] &amp;&amp; echo “当前用户对$file 有写权限” || echo “当前用户对$file 没有写权限”</p>
<p>[ -x /etc/passwd ] &amp;&amp; echo “当前用户对$file 有执行权限” || echo “当前用户对$file 没有执行权限”</p>
]]></content>
  </entry>
  <entry>
    <title>shell02</title>
    <url>/2021/11/03/shell02/</url>
    <content><![CDATA[<p>什么是shell</p>
<p>在Linux内核与用户之间的解释器程序</p>
<p>通常指 /bin/bash</p>
<p>负责向内核翻译及传达用户/程序指令</p>
<p>相当于操作系统的“外壳”</p>
<p>Shell的使用方式</p>
<p>交互式   —— 命令行</p>
<p>人工干预、智能化程度高</p>
<p>逐条解释执行、效率低</p>
<p>非交互式 —— 脚本</p>
<p>需要提前设计、智能化难度大</p>
<p>批量执行、效率高</p>
<p>方便在后台静悄悄地运行</p>
<p>什么是Shell脚本？</p>
<p>提前写好可执行语句，能够完成特定任务的文件</p>
<p>顺序、批量化处理</p>
<p>[root@svr7 ~]# cat /etc/shells   //查看所有解释器</p>
<p>[root@svr7 ~]# sh   //切换成sh解释器</p>
<p>sh-4.2# ls    //利用sh解释器输入命令</p>
<p>sh-4.2#exit   //退出sh解释器</p>
<p>[root@svr7 ~]#yum -y install ksh   //安装新解释器</p>
<p>[root@svr7 ~]#ksh   //进入新解释器</p>
<p>Bash的优点 : tab键、历史命令、快捷键、支</p>
<p>持别名、管道、重定向</p>
<p>脚本的编写规范</p>
<p>声明解释器<br>#!/bin/bash</p>
<p>编写注释<br>#注释内容可以是脚本的功能、作者介绍、脚本中各个参数的含义等</p>
<p>执行指令<br>ls</p>
<p>cd</p>
<p>pwd</p>
<p>   所有需要脚本执行的任务都可以逐行写在这里</p>
<p>脚本的执行方式</p>
<p>添加x权限，使用相对或者绝对路径<br>使用解释器执行脚本，会开启解释器子进程<br>bash test01.sh</p>
<p>使用source命令执行脚本，不开启解释器子进程<br>source test01.sh</p>
<p>可以在另外一个命令行终端使用pstree命令查看</p>
<p>    主进程—子进程</p>
<p>  bash—bash—test01.sh    //使用解释器执行脚本</p>
<p>  bash—test01.sh   //使用source执行脚本</p>
<hr>
<p>#!/bin/bash</p>
<p>mkdir abc</p>
<p>cd abc</p>
<p>//可以利用该脚本测试，bash执行时看不到进入abc的效果，因为bash开启了子进程，执行完任务就退出了，父进程并没有进入abc目录，如果使用source执行该脚本就可以看到进入abc目录的效果，因为是父进程亲自进入没有开启子进程。  另外开一个命令行窗口使用pstree命令可以看到具体过程</p>
<hr>
<p>编写部署yum的脚本</p>
<p>#!/bin/bash</p>
<p>#搭建yum仓库</p>
<p>mkdir /yum</p>
<p>mount /dev/cdrom /yum</p>
<p>rm -rf /etc/yum.repos.d/*.repo</p>
<p>echo “[abc] //这里由于喊出的内容是有换行所以要用引号</p>
<p>name=abcabc</p>
<p>baseurl=file:///yum</p>
<p>gpgcheck=0” &gt; /etc/yum.repos.d/abc.repo    //最后使用重定向保存到yum配置文件中</p>
<p>编写脚本，部署httpd，定义默认页面为”web_test~~~~~~”</p>
<p>#!/bin/bash</p>
<p>#部署网站服务</p>
<p>yum -y install httpd</p>
<p>systemctl restart httpd</p>
<p>echo “ web_test~~~~~~” &gt; /var/www/html/index.html</p>
<p>测试时需要临时关闭防火墙</p>
<p>systemctl stop firewalld</p>
<p>编写部署ftp服务的脚本，要求可以实现开机自动运行</p>
<p>#!/bin/bash</p>
<p>#部署ftp服务</p>
<p>yum -y install vsftpd  &amp;&gt;  /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>常量 固定不变的值（内容）</p>
<p>变量 以固定名称存放，可能发生变化的值，可以提高脚本对任务需求、运行环境变化的适应能力，方便在脚本中重复使用</p>
<p>变量的种类</p>
<p>自定义变量，定义名称可以用数字、字母、下划线，不能<br>使用数字开头，不能使用特殊符号</p>
<p>变量名称=变量的值</p>
<p>[root@localhost opt]# a=10   //定义变量(赋值)</p>
<p>[root@localhost opt]# echo $a  //调用变量，此时$a就相当于10</p>
<p>使用自定义变量要注意：</p>
<p>1，a =10     等号两边不能有空格</p>
<p>a=10  然后 a=20  多次赋值之后，仅最后一次生效<br>如果变量不需要了可以使用unset a  取消，或者a=<br>echo ${a}RMB  当变量名与后面的常量容易发生混淆时要用<br>大括号隔开</p>
<p>2，环境变量，是由系统提前定义好，使用时直接调用</p>
<p>USER当前用户名   HOME当前用户的家目录  </p>
<p>UID 当前用户的id号   PWD 当前位置  </p>
<p>SHELL 当前用户的解释器  HOSTNAME 完整主机名</p>
<p>PS1 一级提示符   PS2  二级提示符</p>
<p>PATH 存储了执行指令的路径</p>
<p>3, 预定义变量与位置变量</p>
<p>$*  $#  $$  $?   $1  $2  $3 ….</p>
<p>#!/bin/bash</p>
<p>echo $1   执行脚本后面跟的第1个位置参数</p>
<p>echo $2   执行脚本后面跟的第2个位置参数</p>
<p>echo $3   执行脚本后面跟的第3个位置参数</p>
<p>echo $*   所有的位置参数</p>
<p>echo $#   所有的位置参数的个数</p>
<p>echo $$   随机的进程号</p>
<p>echo $?   判断上一条指令是否执行成功，0是成功，非0是失败</p>
<p>编写脚本，可以创建用户abcd ，并且配置密码123456</p>
<p>#!/bin/bash</p>
<p>useradd abcd</p>
<p>echo 123456 | passwd –stdin abcd</p>
<p>改良版本，使用了位置变量</p>
<p>#!/bin/bash</p>
<p>useradd $1    //创建用户时调用第1个位置变量</p>
<p>echo $2 | passwd –stdin $1  //配置密码时调用第2个位置变量</p>
<hr>
<p>env  //查看所有的环境变量</p>
<p>env | grep HOSTNAME   //在所有的环境变量中查询HOSTNAME</p>
<p>set  //查看所有变量</p>
<p>set | grep abcd  //过滤查询</p>
<hr>
<p>变量的扩展知识</p>
<p>1，引号与反撇号</p>
<p>双引号  界定范围</p>
<p>touch “a b”  可以创建a空格b的文件</p>
<p>a=10</p>
<p>echo  “$a” 可以调用变量</p>
<p>单引号  界定范围  屏蔽特殊符号的功能</p>
<p>touch  ‘a b’  也可以创建a空格b的文件</p>
<p>echo  ‘$a’  无法调用变量，$是调用变量的特殊符号</p>
<p>其效果被屏蔽</p>
<p>`` 反撇号   调用命令执行的结果</p>
<p>a=date    定义变量时如果使用命令则不会直接识别</p>
<p>a=<code>date</code>   使用反撇号可以将命令的执行结果赋值给变量</p>
<p>a=$(date)  效果同上</p>
<p>2，使用read指令，以交互式使用脚本</p>
<p>用法：read -p “提示的信息”  变量名</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n   //执行脚本后可以看到提示信息，输入信息</p>
<p>之后会存到变量n中</p>
<p>useradd $n    //调用变量n创建刚刚定义的用户名</p>
<p>read -p “请输入密码：”  p   </p>
<p>echo $p | passwd –stdin $n</p>
<p>stty -echo  屏蔽回显</p>
<p>stty echo  恢复回显</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n</p>
<p>useradd $n</p>
<p>stty -echo</p>
<p>read -p “请输入密码：” p</p>
<p>stty echo</p>
<p>echo $p | passwd –stdin $n</p>
<p>3， export  定义全局变量，可以让子进程使用父进程定</p>
<p>义的变量</p>
<p>export  b=20   //创建变量b的同时发布为全局效果</p>
<p>export  a  //将已有的变量发布为全局效果</p>
<p>export  -n  a  //取消变量的全局效果</p>
<p>注意，测试时要在父进程创建变量，然后可以执行bash进入</p>
<p>子进程测试效果，如果要返回父进程要执行exit指令</p>
<p>shell中的运算</p>
<p>加、减、乘、除、取余</p>
<p>expr 可以运算并输出结果</p>
<p>expr 1 + 1   //注意，运算符号两边要有空格</p>
<p>expr 2 - 1</p>
<p>expr 2 * 2     //使用转义符号\可以屏蔽之后一个字符的特殊含义</p>
<p>expr 4 / 2   </p>
<p>expr 10 % 3</p>
<p>[root@svr7 opt]# a=10</p>
<p>[root@svr7 opt]# b=20</p>
<p>[root@svr7 opt]# expr $a + $b    //也支持变量的运算</p>
<p>30</p>
<p>[root@svr7 opt]# expr $a + 100</p>
<p>练习题：</p>
<p>1，如何执行Shell脚本？</p>
<p>2 自定义Shell变量时，有哪些注意事项？</p>
<p>3 编写一个Shell脚本程序，用来报告当前用户的环境信息。</p>
<p>4 简述预定义变量$$、$?、$#、$*的作用。</p>
<p>5 编写一个Shell脚本程序，能够部署ftp服务，并开启ftp默认共享的目录权限。</p>
<p>6 简述单引号、双引号、反撇号在变量赋值操作中的特点。</p>
<p>1，如何执行Shell脚本？</p>
<p>方法一：添加x权限，然后使用路径运行</p>
<p>方法二：bash 脚本文件路径</p>
<p>方法三：source 脚本文件路径</p>
<p>2 自定义Shell变量时，有哪些注意事项？</p>
<p>可以包括数字、字母、下划线，不能以数字开头</p>
<p>赋值时等号两边不要有空格</p>
<p>尽量不要使用关键字和特殊字符</p>
<p>给同一个变量多次赋值时，最后一次的赋值生效</p>
<p>3 编写一个Shell脚本程序，用来报告当前用户的环境信息。</p>
<p>新建脚本文件report.sh，执行后能够输出当前的主机名、登录用户名、所在的文件夹路径。</p>
<p>#!/bin/bash</p>
<p>echo “当前的主机名是：$HOSTNAME”</p>
<p>echo “登录用户是：$USER”</p>
<p>echo “当前位于 $PWD 文件夹下”</p>
<p>4 简述预定义变量$$、$?、$#、$*的作用。</p>
<p>$$ 保存当前运行进程号</p>
<p>$? 保存命令执行结果的（返回状态）0是成功，非0是失败</p>
<p>$# 保存位置变量的（个数）</p>
<p>$* 保存所有位置变量的（值）</p>
<p>5 编写一个Shell脚本程序，能够部署ftp服务，并开启ftp默认共享的目录权限。</p>
<p>#!/bin/bash</p>
<p>yum -y install vsftpd &amp;&gt; /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>chmod 777 /var/ftp/pub</p>
<p>6 简述单引号、双引号、反撇号在变量赋值操作中的特点。</p>
<p>双引号 “ “：可以界定范围</p>
<p>单引号 ‘ ‘：可以界定范围，还可以屏蔽特殊符号，即便 $ 也视为普通字符</p>
<p>反撇号 <code> </code>：将命令的执行输出作为变量值</p>
]]></content>
  </entry>
  <entry>
    <title>linuxbay2</title>
    <url>/2021/11/03/linuxbay2/</url>
    <content><![CDATA[<p>一。任务管理 （job control）<br>1.&amp;  将命令丢到后台执行<br>2.ctrl+z 将当前命令丢到后台暂停<br>3.jobs 查看目前后台状态<br>4.fg j将后台的任务拿到前台处理：fg<br>5.bg 让后台的任务变成运行中<br>6.kill 管理后台的任务  -9 强制删除<br>7.nohup 让后台任务在你注销后还能执行， nohup 和&amp; 搭配<br>二。查看进程<br>1.ps aux 查看系统所有进程  ps  -lA  查看所有系统的进程   ps  -l 仅查看自己bash相关的进程<br>2.top 查看动态的进程<br>3.pstree 进程树<br>4priority（pri） 和nice ，pri越小执行的越早。当nice为负，那么该进程就会降低pri，即会变的优先处理<br>列： nice  -n  -5 vim &amp;<br>        renice -5  14836  （重新调整进程的nice）<br>三。查看系统资源信息<br>1.free（内存的使用情况）    -m  显示目前系统的内存容量<br>2.uname 查看系统与内核信息<br>uname -a 输出系统的基本信息   内核的版本<br>uptime 查看系统启动的时间和任务负载<br>netstat ：追踪网络和socket<br>netstat   -tulnp  找出系统上监听的网络连接及pid<br>netstat  -lt   列出所有处于监听状态的tcp端口<br>netstat  -tulnp | grep  8080 查看指定端口号的进程情况<br>lsof  -i：8080  查看某一端口的占用情况  （进程使用的文件）<br>dmesg  |  more  输出所有内核启动时的信息。（dmesg 分析内核产生的信息）<br>vmstat  检测系统资源变化<br>四。特殊文件和进程<br>1./proc/*  (内存)<br>/proc/version  内核版本<br>2.fuser:借该文件找出正在使用该文件的进程<br>fuser -muv  /proc<br>3.pidof 找出执行进程的pid<br>五。selinux<br>查看系统【进程的selinux相关信息】<br>ps  -eZ<br>selinux 三种模式<br>1.enforcing   强制模式<br>2.permissive  宽松模式<br>3.disabled   关闭模式</p>
<p>setenforce  [0|1]   0宽松 1强制<br>getenforce  查看</p>
]]></content>
  </entry>
</search>
