<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>shell03</title>
    <url>/2021/11/03/shell03/</url>
    <content><![CDATA[<p>shell中的运算</p>
<p>2，方法二用$[ ]结构，配合echo输出，同样可以实现加 减 乘 除 取余,另外$(( ))也可以实现相同效果</p>
<p>echo $[1+1]  或者  echo $((1+1))</p>
<p>echo $[2-1]</p>
<p>echo $[2*2]</p>
<p>echo $[4/2]</p>
<p>echo $[5%3]</p>
<p>3，方法三使用let指令，不输出计算结果，专用于创建变量，或者对变量进行自增减</p>
<p>用法一：创建变量</p>
<p>let a=1+1   创建变量a</p>
<p>用法二： 变量的自增减</p>
<p>常规写法  主流写法</p>
<p>let a=a+1    let a++    变量的自增减，将变量a的值加1</p>
<p>let a=a-1  let a–    变量a减1</p>
<p>let a=a+2        let a+=2   变量a加2</p>
<p>let a=a-2  let a-=2   变量a减2</p>
<p>let a=a<em>10  let a</em>=10  变量a乘以10</p>
<p>4，使用bc 计算器，可以进行小数运算</p>
<p>echo “1.1+1” | bc    //非交互的方式使用bc工具</p>
<p>echo “10/3” | bc</p>
<p>echo “scale=3;10/3” | bc   //scale可以定义小数点</p>
<p>后面的长度</p>
<hr>
<p>条件测试：可以为脚本提供智能判断的效果</p>
<p>使用方式：test  表达式   或者    [ 表达式 ]</p>
<p>条件测试种类：</p>
<p>1， 对字符串进行判断</p>
<p>可以使用的方式有： == 两边是否相等   != 两边是否不等  </p>
<p>-z判断变量是否为空  ! -z 判断变量是否非空</p>
<p>[ a == a ]  判断字符串a是否等于a，如果相等，echo $?的返回值就是0</p>
<p>[ root == $USER ]   判断当前用户名是否叫root，如果是，返回值就是0</p>
<p>[ root != $USER ]  判断当前用户名是否不叫root，如果不叫root，返回值就是0</p>
<p>[ -z $a ] 判断变量a是否为空，如果是，返回值是0</p>
<p>[ ! -z $a ] 判，返回断变量a是否非空，如果是值是0</p>
<p>2，逻辑符号，可以连接条件测试或者指令，来决定之后如何操作</p>
<p>&amp;&amp;  之前任务成功就执行之后任务</p>
<p>||   之前任务失败就执行之后任务</p>
<p>[ root == $USER ] || exit   如果当前用户不是管理员，则退出</p>
<p>ls || ls   只执行第1个ls  </p>
<p>ls &amp;&amp; ls   连个ls都执行</p>
<p>编写脚本可以创建用户和配置密码，如果用户没有输入用户名直接敲回车则结束脚本程序</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n</p>
<p>[ -z $n ] &amp;&amp; exit   //如果没有输入用户名就退出脚本，写法一</p>
<p>[ ! -z $n ] || exit   //如果没有输入用户名就退出脚本，写法二</p>
<p>useradd $n</p>
<p>stty -echo</p>
<p>read -p “请输入密码：” p</p>
<p>stty echo</p>
<p>echo $p | passwd –stdin $n</p>
<p>逻辑符号的组合应用</p>
<p>当2个逻辑符号连用时，第二个逻辑符号后面的任务是否执行不能只看前面一个任务，要看前面所有任务的组合，比如下列情况：</p>
<p>touch a b c //创建3个测试文件</p>
<p>ls a &amp;&amp; ls b &amp;&amp; ls c  //结果是都显示，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，然后会导致第二个逻辑符号&amp;&amp;后面的ls c 也执行并且成功。</p>
<p>ls a &amp;&amp; ls b || ls c  //结果是显示a和b，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，但是由于第二个逻辑符号是||，就不会执行最后的ls c任务了</p>
<p>ls a || ls b &amp;&amp; ls c   //结果是显示a和c，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，所以就会导致第二个逻辑符号&amp;&amp;后面的ls c执行</p>
<p>ls a || ls b || ls c   //结果是显示a，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，由于这个组合算成功，所以就不会执行第二个||后面的任务了</p>
<p>练习</p>
<p>安装ftp服务时，如果是非管理员执行该脚本则给出”非管理员无法执行</p>
<p>该脚本”的提示信息并退出</p>
<p>#!/bin/bash</p>
<p>#部署ftp服务</p>
<p>[ $USER != root ] &amp;&amp; echo “非管理员无法执行该脚本”  &amp;&amp; exit</p>
<p>yum -y install vsftpd  &amp;&gt; /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>3，数字的条件测试</p>
<p>-eq等于  -ne不等于  -gt大于  -ge大于等于  -lt小于  -le小于等于 </p>
<p>[ 1 -eq 1 ]  判断1是否等于1，判断成功的话返回值是0，判断失败返回</p>
<p>值是非0</p>
<p>a=10    </p>
<p>b=20</p>
<p>[ $a -eq $b ]    //判断两个变量是否相等</p>
<p>编写脚本，每隔2分钟检查登录服务器的账户数量，如果超过3</p>
<p>人，则发报警邮件给管理员，管理员可以通过mail命令查看邮件</p>
<p>#!/bin/bash</p>
<p>n=$(who | wc -l)    //统计登录服务器的账户数量，存在变量n里</p>
<p>[ $n -gt 3 ] &amp;&amp; echo “有人入侵服务器~，牛老师来了~~~” | mail -s test root</p>
<p>脚本写完后，执行下列指令：</p>
<p>rm -rf /var/spool/mail/root   //清空邮箱(非必须)</p>
<p>[root@svr7 opt]#chmod +x test01.sh   //给脚本添加执行权限</p>
<p>[root@svr7 opt]# crontab -e   //编写计划任务</p>
<p>*/2 * * * * /opt/test01.sh     //每2分钟执行脚本</p>
<p>然后故意多登陆几个账户，每2分钟就可以收到新邮件</p>
<p>4，文件的条件测试</p>
<p>-e判断是否存在不关心文件类型   -f判断是否存在且是普通文件  </p>
<p>-d判断是否存在且是目录  </p>
<p>-r判断当前用户对文件是否能读 ，对root无效</p>
<p>-w判断当前用户对文件是否能写 ，对root无效</p>
<p>-x 判断当前用户对文件是否能执行(文件)，或者进入(目录)</p>
<p>[  -e  a  ]   当前位置如果有a文件，不关心类型，则测试成功</p>
<p>[  -f  a  ]   当前位置如果有叫a的普通文件，则测试成功</p>
<p>[  -d  a  ]   当前位置如果有叫a的目录，则测试成功</p>
<p>[  -r  a  ]   当前用户如果对a文件有读权限，则测试成功</p>
<p>[  -w  a  ]   当前用户如果对a文件有写权限，则测试成功</p>
<p>[  -x  a  ]   当前用户如果对a文件有执行(目录是进入)权限，则测试成功</p>
<hr>
<p>虽然&amp;&amp;和||可以实现逻辑组合，但如果情况比较复杂就可能需要n多个&amp;&amp;或者||，会导致脚本难写，可读性差。此时就可以使用if分支</p>
<p>if分支</p>
<p>单分支<br>if 条件测试;then   //如果条件测试成功，那就执行下面的所有指令(指令可以有很多)</p>
<p>执行指令</p>
<p>执行指令</p>
<p>执行指令</p>
<p>。。。</p>
<p>fi</p>
<p>双分支<br>if 条件测试;then     //如果条件测试成功，那就执行下面的指令1</p>
<p>执行指令1</p>
<p>else       //如果上述条件测试失败，那就执行下面的指令2</p>
<p>执行指令2</p>
<p>fi</p>
<p>ping  -c 定义ping次数   -i 定义ping间隔时间(秒)   </p>
<p>-W 如果ping不通多久反馈结果(秒)</p>
<p>练习：编写脚本测试某ip是否能ping通，但不要显示过程，仅仅显示通了或者</p>
<p>不通即可</p>
<p>ping -c 3 -i 0.1 -W 1 192.168.4.7 &amp;&gt; /dev/null     //ping的具体过程扔黑洞不看</p>
<p>if [ $? -eq 0 ];then  //使用$?可以判断上面的任务是否成功，如果等于0就</p>
<p>是成功</p>
<p>        echo “通了！”</p>
<p>    else</p>
<p>        echo “不通！”</p>
<p>fi</p>
<p>多分支，适合更复杂的情况，结果会有很多的情况<br>if 条件测试;then     //如果条件测试成功，那就执行下面的指令1</p>
<p>执行指令1</p>
<p>   elif 条件测试;then    //如果条件测试成功，那就执行下面的指令2</p>
<p>      执行指令2</p>
<p>else       //如果上述条件测试失败，那就执行下面的指令3</p>
<p>执行指令3</p>
<p>fi</p>
<p>练习：</p>
<p>#!/bin/bash</p>
<p>read -p “请输入期末考试成绩：”  n</p>
<p>if [ $n -ge 90 ];then</p>
<p>        echo “优秀！”</p>
<p>elif [ $n -ge 80 ];then</p>
<p>        echo “良好！”</p>
<p>elif [ $n -ge 60 ];then</p>
<p>        echo “及格！”</p>
<p>else</p>
<p>        echo “晚上跪键盘~”</p>
<p>fi</p>
<p>循环：</p>
<p>有时我们需要某个或者某群任务反复在服务器中执行很多次，就可以使用循环命令写成脚本，而无需手工一次次执行</p>
<p>for循环 可以定义循环次数，有限的循环</p>
<p>基本语法格式：</p>
<p>for 变量名 in 值1 值2 值3 。。。。     //此处变量名可以自定义，通常习惯用i，值的多少决定了下面do与done之间的任务执行多少次，每个值之间有空格，这里是有3个值，所以就循环执行指令3次</p>
<p>do</p>
<p>指令     </p>
<p>done</p>
<hr>
<p>#!/bin/bash</p>
<p>for i in a b c     //给了abc三个值，下面的echo任务就循环三次</p>
<p>do</p>
<p>   echo “abc”</p>
<p>done</p>
<hr>
<p>#!/bin/bash</p>
<p>for i in {1..100}  //循环100次时无需填写100个值，用此格式即可，代表1到100，一共100个值   </p>
<p>do</p>
<p>   echo “abc”</p>
<p>   echo “$i”    //执行任务时，还可以调用变量，变量的值是所有值的轮询，由于这里给了1到100的值，那第一次循环$i就是1，第二次循环$i就是2，依次类推到第100次循环$i就是100</p>
<p>done</p>
<p>编写脚本，使用ping测试192.168.4.1~192.168.4.10，并显示通了或者不通，并且统计多少台通了，多少台不通</p>
<p>#!/bin/bash</p>
<p>x=0    //定义通了的数量,没测试之前是0台</p>
<p>y=0    //定义没通的数量,没测试之前是0台</p>
<p>for i in {1..10}</p>
<p>do</p>
<p>ping -c 3 -i 0.1 -W 1 192.168.4.$i &amp;&gt; /dev/null</p>
<p>if [ $? -eq 0 ];then</p>
<p>        echo “192.168.4.$i 通了！”</p>
<p>        let x++           //每通了一次就把x+1</p>
<p>else</p>
<p>        echo “192.168.4.$i 不通！”</p>
<p>        let y++            //每不通一次就把y+1</p>
<p>fi</p>
<p>done</p>
<p>echo “$x台通了，$y台不通”</p>
<p>练习：</p>
<p>1，列出常见的整数值比较操作，并说明各自作用。</p>
<p>2，运用条件测试操作，检查当前的用户是否为root。</p>
<p>3，绘图描述if双分支结构的执行流程。</p>
<p>4，[ -z $abc ] &amp;&amp; echo “yes” || echo “no” 可以实现什么测试效果。</p>
<p>参考答案</p>
<p>1，列出常见的整数值比较操作，并说明各自作用。</p>
<p>-eq 等于</p>
<p>-ne 不等于</p>
<p>-ge 大于等于</p>
<p>-le 小于等于</p>
<p>-gt 大于</p>
<p>-lt 小于</p>
<p>2，运用条件测试操作，检查当前的用户是否为root。</p>
<p>[ $USER == “root” ] &amp;&amp; echo “yes” || echo no</p>
<p>3，绘图描述if双分支结构的执行流程。</p>
<p>if双分支结构判断一次条件，当条件成立时执行分支1、若不成立则执行分支2，如图-1所示。</p>
<p>   </p>
<p>图-1</p>
<p>4，[ -z $abc ] &amp;&amp; echo “yes” || echo “no” 可以实现什么测试效果。</p>
<p>如果变量abc是空则显示yes，否则显示no</p>
]]></content>
  </entry>
  <entry>
    <title>shell01</title>
    <url>/2021/11/03/shell01/</url>
    <content><![CDATA[<p>正则表达式，使用若干符号配合某工具实现对文档的过滤、查</p>
<p>找、修改等功能</p>
<p>head -5 /etc/passwd &gt; user   //准备素材</p>
<p>grep bin user   //找有bin的行</p>
<p>grep ^bin user        //找以bin开头的行</p>
<p>grep bash user   //找有bash的行</p>
<p>grep bash$ user   //找以bash结尾的行</p>
<p>vim user     //编辑文档添加空行</p>
<p>grep  -n  ^$  user   //找空行，加n选项可以显示行号</p>
<p>grep “[root]” user   //找root四个字符任意一个</p>
<p>grep “[rot]” user         //效果同上，找rot任意一个字符</p>
<p>grep “rot” user   //找连续的rot字符串</p>
<p>grep “[a-z]” user   //找所有小写字母</p>
<p>grep “[A-Z]” user   //找所有大写字母</p>
<p>grep “[a-Z]” user   //找所有字母</p>
<p>grep “[0-9]” user   //找所有数字</p>
<p>grep “[^a-Z]” user  //找字母之外的内容，^写在[]里是取反效果</p>
<p>grep “r..t” user   //找rt之间有2个任意字符的行</p>
<p>grep “r…t” user  //找rt之间有3个任意字符的行，没有匹配内容，就无输出    </p>
<p>grep “<em>“ user  //错误用法，</em>号是匹配前一个字符任意次，不能单独使用</p>
<p>grep “ro*t” user  //找rt，中间的o有没有都行，有几次都行</p>
<p>grep “.” user   //找任意单个字符，文档中每个字符都可以理解为任意字符</p>
<p>grep “.<em>“ user  //找任意，包括空行 .与</em>的组合在正则中相当于通配符的效果</p>
<p>grep “ro{2,4}t” user   //找rt，中间的o可以是2~4个</p>
<p>grep “ro{2,}t” user         //找rt，中间的o可以是2个以及2个以</p>
<p>上</p>
<p>grep “ro{3,7}t” user //找rt，中间的o可以是3~7个，没有匹</p>
<p>配条件就没有任何显示</p>
<p>grep “ro{3,}t” user  //找rt，中间的o可以是3个以及3个以</p>
<p>上</p>
<p>grep “ro{2}t” user  //找rt，中间的o必须是2个</p>
<p>grep “ro{1,}t” user    //找1次以及1次以上的o</p>
<p>egrep “ro{1,}t” user   //效果同上,egrep支持扩展正则，或者grep -E</p>
<p>egrep “ro+t” user     //效果同上，最精简</p>
<p>grep “roo{0,1}t” user   //第二个o要出现0~1次</p>
<p>egrep “roo{0,1}t” user  //效果同上</p>
<p>egrep “roo?t” user   //效果同上，最精简</p>
<p>grep “ro{2}t” user    //找o出现2次的</p>
<p>egrep “ro{2}t” user    //效果同上</p>
<p>egrep “^root|^bin” user   //找root或者以bin开头的行</p>
<p>egrep “^(root|bin)” user   //效果同上</p>
<p>egrep “\bthe\b” abc             //找the，前后不允许出现数</p>
<p>字，字母，下划线</p>
]]></content>
  </entry>
  <entry>
    <title>shell04</title>
    <url>/2021/11/03/shell04/</url>
    <content><![CDATA[<p>如果在for循环中用变量定义循环次数的话</p>
<p>#!/bin/bash</p>
<p>a=20</p>
<p>for i in $(seq $a)     //如果循环次数有变量那么不能写成{1..$a}，要</p>
<p>用seq指令，可以生成数字序列且支持变量</p>
<p>do</p>
<p>        echo abc</p>
<p>        echo $i</p>
<p>done</p>
<hr>
<p>while循环，可以根据条件测试决定循环次数，可以实现无限循环</p>
<p>基本语法结构：</p>
<p>while 条件测试     //如果条件测试得到成功的结果就执行下面的指令，然后再回来继续看条件测试能否成功，如果成功就继续执行指令，且可以实现无限循环，一旦发现条件测试失败了，就立刻终止循环</p>
<p>do</p>
<p>         指令</p>
<p>done</p>
<hr>
<p>另外如果想故意创造一个无限循环可以在while后面写冒号即可</p>
<p>while :                         //冒号代表测试永远正确</p>
<p>do</p>
<p>    echo abc           //循环任务</p>
<p>    sleep 0.1    //如果系统执行任务消耗cpu比较多，可以每次稍微休息一下</p>
<p>done</p>
<hr>
<p>练习：使用while编写猜数脚本</p>
<p>#!/bin/bash</p>
<p>x=$[RANDOM%100]    //RANDOM是可以得到随机数的变量，除以100取余数可以得到零到99之间的随机数，并且存到变量x中</p>
<p>y=0     //这里还可以定义猜的次数，一次没猜时是0次</p>
<p>while :     //无限循环</p>
<p>do</p>
<p>let y++    //每猜一次，把y+1</p>
<p>read -p “请输入一个整数(0-99):” n        //将用户给的数字存到变量n中</p>
<p>if [ $n -eq$x ];then      //使用if多分枝加条件测试判断n是否等于x</p>
<p>        echo “恭喜！猜对了！猜了$y次”     //如果n等于x就喊出这句话</p>
<p>        exit</p>
<p>elif [ $n -gt $x ];then                           //如果n比x大</p>
<p>        echo “猜大了！”</p>
<p>else                                                          //还有最后一种情况</p>
<p>        echo “猜小了！”</p>
<p>fi</p>
<p>done</p>
<hr>
<p>case分支</p>
<p>功能类似if，不如if强大，语句比较精简</p>
<p>基本语法格式：</p>
<p>case 调用变量名 in                          //如果调用的变量内容与下面某个模式一致，就执行模式下面的指令</p>
<p>模式1)                                 //这里的模式可以有很多</p>
<p>         执行指令;;                //指令需要用双分号结尾，如果一个模式有多个指令，那只需在该模式的最后一条指令后加双分号即可</p>
<p>模式2)</p>
<p>         执行指令;;</p>
<p>…</p>
<p>*)                        //如果上述模式都没有被匹配，那就匹配这个</p>
<p>         执行指令</p>
<p>esac</p>
<p>练习：</p>
<p>测试case分支的实际应用</p>
<p>#!/bin/bash</p>
<p>case $1 in          //使用执行脚本后的第1个位置变量作为匹配对象</p>
<p>t|T|tt)                         //如果$1是t或者T或者tt，都可以算匹配</p>
<p>    touch $2;;         //此处是创建文件的命令，后面是第二个位置变量的参数</p>
<p>m|M|mm)</p>
<p>    mkdir $2;;</p>
<p>r)</p>
<p>    rm -rf $2;;</p>
<p>*)</p>
<p>    echo “请输入t|m|r”</p>
<p>esac</p>
<hr>
<p>部署nginx服务</p>
<p>httpd是之前使用过的网站服务，除此之外nginx也可以实现搭建网站的任务</p>
<p>1，将lnmp_soft.tar.gz软件包从真实主机拖拽到虚拟机的管理员家目录，然后释放</p>
<p>[root@svr7 ~]# tar -xf lnmp_soft.tar.gz  //释放到当前目录 </p>
<p>[root@svr7 ~]# cd lnmp_soft/    //然后到释放的目录中</p>
<p>[root@svr7 lnmp_soft]# cp nginx-1.17.6.tar.gz /opt    //将nginx拷贝到opt下</p>
<p>2，安装nginx</p>
<p>由于nginx是源码包，所以需要源码编译安装</p>
<p>编写部署nginx服务的脚本思路：</p>
<p>         1）安装依赖 gcc(编译工具)，pcre-devel，openssl-devel(后两个都是nginx所需依赖包)</p>
<p>         2）释放nginx-1.17.6.tar.gz</p>
<p>         3）进入nginx-1.17.6目录</p>
<p>         4）./configure    配置</p>
<p>         5）make     编译</p>
<p>         6）make install   安装</p>
<p>将上述过程编写成部署nginx服务的脚本</p>
<p>#!/bin/bash</p>
<p>yum -y install gcc pcre-devel openssl-devel &amp;&gt; /dev/null     //安装依赖软件包</p>
<p>tar -xf nginx-1.17.6.tar.gz                  //释放tar包</p>
<p>cd nginx-1.17.6     //进入nginx目录</p>
<p>./configure      //配置</p>
<p>make      //编译</p>
<p>make install    //安装</p>
<p>写完后保存退出，并执行脚本</p>
<p>ls /usr/local/nginx/     //检查nginx如果安装成功该目录会有文件</p>
<p>/usr/local/nginx/sbin/nginx    //开启nginx服务</p>
<p>使用火狐浏览器访问虚拟机可以看到nginx网页</p>
<p>提示：不要忘记关闭防火墙</p>
<p>systemctl stop firewalld</p>
<hr>
<p>编写脚本，使用case分支控制nginx服务</p>
<p>#!/bin/bash</p>
<p>case $1 in          //使用执行脚本后的第1个位置变量作为匹配对象</p>
<p>s|start|kai)   //如果$1是s或start或kai ，那么就执行以下指令</p>
<p>    netstat -ntulp | grep -q nginx   //查询有没有开启nginx服务, -q是不输出查询结果</p>
<p>    [ $? -eq 0 ] &amp;&amp; echo “nginx已经开启” &amp;&amp; exit     //判断如果开了nginx就退出</p>
<p>    /usr/local/nginx/sbin/nginx;;     //如果没开nginx就开启</p>
<p>stop|guan)    //如果$1是stop或guan，那么就执行以下指令：</p>
<p>    /usr/local/nginx/sbin/nginx -s stop;;     //关闭nginx</p>
<p>restart|cq)    //如果$1是restart或cq，那么就执行以下指令</p>
<p>    /usr/local/nginx/sbin/nginx -s stop   //关闭nginx</p>
<p>    /usr/local/nginx/sbin/nginx;;    //开启nginx，此处相当于重启nginx</p>
<p>status|cx)     //如果$1是status或cx，那么就执行以下指令</p>
<p>    netstat -ntulp | grep -q nginx  //查询有没有开启nginx服务, -q是不输出查询结果</p>
<p>    [ $? -eq 0 ] &amp;&amp; echo “nginx正在运行中。。”  || echo “nginx未开启”;;   //根据查询结果输出nginx正在运行或者nginx未开启的提示</p>
<p>*)</p>
<p>   echo “start|stop|restart”    //如果没有匹配任何模式就是喊出使用该脚本的提示，告诉使用者$1应该敲啥，而不能随意敲。</p>
<p>esac    //结尾，固定语法，不能少</p>
<p>netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：</p>
<p>-n以数字格式显示端口号</p>
<p>-t显示TCP连接的端口</p>
<p>-u显示UDP连接的端口</p>
<p>-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口</p>
<p>-p显示监听端口的服务名称是什么（也就是程序名称）</p>
<hr>
<p>如果想在linux中修改输出文字的颜色，可以使用下列方式</p>
<p>echo -e “\033[32mABCD\033[0m”     //-e选项可以激活后面特殊字符的作用，相当于使用echo的扩展功能，\033[32m代表设置颜色为绿色，ABCD是输入内容，\033[0m代表还原颜色。</p>
<p>函数，可以将公共的语句块使用一个函数名来定义，方便后期反复调用，达到精简脚本，增加可读性的目的</p>
<p>#!/bin/bash</p>
<p>a() {          //定义函数</p>
<p>echo abc</p>
<p>echo xyz</p>
<p>}</p>
<p>a    //调用函数，相当于执行上述两个echo任务</p>
<p>a    //可以反复调用</p>
<hr>
<p>#!/bin/bash</p>
<p>a() {                //定义函数</p>
<p>echo -e “\033[$1m$2\033[0m”     //输出不同颜色的文本内容，并加入位置变量</p>
<p>}</p>
<p>a 31 ABCD    //调用时函数后面可以写位置变量的内容，31就是$1  ABCD是$2</p>
<hr>
<p>控制循环</p>
<p>通常，在执行循环任务中途如果想退出可以用exit指令，但该指令不但会退出循环，连同脚本也会一并退出，此时可以使用break与continue指令更精细的控制循环。</p>
<p>exit  可以终止循环，同时脚本也退出</p>
<p>break  可以终止循环，继续执行循环之后的任务</p>
<p>continue  可以终止当前循环，继续下一次循环</p>
<p>练习：</p>
<p>编写脚本，可以为用户进行整数求和，如果输入0则退出并显示</p>
<p>之前求和的结果</p>
<p>#!/bin/bash</p>
<p>y=0   //先定义了一个y，表示用户给的整数之和，一个都没给时就是0</p>
<p>while :</p>
<p>do</p>
<p>read -p “请输入一个整数求和(0是结束并查看结果)”  n</p>
<p>[ -z $n ] &amp;&amp; continue                 //如果n是空值，就重新循环</p>
<p>[ $n -eq 0 ] &amp;&amp; break    //如果n是0，就退出循环</p>
<p>let y+=n    //将y+n</p>
<p>done</p>
<p>echo “整数之和是$y”    //喊出结果</p>
<hr>
<p>linux中很多地方都需要这样或着那样的去使用、管理、操作字符，多掌握在linux中字符的控制方法直接决定能否写好脚本与更好的控制linux系统。</p>
<p>1，字串截取的用法：</p>
<p>${变量名:起始位置:长度}</p>
<p>a=abcdef   //创建变量，作为截取素材</p>
<p>echo ${x:1:2}   //截取bc，位置是从0开始计算，所以要从1开始</p>
<p>才能截取第二个字符b</p>
<p>echo ${x:1:1}  //从第2个字符截取，截取1位</p>
<p>echo ${x:0:2}   //从第1个字符截取，截取2位</p>
<p>编写脚本，可以获取随机的8位字符（将来可以作为为用户配置随机密码时使用）</p>
<p>#!/bin/bash</p>
<p>x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789    //定义变量</p>
<p>for i in {1..8}     //循环8次</p>
<p>do</p>
<p>n=$[RANDOM%62]   //得到0-61之间的随机数</p>
<p>b=${x:n:1}   //随机截取一个x中的字符存储到变量b中</p>
<p>pass=$pass$b  //将每次获取的随机字符存储到变量pass中</p>
<p>done</p>
<p>echo $pass   //循环完8次之后，喊出最终结果，就得到了1个8位的字符</p>
<p>练习：</p>
<p>1，简述Linux服务脚本中的case分支结构。</p>
<p>2，简述定义一个Shell函数的任意一种方法。</p>
<p>3，简述Shell环境常见的中断及退出控制指令。</p>
<p>4，使用 while 循环,统计 1+2+3+4…+100的结果。</p>
<p>提示:可以用一个独立的变量a存放求和的值。</p>
<p>5，编写脚本,通过 3 个 read 命令读取用户输入的三个任意数字,脚本对输入的三个数字求和输出。</p>
<p>6，判断当前系统启动的进程数量,如果进程数量超过 100 个,则发送邮件给 root 报警。</p>
<p>7， 编写脚本,测试当前用户对/etc/passwd 文件是否具有读、写、执行的权限,让脚本执行结果类似下面的效果。</p>
<p>参考答案：</p>
<p>1，简述Linux服务脚本中的case分支结构。</p>
<p>case 变量名 in</p>
<p>模式1)</p>
<p>执行指令 ;;</p>
<p>模式2)</p>
<p>执行指令 ;;</p>
<p>*)</p>
<p>执行指令</p>
<p>esac</p>
<p>2，简述定义一个Shell函数的任意一种方法。</p>
<p>函数名() {</p>
<p>执行指令</p>
<p>}</p>
<p>3，简述Shell环境常见的中断及退出控制指令。</p>
<p>break：跳出当前所在的循环，执行循环之后的语句。</p>
<p>continue:跳过循环内余下的语句，执行下一次循环。</p>
<p>exit:退出脚本</p>
<p>4，使用 while 循环,统计 1+2+3+4…+100的结果。</p>
<p>提示:可以用一个独立的变量a存放求和的值。</p>
<p>#!/bin/bash</p>
<p>a=0</p>
<p>for i in {1..100}</p>
<p>do</p>
<p>let a+=i</p>
<p>done</p>
<p>echo $a</p>
<p>5，编写脚本,通过 3 个 read 命令读取用户输入的三个任意数字,脚本对输入的三个数字求和输出。</p>
<p>#!/bin/bash</p>
<p>read -p “请输入数字” num1</p>
<p>read -p “请输入数字” num2</p>
<p>read -p “请输入数字” num3</p>
<p>echo $[num1+num2+num3]</p>
<p>6，判断当前系统启动的进程数量,如果进程数量超过 100 个,则发送邮件给 root 报警。</p>
<p>(ps aux命令可以查看进程,wc -l可以统计数量)</p>
<p>#!/bin/bash</p>
<p>num=<code>ps aux | wc -l</code></p>
<p>[ $num -gt 100 ] &amp;&amp; echo “进程超过100啦～” | mail -s Warning root</p>
<p>7， 编写脚本,测试当前用户对/etc/passwd 文件是否具有读、写、执行的权限,让脚本执行结果类似下面的效果。</p>
<p>当前用户对/etc/passwd 有读权限</p>
<p>当前用户对/etc/passwd 有写权限</p>
<p>当前用户对/etc/passwd 无执行权限</p>
<p>#!/bin/bash</p>
<p>file=/etc/passwd</p>
<p>[ -r /etc/passwd ] &amp;&amp; echo “当前用户对$file 有读权限” || echo “当前用户对$file 没有读权限”</p>
<p>[ -w /etc/passwd ] &amp;&amp; echo “当前用户对$file 有写权限” || echo “当前用户对$file 没有写权限”</p>
<p>[ -x /etc/passwd ] &amp;&amp; echo “当前用户对$file 有执行权限” || echo “当前用户对$file 没有执行权限”</p>
]]></content>
  </entry>
  <entry>
    <title>shell02</title>
    <url>/2021/11/03/shell02/</url>
    <content><![CDATA[<p>什么是shell</p>
<p>在Linux内核与用户之间的解释器程序</p>
<p>通常指 /bin/bash</p>
<p>负责向内核翻译及传达用户/程序指令</p>
<p>相当于操作系统的“外壳”</p>
<p>Shell的使用方式</p>
<p>交互式   —— 命令行</p>
<p>人工干预、智能化程度高</p>
<p>逐条解释执行、效率低</p>
<p>非交互式 —— 脚本</p>
<p>需要提前设计、智能化难度大</p>
<p>批量执行、效率高</p>
<p>方便在后台静悄悄地运行</p>
<p>什么是Shell脚本？</p>
<p>提前写好可执行语句，能够完成特定任务的文件</p>
<p>顺序、批量化处理</p>
<p>[root@svr7 ~]# cat /etc/shells   //查看所有解释器</p>
<p>[root@svr7 ~]# sh   //切换成sh解释器</p>
<p>sh-4.2# ls    //利用sh解释器输入命令</p>
<p>sh-4.2#exit   //退出sh解释器</p>
<p>[root@svr7 ~]#yum -y install ksh   //安装新解释器</p>
<p>[root@svr7 ~]#ksh   //进入新解释器</p>
<p>Bash的优点 : tab键、历史命令、快捷键、支</p>
<p>持别名、管道、重定向</p>
<p>脚本的编写规范</p>
<p>声明解释器<br>#!/bin/bash</p>
<p>编写注释<br>#注释内容可以是脚本的功能、作者介绍、脚本中各个参数的含义等</p>
<p>执行指令<br>ls</p>
<p>cd</p>
<p>pwd</p>
<p>   所有需要脚本执行的任务都可以逐行写在这里</p>
<p>脚本的执行方式</p>
<p>添加x权限，使用相对或者绝对路径<br>使用解释器执行脚本，会开启解释器子进程<br>bash test01.sh</p>
<p>使用source命令执行脚本，不开启解释器子进程<br>source test01.sh</p>
<p>可以在另外一个命令行终端使用pstree命令查看</p>
<p>    主进程—子进程</p>
<p>  bash—bash—test01.sh    //使用解释器执行脚本</p>
<p>  bash—test01.sh   //使用source执行脚本</p>
<hr>
<p>#!/bin/bash</p>
<p>mkdir abc</p>
<p>cd abc</p>
<p>//可以利用该脚本测试，bash执行时看不到进入abc的效果，因为bash开启了子进程，执行完任务就退出了，父进程并没有进入abc目录，如果使用source执行该脚本就可以看到进入abc目录的效果，因为是父进程亲自进入没有开启子进程。  另外开一个命令行窗口使用pstree命令可以看到具体过程</p>
<hr>
<p>编写部署yum的脚本</p>
<p>#!/bin/bash</p>
<p>#搭建yum仓库</p>
<p>mkdir /yum</p>
<p>mount /dev/cdrom /yum</p>
<p>rm -rf /etc/yum.repos.d/*.repo</p>
<p>echo “[abc] //这里由于喊出的内容是有换行所以要用引号</p>
<p>name=abcabc</p>
<p>baseurl=file:///yum</p>
<p>gpgcheck=0” &gt; /etc/yum.repos.d/abc.repo    //最后使用重定向保存到yum配置文件中</p>
<p>编写脚本，部署httpd，定义默认页面为”web_test~~~~~~”</p>
<p>#!/bin/bash</p>
<p>#部署网站服务</p>
<p>yum -y install httpd</p>
<p>systemctl restart httpd</p>
<p>echo “ web_test~~~~~~” &gt; /var/www/html/index.html</p>
<p>测试时需要临时关闭防火墙</p>
<p>systemctl stop firewalld</p>
<p>编写部署ftp服务的脚本，要求可以实现开机自动运行</p>
<p>#!/bin/bash</p>
<p>#部署ftp服务</p>
<p>yum -y install vsftpd  &amp;&gt;  /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>常量 固定不变的值（内容）</p>
<p>变量 以固定名称存放，可能发生变化的值，可以提高脚本对任务需求、运行环境变化的适应能力，方便在脚本中重复使用</p>
<p>变量的种类</p>
<p>自定义变量，定义名称可以用数字、字母、下划线，不能<br>使用数字开头，不能使用特殊符号</p>
<p>变量名称=变量的值</p>
<p>[root@localhost opt]# a=10   //定义变量(赋值)</p>
<p>[root@localhost opt]# echo $a  //调用变量，此时$a就相当于10</p>
<p>使用自定义变量要注意：</p>
<p>1，a =10     等号两边不能有空格</p>
<p>a=10  然后 a=20  多次赋值之后，仅最后一次生效<br>如果变量不需要了可以使用unset a  取消，或者a=<br>echo ${a}RMB  当变量名与后面的常量容易发生混淆时要用<br>大括号隔开</p>
<p>2，环境变量，是由系统提前定义好，使用时直接调用</p>
<p>USER当前用户名   HOME当前用户的家目录  </p>
<p>UID 当前用户的id号   PWD 当前位置  </p>
<p>SHELL 当前用户的解释器  HOSTNAME 完整主机名</p>
<p>PS1 一级提示符   PS2  二级提示符</p>
<p>PATH 存储了执行指令的路径</p>
<p>3, 预定义变量与位置变量</p>
<p>$*  $#  $$  $?   $1  $2  $3 ….</p>
<p>#!/bin/bash</p>
<p>echo $1   执行脚本后面跟的第1个位置参数</p>
<p>echo $2   执行脚本后面跟的第2个位置参数</p>
<p>echo $3   执行脚本后面跟的第3个位置参数</p>
<p>echo $*   所有的位置参数</p>
<p>echo $#   所有的位置参数的个数</p>
<p>echo $$   随机的进程号</p>
<p>echo $?   判断上一条指令是否执行成功，0是成功，非0是失败</p>
<p>编写脚本，可以创建用户abcd ，并且配置密码123456</p>
<p>#!/bin/bash</p>
<p>useradd abcd</p>
<p>echo 123456 | passwd –stdin abcd</p>
<p>改良版本，使用了位置变量</p>
<p>#!/bin/bash</p>
<p>useradd $1    //创建用户时调用第1个位置变量</p>
<p>echo $2 | passwd –stdin $1  //配置密码时调用第2个位置变量</p>
<hr>
<p>env  //查看所有的环境变量</p>
<p>env | grep HOSTNAME   //在所有的环境变量中查询HOSTNAME</p>
<p>set  //查看所有变量</p>
<p>set | grep abcd  //过滤查询</p>
<hr>
<p>变量的扩展知识</p>
<p>1，引号与反撇号</p>
<p>双引号  界定范围</p>
<p>touch “a b”  可以创建a空格b的文件</p>
<p>a=10</p>
<p>echo  “$a” 可以调用变量</p>
<p>单引号  界定范围  屏蔽特殊符号的功能</p>
<p>touch  ‘a b’  也可以创建a空格b的文件</p>
<p>echo  ‘$a’  无法调用变量，$是调用变量的特殊符号</p>
<p>其效果被屏蔽</p>
<p>`` 反撇号   调用命令执行的结果</p>
<p>a=date    定义变量时如果使用命令则不会直接识别</p>
<p>a=<code>date</code>   使用反撇号可以将命令的执行结果赋值给变量</p>
<p>a=$(date)  效果同上</p>
<p>2，使用read指令，以交互式使用脚本</p>
<p>用法：read -p “提示的信息”  变量名</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n   //执行脚本后可以看到提示信息，输入信息</p>
<p>之后会存到变量n中</p>
<p>useradd $n    //调用变量n创建刚刚定义的用户名</p>
<p>read -p “请输入密码：”  p   </p>
<p>echo $p | passwd –stdin $n</p>
<p>stty -echo  屏蔽回显</p>
<p>stty echo  恢复回显</p>
<p>#!/bin/bash</p>
<p>read -p “请输入用户名：”  n</p>
<p>useradd $n</p>
<p>stty -echo</p>
<p>read -p “请输入密码：” p</p>
<p>stty echo</p>
<p>echo $p | passwd –stdin $n</p>
<p>3， export  定义全局变量，可以让子进程使用父进程定</p>
<p>义的变量</p>
<p>export  b=20   //创建变量b的同时发布为全局效果</p>
<p>export  a  //将已有的变量发布为全局效果</p>
<p>export  -n  a  //取消变量的全局效果</p>
<p>注意，测试时要在父进程创建变量，然后可以执行bash进入</p>
<p>子进程测试效果，如果要返回父进程要执行exit指令</p>
<p>shell中的运算</p>
<p>加、减、乘、除、取余</p>
<p>expr 可以运算并输出结果</p>
<p>expr 1 + 1   //注意，运算符号两边要有空格</p>
<p>expr 2 - 1</p>
<p>expr 2 * 2     //使用转义符号\可以屏蔽之后一个字符的特殊含义</p>
<p>expr 4 / 2   </p>
<p>expr 10 % 3</p>
<p>[root@svr7 opt]# a=10</p>
<p>[root@svr7 opt]# b=20</p>
<p>[root@svr7 opt]# expr $a + $b    //也支持变量的运算</p>
<p>30</p>
<p>[root@svr7 opt]# expr $a + 100</p>
<p>练习题：</p>
<p>1，如何执行Shell脚本？</p>
<p>2 自定义Shell变量时，有哪些注意事项？</p>
<p>3 编写一个Shell脚本程序，用来报告当前用户的环境信息。</p>
<p>4 简述预定义变量$$、$?、$#、$*的作用。</p>
<p>5 编写一个Shell脚本程序，能够部署ftp服务，并开启ftp默认共享的目录权限。</p>
<p>6 简述单引号、双引号、反撇号在变量赋值操作中的特点。</p>
<p>1，如何执行Shell脚本？</p>
<p>方法一：添加x权限，然后使用路径运行</p>
<p>方法二：bash 脚本文件路径</p>
<p>方法三：source 脚本文件路径</p>
<p>2 自定义Shell变量时，有哪些注意事项？</p>
<p>可以包括数字、字母、下划线，不能以数字开头</p>
<p>赋值时等号两边不要有空格</p>
<p>尽量不要使用关键字和特殊字符</p>
<p>给同一个变量多次赋值时，最后一次的赋值生效</p>
<p>3 编写一个Shell脚本程序，用来报告当前用户的环境信息。</p>
<p>新建脚本文件report.sh，执行后能够输出当前的主机名、登录用户名、所在的文件夹路径。</p>
<p>#!/bin/bash</p>
<p>echo “当前的主机名是：$HOSTNAME”</p>
<p>echo “登录用户是：$USER”</p>
<p>echo “当前位于 $PWD 文件夹下”</p>
<p>4 简述预定义变量$$、$?、$#、$*的作用。</p>
<p>$$ 保存当前运行进程号</p>
<p>$? 保存命令执行结果的（返回状态）0是成功，非0是失败</p>
<p>$# 保存位置变量的（个数）</p>
<p>$* 保存所有位置变量的（值）</p>
<p>5 编写一个Shell脚本程序，能够部署ftp服务，并开启ftp默认共享的目录权限。</p>
<p>#!/bin/bash</p>
<p>yum -y install vsftpd &amp;&gt; /dev/null</p>
<p>systemctl restart vsftpd</p>
<p>systemctl enable vsftpd</p>
<p>chmod 777 /var/ftp/pub</p>
<p>6 简述单引号、双引号、反撇号在变量赋值操作中的特点。</p>
<p>双引号 “ “：可以界定范围</p>
<p>单引号 ‘ ‘：可以界定范围，还可以屏蔽特殊符号，即便 $ 也视为普通字符</p>
<p>反撇号 <code> </code>：将命令的执行输出作为变量值</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday2</title>
    <url>/2021/11/03/linuxday2/</url>
    <content><![CDATA[<p>一。任务管理 （job control）<br>1.&amp;  将命令丢到后台执行<br>2.ctrl+z 将当前命令丢到后台暂停<br>3.jobs 查看目前后台状态<br>4.fg j将后台的任务拿到前台处理：fg<br>5.bg 让后台的任务变成运行中<br>6.kill 管理后台的任务  -9 强制删除<br>7.nohup 让后台任务在你注销后还能执行， nohup 和&amp; 搭配<br>二。查看进程<br>1.ps aux 查看系统所有进程  ps  -lA  查看所有系统的进程   ps  -l 仅查看自己bash相关的进程<br>2.top 查看动态的进程<br>3.pstree 进程树<br>4priority（pri） 和nice ，pri越小执行的越早。当nice为负，那么该进程就会降低pri，即会变的优先处理<br>列： nice  -n  -5 vim &amp;<br>        renice -5  14836  （重新调整进程的nice）<br>三。查看系统资源信息<br>1.free（内存的使用情况）    -m  显示目前系统的内存容量<br>2.uname 查看系统与内核信息<br>uname -a 输出系统的基本信息   内核的版本<br>uptime 查看系统启动的时间和任务负载<br>netstat ：追踪网络和socket<br>netstat   -tulnp  找出系统上监听的网络连接及pid<br>netstat  -lt   列出所有处于监听状态的tcp端口<br>netstat  -tulnp | grep  8080 查看指定端口号的进程情况<br>lsof  -i：8080  查看某一端口的占用情况  （进程使用的文件）<br>dmesg  |  more  输出所有内核启动时的信息。（dmesg 分析内核产生的信息）<br>vmstat  检测系统资源变化<br>四。特殊文件和进程<br>1./proc/*  (内存)<br>/proc/version  内核版本<br>2.fuser:借该文件找出正在使用该文件的进程<br>fuser -muv  /proc<br>3.pidof 找出执行进程的pid<br>五。selinux<br>查看系统【进程的selinux相关信息】<br>ps  -eZ<br>selinux 三种模式<br>1.enforcing   强制模式<br>2.permissive  宽松模式<br>3.disabled   关闭模式<br>setenforce  [0|1]   0宽松 1强制<br>getenforce  查看<br>4./etc/selinux/config 是selinux的配置文件<br>5.selinux各个规则的布尔值查询getsebool<br>查询本系统的所有的布尔值的设置情况<br>getsebool  -a     修改布尔值 ：  setsebool  【-p】  【规则名称】  【0|1】<br>6.seinfo  列出selinux在此策略下的统计状态，还有sesearch 是找出进程能读取文件selinux的类型<br>7.使用chcon手动修改（文件）的selinux类型<br>restorecon 恢复正确的selinux类型（文件）<br>semanage 默认目录的安全上下文查询和修改  -a 增加 -m 修改  -d 删除</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday1</title>
    <url>/2021/11/03/linuxday1/</url>
    <content><![CDATA[<p>一、基本命令<br>1.1 关机和重启<br>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p>
<p>1.2 帮助命令<br>–help命令<br>  shutdown –help：<br>  ifconfig  –help：查看网卡信息</p>
<p>man命令（命令说明书）<br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p>
<p>二、目录操作命令<br>2.1 目录切换 cd<br>命令：cd 目录</p>
<p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p>
<p>2.2 目录查看 ls [-al]<br>命令：ls [-al]</p>
<p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p>
<p>2.3 目录操作【增，删，改，查】<br>2.3.1 创建目录【增】 mkdir<br>命令：mkdir 目录</p>
<p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</p>
<p>2.3.2 删除目录或文件【删】rm<br>命令：rm [-rf] 目录</p>
<p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p>
<p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p>
<p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p>
<p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</p>
<p>2.3.3 目录修改【改】mv 和 cp<br>一、重命名目录<br>    命令：mv 当前目录  新目录<br>    例如：mv aaa bbb    将目录aaa改为bbb<br>    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</p>
<p>二、剪切目录<br>    命令：mv 目录名称 目录的新位置<br>    示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面     mv /usr/tmp/aaa /usr<br>    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p>
<p>三、拷贝目录<br>    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归<br>    示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面     cp /usr/tmp/aaa  /usr<br>    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</p>
<p>2.3.4 搜索目录【查】find<br>命令：find 目录 参数 文件名称<br>示例：find /usr/tmp -name ‘a*’    查找/usr/tmp目录下的所有以a开头的目录或文件</p>
<p>三、文件操作命令<br>3.1 文件操作【增，删，改，查】<br>3.1.1 新建文件【增】touch<br>命令：touch 文件名<br>示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</p>
<p>3.1.2 删除文件 【删】 rm<br>命令：rm -rf 文件名</p>
<p>3.1.3 修改文件【改】 vi或vim<br>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p>
<ol>
<li>命令行模式command mode）<br>   控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>   命令行模式下的常用命令：<br>   【1】控制光标移动：↑，↓，j<br>   【2】删除当前行：dd<br>   【3】查找：/字符<br>   【4】进入编辑模式：i o a<br>   【5】进入底行模式：:</li>
<li>编辑模式（Insert mode）<br>   只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>   编辑模式下常用命令：<br>   【1】ESC 退出编辑模式到命令行模式；</li>
<li>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：<br>  【1】退出编辑：   :q<br>  【2】强制退出：   :q!<br>  【3】保存并退出：  :wq</li>
</ol>
<p>打开文件</p>
<p>命令：vi 文件名<br>示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</p>
<p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</p>
<p>编辑文件</p>
<p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p>
<p>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p>
<p>保存或者取消编辑</p>
<p>保存文件：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑</p>
<p>取消编辑：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p>
<p>3.1.4 文件的查看【查】<br>文件的查看命令：cat/more/less/tail</p>
<p>cat：看最后一屏</p>
<p>示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容<br>cat sudo.conf</p>
<p>more：百分比显示</p>
<p>示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>more sudo.conf</p>
<p>less：翻页查看</p>
<p>示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>less sudo.conf</p>
<p>tail：指定行数或者动态查看</p>
<p>示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束<br>tail -10 sudo.conf</p>
<p>3.2 权限修改<br>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>
<p>示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是-rw——-</p>
<p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限</p>
<p>   421  421  421</p>
<ul>
<li> rw-   —     —</li>
</ul>
<p>命令：chmod +x aaa.txt或者采用8421法命令：chmod 100 aaa.txt<br>四、压缩文件操作<br>4.1 打包和压缩<br>Windows的压缩文件的扩展名  .zip/.rar<br>linux中的打包文件：aa.tar<br>linux中的压缩文件：bb.gz<br>linux中打包并压缩的文件：.tar.gz</p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>
<p>命令：tar -zcvf 打包压缩后的文件名 要打包的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名</p>
<p>示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar<br>tar -zcvf ab.tar aa.txt bb.txt<br>或：tar -zcvf ab.tar  *</p>
<p>4.2 解压<br>命令：tar [-zxvf] 压缩文件<br>其中：x：代表解压<br>示例：将/usr/tmp 下的ab.tar解压到当前目录下<br>五、查找命令<br>5.1 grep<br>grep命令是一种强大的文本搜索工具</p>
<p>使用实例：</p>
<p>ps -ef | grep sshd  查找指定ssh服务进程 ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 ps -ef | grep sshd -c 查找指定进程个数<br>5.2 find<br>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p>
<p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>5.3 locate<br>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。如果数据库中没有查询的数据，则会报出locate: can not stat () `/var/lib/mlocate/mlocate.db’: No such file or directory该错误！updatedb即可！</p>
<p>yum -y install mlocate 如果是精简版CentOS系统需要安装locate命令</p>
<p>使用实例：</p>
<p>updatedblocate /etc/sh 搜索etc目录下所有以sh开头的文件 locate pwd 查找和pwd相关的所有文件<br>5.4 whereis<br>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p>
<p>使用实例：</p>
<p>whereis ls    将和ls文件相关的文件都查找出来<br>5.5 which<br>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p>使用实例：</p>
<p>which pwd  查找pwd命令所在路径 which java  查找path中java的路径<br>六、su、sudo<br>6.1 su<br>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。<br>九、定时任务指令crontab 配置<br>crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。</p>
<p>crontab安装： yum install crontabs<br>9.1 命令格式<br>crontab [-u user] file</p>
<p>crontab [-u user] [ -e | -l | -r ]</p>
<p>参数说明：</p>
<p>-u user：用来设定某个用户的crontab服务  </p>
<p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件</p>
<p>并载入crontab。</p>
<p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前</p>
<p>用户的crontab文件。</p>
<p>-l：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前</p>
<p>用户的crontab文件内容。</p>
<p>-r：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab</p>
<p>文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>9.2 配置说明、实例<br>命令：*   *    *   *   *   command  </p>
<p>解释：分  时  日  月  周  命令</p>
<p>第1列表示分钟1～59 每分钟用*或者 */1表示    </p>
<p>第2列表示小时0～23（0表示0点）</p>
<p>第3列表示日期1～31  </p>
<p>第4列表示月份1～12  </p>
<p>第5列标识号星期0～6（0表示星期天）  </p>
<p>第6列要运行的命令<br>十、其他命令<br>10.1 查看当前目录：pwd<br>命令：pwd     查看当前目录路径</p>
<p>10.2 查看进程：ps -ef<br>命令：ps -ef    查看所有正在运行的进程</p>
<p>10.3 结束进程：kill<br>命令：kill pid 或者 kill -9 pid(强制杀死进程)           pid:进程号</p>
<p>10.4 网络通信命令：<br>ifconfig：查看网卡信息</p>
<p>命令：ifconfig 或 ifconfig | more</p>
<p>ping：查看与某台机器的连接情况</p>
<p>命令：ping ip</p>
<p>netstat -an：查看当前系统端口</p>
<p>命令：netstat -an</p>
<p>搜索指定端口<br>命令：netstat -an | grep 8080</p>
<p>10.5 配置网络<br>命令：setup</p>
<p>10.6 重启网络<br>命令：service network restart</p>
<p>10.7 切换用户<br>命令：su - 用户名</p>
<p>10.8 关闭防火墙<br>命令：chkconfig iptables off<br>10.9 修改文件权限<br>命令：chmod 777</p>
<p>10.10 清屏<br>命令：ctrl + l</p>
<p>10.11 vi模式下快捷键<br>esc后:</p>
<p>保存并退出快捷键：shift+z+z</p>
<p>光标跳到最后一行快捷键：shift+g</p>
<p>删除一行：dd</p>
<p>复制一行内容：y+y</p>
<p>粘贴复制的内容：p</p>
<p>十一、Linux项目部署<br>11.1 安装jdk1.8<br>先卸载open-jdk</p>
<p>java -version<br>rpm -qa | grep java</p>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64<br>rpm -e –nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64</p>
<p>开始安装：<br>mkdir /usr/local/src/java<br>rz 上传jdk tar包<br>tar -zxvf jdk-8u181-linux-x64.tar.gz</p>
<p>yum install glibc.i686</p>
<p>配置环境变量：<br> vi /etc/profile</p>
<p> 在末尾行添加<br>  #set java environment<br>  JAVA_HOME=/usr/local/src/jdk8/jdk1.8.0_181<br>  CLASSPATH=.:$JAVA_HOME/lib.tools.jar<br>  PATH=$JAVA_HOME/bin:$PATH<br>  export JAVA_HOME CLASSPATH PATH</p>
<p>保存退出<br>source /etc/profile  使更改的配置立即生效<br>java -version  查看JDK版本信息，如果显示出1.8证明成功</p>
<p>11.2 安装MySQL5.6<br>11.2.1 上传MySQL5.6的tar包<br>创建目录：mkdir /usr/local/src/mysql5.6</p>
<p>上传：MySQL-5.6.34-1.rhel5.x86_64.rpm-bundle.tar 到上面的目录中</p>
<p>11.2.2 安装<br>第一步：解压</p>
<pre><code> 命令：tar -xvf MySQL-5.6.34-1.rhel5.x86_64.rpm-bundle.tar
</code></pre>
<p>第二步：检测是否已经安装了mysql</p>
<pre><code> 命令：rpm -qa | grep mysql   

 如果已经安装了，将其卸载，如：

 rpm -e --nodeps  mysql-libs-5.1.71-1.el6.x86_64
</code></pre>
<p>第三步：安装MySQL的服务端</p>
<pre><code> 命令：rpm -ivh MySQL-server-5.6.34-1.rhel5.x86_64.rpm
</code></pre>
<p>第四步：安装MySQL的客户端</p>
<pre><code> 命令：rpm -ivh MySQL-client-5.6.34-1.rhel5.x86_64.rpm
</code></pre>
<p>第五步：查看MySQL服务运行状态</p>
<pre><code> 命令：service mysql status
</code></pre>
<p>第六步：启动MySQL服务</p>
<pre><code> 命令：service mysql start
</code></pre>
<p>第七步：使用root账号登录mysql<br>注意：这个密码是不安全的，所有需要修改初始密码。</p>
<p>使用密码登录mysql账号：mysql -uroot -p<br>修改root密码：SET PASSWORD = PASSWORD(‘root’);<br>11.2.3 开机自动启动设置<br>加入到系统服务：</p>
<p>chkconfig –add mysql</p>
<p>自动启动：</p>
<p>chkconfig mysql on</p>
<p>查询列表：</p>
<p>chkconfig</p>
<p>说明：都没关闭（off）时是没有自动启动。</p>
<p>11.2.4 开启远程访问<br>登录：</p>
<p>mysql -uroot –proot</p>
<p>设置远程访问（使用root密码）：</p>
<p>grant all privileges on <em>.</em> to ‘root’ @’%’ identified by ‘root’;</p>
<p>flush privileges;</p>
<p>退出mysql，在centos环境下打开3306防火墙</p>
<p>/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p>
<p>/etc/rc.d/init.d/iptables save</p>
<p>/etc/init.d/iptables status</p>
<p>11.3 安装tomcat部署项目<br>准备工作：将web项目打成war包，改名为ROOT.war</p>
<p>11.3.1 创建ucenter用户<br>一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；</p>
<p>创建ucenter用户：</p>
<p>useradd -d /ucenter ucenter</p>
<p>设置密码：</p>
<p>passwd ucenter （密码 ucenter）</p>
<p>切换用户：</p>
<p>su - ucenter</p>
<p>11.3.2 安装Tomcat<br>tomcat只要解压就可以使用。</p>
<p>1、创建web目录<br>mkdir /ucenter/web</p>
<p>2、上传apache-tomcat-7.0.57.tar.gz</p>
<p>3、解压：tar -xvf apache-tomcat-7.0.57.tar.gz</p>
<p>4、重命名：mv apache-tomcat-7.0.57 itcast-usermanage</p>
<p>5、启动tomcat：<br>     cd itcast-usermanage/bin/<br>     ./startup.sh 或者 sh startup.sh</p>
<p>6、查看日志：<br>     tail -f ../logs/catalina.out</p>
<p>7、查看效果 <a href="http://192.168.0.160:8080/">http://192.168.0.160:8080/</a><br>8、防火墙打开 8080 端口<br>     /sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT</p>
<pre><code> /etc/rc.d/init.d/iptables save
</code></pre>
<p>11.3.3 部署用户管理项目<br>1、上传usermanage.sql和ROOT.war到/ucenter/web</p>
<p>2、执行数据库脚本</p>
<pre><code> cat user_manager.sql | mysql -uroot -p123456
</code></pre>
<p>3、部署web程序</p>
<p>3.1 删除webapps下的所有文件</p>
<pre><code> cd /ucenter/web/usermanage/webapps

 rm -rf *
</code></pre>
<p>3.2 拷贝ROOT.war到webapps</p>
<pre><code> cp /ucenter/web/ROOT.war .
</code></pre>
<p>3.3 重新启动tomcat</p>
<pre><code> cd ../bin/

 sh startup.sh &amp;&amp; tail -f ../logs/catalina.out
</code></pre>
<p>3.4 启动浏览器测试</p>
<p>注意事项：Centos环境下部署项目中文乱码问题解决方案</p>
<pre><code>今天在一台新的CentOS机器上使用c3p0连接池操作mysql数据库出现中文乱码问题，具体表现为：查询时无中文乱码问题，写数据时中文乱码，查看了机器上数据库字符集也是UTF8，应该不会出现中文乱码才对，最后在c3p0配置文件中 jdbcUrl后加上：?useUnicode=true&amp;amp;characterEncoding=UTF8 中文就不会乱码了。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>linuxday3</title>
    <url>/2021/11/05/linuxday3/</url>
    <content><![CDATA[<p>一。实例：通过vsftp这个ftp服务器来读写系统上的文件、<br>1.先创建ftptest用户并设置密码<br>useradd  ftptest<br>echo  ”123“  | passwd  –stdin ftptest<br>2.安装vsftpd这个服务器软件，同时启动，并开机自启。<br>yum  install  /mnt/P{tab}/vsftpd-3*<br>systemctl  start  vsftpd</p>
<p>二。systemctl管理服务<br>systemctl  【命令】  【服务】<br>start 启动  stop 关闭  restart  重启  enable 开机自启  status 查看</p>
<p>systemctl   列出系统上面启动的unit（服务）</p>
<p>systemctl是 Systemd 的主命令，用于管理系统。</p>
<h1 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h1><p>$ sudo systemctl reboot</p>
<h1 id="关闭系统，切断电源"><a href="#关闭系统，切断电源" class="headerlink" title="关闭系统，切断电源"></a>关闭系统，切断电源</h1><p>$ sudo systemctl poweroff</p>
<h1 id="CPU停止工作"><a href="#CPU停止工作" class="headerlink" title="CPU停止工作"></a>CPU停止工作</h1><p>$ sudo systemctl halt</p>
<h1 id="暂停系统"><a href="#暂停系统" class="headerlink" title="暂停系统"></a>暂停系统</h1><p>$ sudo systemctl suspend</p>
<h1 id="让系统进入冬眠状态"><a href="#让系统进入冬眠状态" class="headerlink" title="让系统进入冬眠状态"></a>让系统进入冬眠状态</h1><p>$ sudo systemctl hibernate</p>
<h1 id="让系统进入交互式休眠状态"><a href="#让系统进入交互式休眠状态" class="headerlink" title="让系统进入交互式休眠状态"></a>让系统进入交互式休眠状态</h1><p>$ sudo systemctl hybrid-sleep</p>
<h1 id="启动进入救援状态（单用户状态）"><a href="#启动进入救援状态（单用户状态）" class="headerlink" title="启动进入救援状态（单用户状态）"></a>启动进入救援状态（单用户状态）</h1><p>$ sudo systemctl rescue<br>3.2 systemd-analyze<br>systemd-analyze命令用于查看启动耗时。</p>
<h1 id="查看启动耗时"><a href="#查看启动耗时" class="headerlink" title="查看启动耗时"></a>查看启动耗时</h1><p>$ systemd-analyze                                                                                       </p>
<h1 id="查看每个服务的启动耗时"><a href="#查看每个服务的启动耗时" class="headerlink" title="查看每个服务的启动耗时"></a>查看每个服务的启动耗时</h1><p>$ systemd-analyze blame</p>
<h1 id="显示瀑布状的启动过程流"><a href="#显示瀑布状的启动过程流" class="headerlink" title="显示瀑布状的启动过程流"></a>显示瀑布状的启动过程流</h1><p>$ systemd-analyze critical-chain</p>
<h1 id="显示指定服务的启动流"><a href="#显示指定服务的启动流" class="headerlink" title="显示指定服务的启动流"></a>显示指定服务的启动流</h1><p>$ systemd-analyze critical-chain atd.service<br> hostnamectl<br>hostnamectl命令用于查看当前主机的信息。</p>
<h1 id="显示当前主机的信息"><a href="#显示当前主机的信息" class="headerlink" title="显示当前主机的信息"></a>显示当前主机的信息</h1><p>$ hostnamectl</p>
<h1 id="设置主机名。"><a href="#设置主机名。" class="headerlink" title="设置主机名。"></a>设置主机名。</h1><p>$ sudo hostnamectl set-hostname rhel7<br>3.4 localectl<br>localectl命令用于查看本地化设置。</p>
<h1 id="查看本地化设置"><a href="#查看本地化设置" class="headerlink" title="查看本地化设置"></a>查看本地化设置</h1><p>$ localectl</p>
<h1 id="设置本地化参数。"><a href="#设置本地化参数。" class="headerlink" title="设置本地化参数。"></a>设置本地化参数。</h1><p>$ sudo localectl set-locale LANG=en_GB.utf8<br>$ sudo localectl set-keymap en_GB<br>3.5 timedatectl<br>timedatectl命令用于查看当前时区设置。</p>
<h1 id="查看当前时区设置"><a href="#查看当前时区设置" class="headerlink" title="查看当前时区设置"></a>查看当前时区设置</h1><p>$ timedatectl</p>
<h1 id="显示所有可用的时区"><a href="#显示所有可用的时区" class="headerlink" title="显示所有可用的时区"></a>显示所有可用的时区</h1><p>$ timedatectl list-timezones                                                                                   </p>
<h1 id="设置当前时区"><a href="#设置当前时区" class="headerlink" title="设置当前时区"></a>设置当前时区</h1><p>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br>3.6 loginctl<br>loginctl命令用于查看当前登录的用户。</p>
<h1 id="列出当前session"><a href="#列出当前session" class="headerlink" title="列出当前session"></a>列出当前session</h1><p>$ loginctl list-sessions</p>
<h1 id="列出当前登录用户"><a href="#列出当前登录用户" class="headerlink" title="列出当前登录用户"></a>列出当前登录用户</h1><p>$ loginctl list-users</p>
<h1 id="列出显示指定用户的信息"><a href="#列出显示指定用户的信息" class="headerlink" title="列出显示指定用户的信息"></a>列出显示指定用户的信息</h1><p>$ loginctl show-user ruanyf<br>四、Unit<br>4.1 含义<br>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<p>Unit 一共分成12种。</p>
<p>Service unit：系统服务<br>Target unit：多个 Unit 构成的一个组<br>Device Unit：硬件设备<br>Mount Unit：文件系统的挂载点<br>Automount Unit：自动挂载点<br>Path Unit：文件或路径<br>Scope Unit：不是由 Systemd 启动的外部进程<br>Slice Unit：进程组<br>Snapshot Unit：Systemd 快照，可以切回某个快照<br>Socket Unit：进程间通信的 socket<br>Swap Unit：swap 文件<br>Timer Unit：定时器<br>systemctl list-units命令可以查看当前系统的所有 Unit 。</p>
<h1 id="列出正在运行的-Unit"><a href="#列出正在运行的-Unit" class="headerlink" title="列出正在运行的 Unit"></a>列出正在运行的 Unit</h1><p>$ systemctl list-units</p>
<h1 id="列出所有Unit，包括没有找到配置文件的或者启动失败的"><a href="#列出所有Unit，包括没有找到配置文件的或者启动失败的" class="headerlink" title="列出所有Unit，包括没有找到配置文件的或者启动失败的"></a>列出所有Unit，包括没有找到配置文件的或者启动失败的</h1><p>$ systemctl list-units –all</p>
<h1 id="列出所有没有运行的-Unit"><a href="#列出所有没有运行的-Unit" class="headerlink" title="列出所有没有运行的 Unit"></a>列出所有没有运行的 Unit</h1><p>$ systemctl list-units –all –state=inactive</p>
<h1 id="列出所有加载失败的-Unit"><a href="#列出所有加载失败的-Unit" class="headerlink" title="列出所有加载失败的 Unit"></a>列出所有加载失败的 Unit</h1><p>$ systemctl list-units –failed</p>
<h1 id="列出所有正在运行的、类型为-service-的-Unit"><a href="#列出所有正在运行的、类型为-service-的-Unit" class="headerlink" title="列出所有正在运行的、类型为 service 的 Unit"></a>列出所有正在运行的、类型为 service 的 Unit</h1><p>$ systemctl list-units –type=service<br>4.2 Unit 的状态<br>systemctl status命令用于查看系统状态和单个 Unit 的状态。</p>
<h1 id="显示系统状态"><a href="#显示系统状态" class="headerlink" title="显示系统状态"></a>显示系统状态</h1><p>$ systemctl status</p>
<h1 id="显示单个-Unit-的状态"><a href="#显示单个-Unit-的状态" class="headerlink" title="显示单个 Unit 的状态"></a>显示单个 Unit 的状态</h1><p>$ sysystemctl status bluetooth.service</p>
<h1 id="显示远程主机的某个-Unit-的状态"><a href="#显示远程主机的某个-Unit-的状态" class="headerlink" title="显示远程主机的某个 Unit 的状态"></a>显示远程主机的某个 Unit 的状态</h1><p>$ systemctl -H <a href="mailto:&#114;&#111;&#x6f;&#x74;&#x40;&#x72;&#104;&#101;&#108;&#x37;&#x2e;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#114;&#111;&#x6f;&#x74;&#x40;&#x72;&#104;&#101;&#108;&#x37;&#x2e;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a> status httpd.service<br>除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<h1 id="显示某个-Unit-是否正在运行"><a href="#显示某个-Unit-是否正在运行" class="headerlink" title="显示某个 Unit 是否正在运行"></a>显示某个 Unit 是否正在运行</h1><p>$ systemctl is-active application.service</p>
<h1 id="显示某个-Unit-是否处于启动失败状态"><a href="#显示某个-Unit-是否处于启动失败状态" class="headerlink" title="显示某个 Unit 是否处于启动失败状态"></a>显示某个 Unit 是否处于启动失败状态</h1><p>$ systemctl is-failed application.service</p>
<h1 id="显示某个-Unit-服务是否建立了启动链接"><a href="#显示某个-Unit-服务是否建立了启动链接" class="headerlink" title="显示某个 Unit 服务是否建立了启动链接"></a>显示某个 Unit 服务是否建立了启动链接</h1><p>$ systemctl is-enabled application.service<br>4.3 Unit 管理<br>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<h1 id="立即启动一个服务"><a href="#立即启动一个服务" class="headerlink" title="立即启动一个服务"></a>立即启动一个服务</h1><p>$ sudo systemctl start apache.service</p>
<h1 id="立即停止一个服务"><a href="#立即停止一个服务" class="headerlink" title="立即停止一个服务"></a>立即停止一个服务</h1><p>$ sudo systemctl stop apache.service</p>
<h1 id="重启一个服务"><a href="#重启一个服务" class="headerlink" title="重启一个服务"></a>重启一个服务</h1><p>$ sudo systemctl restart apache.service</p>
<h1 id="杀死一个服务的所有子进程"><a href="#杀死一个服务的所有子进程" class="headerlink" title="杀死一个服务的所有子进程"></a>杀死一个服务的所有子进程</h1><p>$ sudo systemctl kill apache.service</p>
<h1 id="重新加载一个服务的配置文件"><a href="#重新加载一个服务的配置文件" class="headerlink" title="重新加载一个服务的配置文件"></a>重新加载一个服务的配置文件</h1><p>$ sudo systemctl reload apache.service</p>
<h1 id="重载所有修改过的配置文件"><a href="#重载所有修改过的配置文件" class="headerlink" title="重载所有修改过的配置文件"></a>重载所有修改过的配置文件</h1><p>$ sudo systemctl daemon-reload</p>
<h1 id="显示某个-Unit-的所有底层参数"><a href="#显示某个-Unit-的所有底层参数" class="headerlink" title="显示某个 Unit 的所有底层参数"></a>显示某个 Unit 的所有底层参数</h1><p>$ systemctl show httpd.service</p>
<h1 id="显示某个-Unit-的指定属性的值"><a href="#显示某个-Unit-的指定属性的值" class="headerlink" title="显示某个 Unit 的指定属性的值"></a>显示某个 Unit 的指定属性的值</h1><p>$ systemctl show -p CPUShares httpd.service</p>
<h1 id="设置某个-Unit-的指定属性"><a href="#设置某个-Unit-的指定属性" class="headerlink" title="设置某个 Unit 的指定属性"></a>设置某个 Unit 的指定属性</h1><p>$ sudo systemctl set-property httpd.service CPUShares=500<br>4.4 依赖关系<br>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p>systemctl list-dependencies命令列出一个 Unit 的所有依赖。</p>
<p>$ systemctl list-dependencies nginx.service<br>上面命令的输出结果之中，有些依赖Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用–all参数。</p>
<p>$ systemctl list-dependencies –all nginx.service<br>五、Unit 的配置文件<br>5.1 概述<br>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>
<p>systemctl enable命令用于在上面两个目录之间，建立符号链接关系。<br>$ sudo systemctl enable <a href="mailto:&#99;&#108;&#x61;&#x6d;&#x64;&#x40;&#x73;&#99;&#x61;&#x6e;&#46;&#115;&#x65;&#x72;&#118;&#x69;&#99;&#x65;">&#99;&#108;&#x61;&#x6d;&#x64;&#x40;&#x73;&#99;&#x61;&#x6e;&#46;&#115;&#x65;&#x72;&#118;&#x69;&#99;&#x65;</a></p>
<h1 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于</h1><p>$ sudo ln -s ‘/usr/lib/systemd/system/<a href="mailto:&#x63;&#108;&#x61;&#x6d;&#100;&#x40;&#x73;&#99;&#97;&#x6e;&#x2e;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;">&#x63;&#108;&#x61;&#x6d;&#100;&#x40;&#x73;&#99;&#97;&#x6e;&#x2e;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;</a>‘ ‘/etc/systemd/system/multi-user.target.wants/<a href="mailto:&#x63;&#x6c;&#97;&#x6d;&#x64;&#x40;&#115;&#x63;&#x61;&#110;&#x2e;&#x73;&#101;&#114;&#x76;&#x69;&#99;&#101;">&#x63;&#x6c;&#97;&#x6d;&#x64;&#x40;&#115;&#x63;&#x61;&#110;&#x2e;&#x73;&#101;&#114;&#x76;&#x69;&#99;&#101;</a>‘<br>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p>
<p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<p>$ sudo systemctl disable <a href="mailto:&#x63;&#108;&#x61;&#x6d;&#x64;&#64;&#115;&#99;&#x61;&#x6e;&#x2e;&#x73;&#x65;&#114;&#118;&#105;&#99;&#x65;">&#x63;&#108;&#x61;&#x6d;&#x64;&#64;&#115;&#99;&#x61;&#x6e;&#x2e;&#x73;&#x65;&#114;&#118;&#105;&#99;&#x65;</a><br>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p>
<p>5.2 配置文件的状态<br>systemctl list-unit-files命令用于列出所有配置文件。</p>
<h1 id="列出所有配置文件"><a href="#列出所有配置文件" class="headerlink" title="列出所有配置文件"></a>列出所有配置文件</h1><p>$ systemctl list-unit-files</p>
<h1 id="列出指定类型的配置文件"><a href="#列出指定类型的配置文件" class="headerlink" title="列出指定类型的配置文件"></a>列出指定类型的配置文件</h1><p>$ systemctl list-unit-files –type=service<br>这个命令会输出一个列表。</p>
<p>$ systemctl list-unit-files</p>
<p>UNIT FILE              STATE<br>chronyd.service        enabled<br>clamd@.service         static<br><a href="mailto:&#99;&#x6c;&#97;&#109;&#100;&#x40;&#115;&#99;&#97;&#x6e;&#x2e;&#x73;&#101;&#x72;&#x76;&#x69;&#99;&#101;">&#99;&#x6c;&#97;&#109;&#100;&#x40;&#115;&#99;&#97;&#x6e;&#x2e;&#x73;&#101;&#x72;&#x76;&#x69;&#99;&#101;</a>     disabled<br>这个列表显示每个配置文件的状态，一共有四种。</p>
<p>enabled：已建立启动链接<br>disabled：没建立启动链接<br>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖<br>masked：该配置文件被禁止建立启动链接<br>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p>
<p>$ systemctl status bluetooth.service<br>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<p>$ sudo systemctl daemon-reload<br>$ sudo systemctl restart httpd.service<br>5.3 配置文件的格式<br>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p>systemctl cat命令可以查看配置文件的内容。</p>
<p>$ systemctl cat atd.service</p>
<p>[Unit]<br>Description=ATD daemon</p>
<p>[Service]<br>Type=forking<br>ExecStart=/usr/bin/atd</p>
<p>[Install]<br>WantedBy=multi-user.target<br>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<p>[Section]<br>Directive1=value<br>Directive2=value<br>. . .<br>注意，键值对的等号两侧不能有空格。</p>
<p>5.4 配置文件的区块<br>[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<p>Description：简短描述<br>Documentation：文档地址<br>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败<br>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败<br>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行<br>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动<br>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动<br>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行<br>Condition…：当前 Unit 运行必须满足的条件，否则不会运行<br>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败<br>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<p>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中<br>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中<br>Alias：当前 Unit 可用于启动的别名<br>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit<br>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<p>Type：定义启动时的进程行为。它有以下几种值。<br>Type=simple：默认值，执行ExecStart指定的命令，启动主进程<br>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出<br>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行<br>Type=dbus：当前服务通过D-Bus启动<br>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行<br>Type=idle：若有其他任务执行完毕，当前服务才会运行<br>ExecStart：启动当前服务的命令<br>ExecStartPre：启动当前服务之前执行的命令<br>ExecStartPost：启动当前服务之后执行的命令<br>ExecReload：重启当前服务时执行的命令<br>ExecStop：停止当前服务时执行的命令<br>ExecStopPost：停止当其服务之后执行的命令<br>RestartSec：自动重启当前服务间隔的秒数<br>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog<br>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数<br>Environment：指定环境变量<br>Unit 配置文件的完整字段清单，请参考官方文档。</p>
<p>六、Target<br>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<h1 id="查看当前系统的所有-Target"><a href="#查看当前系统的所有-Target" class="headerlink" title="查看当前系统的所有 Target"></a>查看当前系统的所有 Target</h1><p>$ systemctl list-unit-files –type=target</p>
<h1 id="查看一个-Target-包含的所有-Unit"><a href="#查看一个-Target-包含的所有-Unit" class="headerlink" title="查看一个 Target 包含的所有 Unit"></a>查看一个 Target 包含的所有 Unit</h1><p>$ systemctl list-dependencies multi-user.target</p>
<h1 id="查看启动时的默认-Target"><a href="#查看启动时的默认-Target" class="headerlink" title="查看启动时的默认 Target"></a>查看启动时的默认 Target</h1><p>$ systemctl get-default</p>
<h1 id="设置启动时的默认-Target"><a href="#设置启动时的默认-Target" class="headerlink" title="设置启动时的默认 Target"></a>设置启动时的默认 Target</h1><p>$ sudo systemctl set-default multi-user.target</p>
<h1 id="切换-Target-时，默认不关闭前一个-Target-启动的进程，"><a href="#切换-Target-时，默认不关闭前一个-Target-启动的进程，" class="headerlink" title="切换 Target 时，默认不关闭前一个 Target 启动的进程，"></a>切换 Target 时，默认不关闭前一个 Target 启动的进程，</h1><h1 id="systemctl-isolate-命令改变这种行为，"><a href="#systemctl-isolate-命令改变这种行为，" class="headerlink" title="systemctl isolate 命令改变这种行为，"></a>systemctl isolate 命令改变这种行为，</h1><h1 id="关闭前一个-Target-里面所有不属于后一个-Target-的进程"><a href="#关闭前一个-Target-里面所有不属于后一个-Target-的进程" class="headerlink" title="关闭前一个 Target 里面所有不属于后一个 Target 的进程"></a>关闭前一个 Target 里面所有不属于后一个 Target 的进程</h1><p>$ sudo systemctl isolate multi-user.target<br>Target 与 传统 RunLevel 的对应关系如下。</p>
<p>Traditional runlevel      New target name     Symbolically linked to…</p>
<p>Runlevel 0           |    runlevel0.target -&gt; poweroff.target<br>Runlevel 1           |    runlevel1.target -&gt; rescue.target<br>Runlevel 2           |    runlevel2.target -&gt; multi-user.target<br>Runlevel 3           |    runlevel3.target -&gt; multi-user.target<br>Runlevel 4           |    runlevel4.target -&gt; multi-user.target<br>Runlevel 5           |    runlevel5.target -&gt; graphical.target<br>Runlevel 6           |    runlevel6.target -&gt; reboot.target<br>它与init进程的主要差别如下。</p>
<p>（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p>
<p>（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</p>
<p>（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</p>
<p>七、日志管理<br>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p>
<p>journalctl功能强大，用法非常多。</p>
<h1 id="查看所有日志（默认情况下-，只保存本次启动的日志）"><a href="#查看所有日志（默认情况下-，只保存本次启动的日志）" class="headerlink" title="查看所有日志（默认情况下 ，只保存本次启动的日志）"></a>查看所有日志（默认情况下 ，只保存本次启动的日志）</h1><p>$ sudo journalctl</p>
<h1 id="查看内核日志（不显示应用日志）"><a href="#查看内核日志（不显示应用日志）" class="headerlink" title="查看内核日志（不显示应用日志）"></a>查看内核日志（不显示应用日志）</h1><p>$ sudo journalctl -k</p>
<h1 id="查看系统本次启动的日志"><a href="#查看系统本次启动的日志" class="headerlink" title="查看系统本次启动的日志"></a>查看系统本次启动的日志</h1><p>$ sudo journalctl -b<br>$ sudo journalctl -b -0</p>
<h1 id="查看上一次启动的日志（需更改设置）"><a href="#查看上一次启动的日志（需更改设置）" class="headerlink" title="查看上一次启动的日志（需更改设置）"></a>查看上一次启动的日志（需更改设置）</h1><p>$ sudo journalctl -b -1</p>
<h1 id="查看指定时间的日志"><a href="#查看指定时间的日志" class="headerlink" title="查看指定时间的日志"></a>查看指定时间的日志</h1><p>$ sudo journalctl –since=”2012-10-30 18:17:16”<br>$ sudo journalctl –since “20 min ago”<br>$ sudo journalctl –since yesterday<br>$ sudo journalctl –since “2015-01-10” –until “2015-01-11 03:00”<br>$ sudo journalctl –since 09:00 –until “1 hour ago”</p>
<h1 id="显示尾部的最新10行日志"><a href="#显示尾部的最新10行日志" class="headerlink" title="显示尾部的最新10行日志"></a>显示尾部的最新10行日志</h1><p>$ sudo journalctl -n</p>
<h1 id="显示尾部指定行数的日志"><a href="#显示尾部指定行数的日志" class="headerlink" title="显示尾部指定行数的日志"></a>显示尾部指定行数的日志</h1><p>$ sudo journalctl -n 20</p>
<h1 id="实时滚动显示最新日志"><a href="#实时滚动显示最新日志" class="headerlink" title="实时滚动显示最新日志"></a>实时滚动显示最新日志</h1><p>$ sudo journalctl -f</p>
<h1 id="查看指定服务的日志"><a href="#查看指定服务的日志" class="headerlink" title="查看指定服务的日志"></a>查看指定服务的日志</h1><p>$ sudo journalctl /usr/lib/systemd/systemd</p>
<h1 id="查看指定进程的日志"><a href="#查看指定进程的日志" class="headerlink" title="查看指定进程的日志"></a>查看指定进程的日志</h1><p>$ sudo journalctl _PID=1</p>
<h1 id="查看某个路径的脚本的日志"><a href="#查看某个路径的脚本的日志" class="headerlink" title="查看某个路径的脚本的日志"></a>查看某个路径的脚本的日志</h1><p>$ sudo journalctl /usr/bin/bash</p>
<h1 id="查看指定用户的日志"><a href="#查看指定用户的日志" class="headerlink" title="查看指定用户的日志"></a>查看指定用户的日志</h1><p>$ sudo journalctl _UID=33 –since today</p>
<h1 id="查看某个-Unit-的日志"><a href="#查看某个-Unit-的日志" class="headerlink" title="查看某个 Unit 的日志"></a>查看某个 Unit 的日志</h1><p>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service –since today</p>
<h1 id="实时滚动显示某个-Unit-的最新日志"><a href="#实时滚动显示某个-Unit-的最新日志" class="headerlink" title="实时滚动显示某个 Unit 的最新日志"></a>实时滚动显示某个 Unit 的最新日志</h1><p>$ sudo journalctl -u nginx.service -f</p>
<h1 id="合并显示多个-Unit-的日志"><a href="#合并显示多个-Unit-的日志" class="headerlink" title="合并显示多个 Unit 的日志"></a>合并显示多个 Unit 的日志</h1><p>$ journalctl -u nginx.service -u php-fpm.service –since today</p>
<h1 id="查看指定优先级（及其以上级别）的日志，共有8级"><a href="#查看指定优先级（及其以上级别）的日志，共有8级" class="headerlink" title="查看指定优先级（及其以上级别）的日志，共有8级"></a>查看指定优先级（及其以上级别）的日志，共有8级</h1><h1 id="0-emerg"><a href="#0-emerg" class="headerlink" title="0: emerg"></a>0: emerg</h1><h1 id="1-alert"><a href="#1-alert" class="headerlink" title="1: alert"></a>1: alert</h1><h1 id="2-crit"><a href="#2-crit" class="headerlink" title="2: crit"></a>2: crit</h1><h1 id="3-err"><a href="#3-err" class="headerlink" title="3: err"></a>3: err</h1><h1 id="4-warning"><a href="#4-warning" class="headerlink" title="4: warning"></a>4: warning</h1><h1 id="5-notice"><a href="#5-notice" class="headerlink" title="5: notice"></a>5: notice</h1><h1 id="6-info"><a href="#6-info" class="headerlink" title="6: info"></a>6: info</h1><h1 id="7-debug"><a href="#7-debug" class="headerlink" title="7: debug"></a>7: debug</h1><p>$ sudo journalctl -p err -b</p>
<h1 id="日志默认分页输出，–no-pager-改为正常的标准输出"><a href="#日志默认分页输出，–no-pager-改为正常的标准输出" class="headerlink" title="日志默认分页输出，–no-pager 改为正常的标准输出"></a>日志默认分页输出，–no-pager 改为正常的标准输出</h1><p>$ sudo journalctl –no-pager</p>
<h1 id="以-JSON-格式（单行）输出"><a href="#以-JSON-格式（单行）输出" class="headerlink" title="以 JSON 格式（单行）输出"></a>以 JSON 格式（单行）输出</h1><p>$ sudo journalctl -b -u nginx.service -o json</p>
<h1 id="以-JSON-格式（多行）输出，可读性更好"><a href="#以-JSON-格式（多行）输出，可读性更好" class="headerlink" title="以 JSON 格式（多行）输出，可读性更好"></a>以 JSON 格式（多行）输出，可读性更好</h1><p>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty</p>
<h1 id="显示日志占据的硬盘空间"><a href="#显示日志占据的硬盘空间" class="headerlink" title="显示日志占据的硬盘空间"></a>显示日志占据的硬盘空间</h1><p>$ sudo journalctl –disk-usage</p>
<h1 id="指定日志文件占据的最大空间"><a href="#指定日志文件占据的最大空间" class="headerlink" title="指定日志文件占据的最大空间"></a>指定日志文件占据的最大空间</h1><p>$ sudo journalctl –vacuum-size=1G</p>
<h1 id="指定日志文件保存多久"><a href="#指定日志文件保存多久" class="headerlink" title="指定日志文件保存多久"></a>指定日志文件保存多久</h1><p>$ sudo journalctl –vacuum-time=1years</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday4</title>
    <url>/2021/11/06/linuxday4/</url>
    <content><![CDATA[<p>一。linux常用的日志文件文件名<br>1./var/log/boot.log 开机启动的时候系统内核会去检测和启动硬件，接下来开始启动各种内核支持的功能<br>2./var/log/cron 计划任务<br>3./var/log/dmesg 记录系统开机的时候内核检测过程所产生的相关信息<br>4./var/log/lastlog 可以记录系统上面所有账号最近一次登录系统时产生的各项信息<br>5./var/log/maillog 或/var/log/mail/* 记录邮件往来的信息<br><em>重要</em>6./var/log/messages 几乎系统发生的错误信息（重要的信息）都会记到这个文件上。<br><em>重要</em>7./var/log/secure 只要牵涉到【密码和账户】的软件，那么都会记录到这个文件上<br> 8./var/log/wtmp ,/var/log/faillog 记录正确登录系统的账户信息与错误登记用户的账户信息<br>二。日志的一般格式<br><em>事件发生的日期和时间<br><em>发生此事件的主机名<br><em>开启此事件的服务名称或命令或函数名称<br><em>该信息的实际内容<br>列cat  /var/log/secure<br>cat  /var/log/messages<br>三。rsyslog.service<br>1.记录日志文件的服务<br>Linux的日志文件主要由rsyslog.service<br>2.配置文件/etc/rsyslog.conf<br>(1)什么服务（2）什么等级信息（3）需要被记录在哪里<br>rsyslogd主要通过linux内核提供的syslog相关规范来设置数据的分类<br>3.信息等级<br>基本上,在0-6的等级之间，等级数值越高越没事，等级靠近0则代表系统出现致命的问题。<br>4.rsyslog.conf语法练习<br>列:mail.info  /var/log/maillog<br>5.rsyslog.conf内容<br>vim  /etc/rsyslog.conf<br>#kern.</em>                                                    /dev/console<br><em>.info;mail.none;authpriv.none;cron.none      /var/log/messages<br>authpriv.</em>                                    /var/log/secure<br>mail.</em>                                        /var/log/maillog<br>cron.</em>                                        /var/log/cron<br><em>.emerg                                       *<br>uucp,news.crit                                /var/log/spooler<br>local7.</em>                                      /var/log/boot.log<br>6.日志文件的安全性设置<br>如果只能增加，不能删除 可以用lsattr 和chattr这俩个程序<br>列：chattr +a  /var/log/admin.log   lsattr 显示文件的隐藏属性   chattr  配置文件隐藏属性。<br>7.日志文件服务器的设置<br>服务端：<br>vim /etc/rsyslog.conf<br>然后重启服务和查看rsyslogd<br>systemctl restart  rsyslogd.service<br>netstat  -ltnp  |  grep  syslog<br>客户端：<br>vim /etc/rsyslog.conf<br><em>.</em>   @@192.168.1.100   (服务端的ip)<br>#</em>.*   @192.168.1.100 #若用udp传输，设置就变成这样</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday5</title>
    <url>/2021/11/07/linuxday5/</url>
    <content><![CDATA[<p>一.日志文件的轮循（logrotate）<br>配置文件：/etc/logrotate.conf<br>                /etc/logrotate.d/<br>执行logrotate<br>logrotate  -v /etc/logrotate.conf<br>强制进行logrotate<br>logrotate  -vf  /etc/logrotate.conf</p>
<p>二.journalctl 查看登录信息<br>Journald使用journalctl工具读取日志  journalctl<br>2查看  2017-05-27 09:37:00 到  2017-05-27 10:47:00 之间日志<br> journalctl –since “2017-05-27 09:37:00” –until “2017-05-27 10:47:00”<br>3.查看重启的记录：journalctl –list-boots<br>4.查看上一次启动以来的日志，根据上面的记录，也可以选择其他重启以来的日志： journalctl -b -1<br>5.查看最新的日志： journalctl -r<br>6.查看严重等级为错误的日志 journalctl -p err<br>7.查看指定应用日志：journalctl -t sshd<br>8.显示最近前几行的日志 如：-n  5<br>9.-f 持续显示joural日志内容</p>
<p>三.logger命令的应用<br>使用 logger 工具，可以直接将信息传入到Journald中，-p 参数指定服务名称，和日志级别<br>logger -p user.info “log test with logger”</p>
<p>四.保存journal的方式<br>mkdir  /var/log/journal<br>chown  root:systemd-journal  /var/log/journal<br>chmod  2775  /var/log/journal<br>systemctl  restart    systemd-journald.service</p>
<p>五.分析日志文件<br>centos默认提供的logwatch<br>他会每天分析一次日志文件，然后通过email 的格式寄给root<br>1.安装<br>yum install /mnt/dvd/Packages/perl-5.*.rpm</p>
]]></content>
  </entry>
  <entry>
    <title>linuxday6 启动流程，模块管理与loader</title>
    <url>/2021/11/08/linuxday6/</url>
    <content><![CDATA[<p>一.linux的启动流程分析<br>1.启动流程：（1）加载bios的硬件信息，<br>（2）读取并执行第一个启动设备内mbr的启动引导程序，<br>（3）根据启动引导加载与加载驱动程序<br>（4）硬件驱动成功后，kernel会调用systemd程序，并以defult.target程序启动<br>2.boot loader<br>初始化开发板上主要硬件（时钟，内存，硬盘），把操作系统从硬盘拷贝到内存，然后让CPU跳到内存中执行操作系统<br>loader的最主要功能是要识别操作系统的文件格式，并据以加载内核到内存去执行<br>boot loader<br>提供选项：（1）用户可以选择不同的启动选项，这也是多重引导的重要功能<br>（2）加载内核文件<br>（3）转交其他loader<br>3. Kernel（初始化）<br>我们知道kernel是完成探索硬件及加载硬件驱动程序，并以读写的方式挂载根文件系统。<br>kernel初始化：探测硬件-&gt;加载驱动（initrd)-&gt;挂载根文件系统-&gt;rootfs(/sbin/init)<br>4.initrd功能介绍<br>       其实说白了initrd就是一个虚拟的文件系统，里面有/、lib、bin、sbin、usr、proc、sys、var、dev、boot等一些目录<br>5./sbin/init(/etc/inittab)<br>/sbin/init启动会用到/etc/inittab所定义的条目，如：默认登陆级别id:3:initdefault:(这里就是默认启动3级别）<br>下面就来说下/etc/inittab所工作那些内容：<br>/etc/inittab<br>默认运行级别<br>   0：halt系统停机状态<br>   1: single user mode(单用户维护模式)<br>   2：multi user mode, without NFS(多用户，不支持NFS功能）<br>   3: multi user mode, text mode（字符界面）完全的多用户状态(有NFS)，登陆后进入控制台命令行模式<br>   4：reserved （系统保留）系统未使用<br>   5: multi user mode, graphic mode  （图形化界面）：X11控制台，登陆后进入图形GUI模式<br>   6: reboot   （重启）<br>6.init执行/etc/rc.d/rc.local<br>init执行中断机模拟程序mingetty来启动login进程，最后等待用户登录<br>7.启动过程会用到的主要配置文件</p>
<p>基本上，systemd有自己的配置文件处理方式，读取位于/etc/sysconfig下面的环境配置文件<br>关于模块：/etc/modprobe.d/<em>.conf及/etc/modules-load.d/</em>.conf</p>
<p>.  /etc/sysconfig/*<br>authconfig   此文件中的内容为主机在进行认证时使用<br>cpupower  启动cpupower.service服务时会读取这个配置文件<br>二.处理忘记密码<br>1.先按e进入编译模式<br>2.在编译模式里添加rd.break  ctrl+x执行<br>3.进入到另外一个模式 ，然后检查mount  ，并添加权限 mount   -o   remount ，rw /sysroot<br>4.chroot  /sysroot<br>然后改密码<br>然后重启<br>tmux</p>
<p>cron计划任务<br>很多时候，我们计划任务需要精确到秒来执行，根据以下方法，可以很容易地以秒执行任务。<br>以下方法将每10秒执行一次</p>
<h1 id="crontab-e"><a href="#crontab-e" class="headerlink" title="crontab -e"></a>crontab -e</h1><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>/bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 10; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 20; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 30; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 40; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>sleep 50; /bin/date &gt;&gt;/tmp/date.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
