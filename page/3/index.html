<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-linux磁盘和vim" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/26/linux%E7%A3%81%E7%9B%98%E5%92%8Cvim/" class="article-date">
  <time class="dt-published" datetime="2022-01-26T12:34:41.000Z" itemprop="datePublished">2022-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/26/linux%E7%A3%81%E7%9B%98%E5%92%8Cvim/">linux磁盘和vim</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一。磁盘<br>在linux下，需要使用一块硬盘。</p>
<p>需要进行以下四步：</p>
<p>识别硬盘—–分区规划—-格式化—-挂载<br>步骤一：分区规划</p>
<p>MBR模式分区</p>
<p>要求：a.最多有四个区。一般分为1～4个主分区或者0～3个主分区+1个扩展分区（n个逻辑分区）</p>
<pre><code>      b.最大支持容量为2.2TB的磁盘

      c.扩展分区不能格式化
</code></pre>
<p>1.ext2<br>linux的正统文件系统为ext2<br>blkid   这个命令可以显示出目前系统被格式化的设备。<br>dumpe2fs  查询ext系统超级区块信息的命令</p>
<p>2.inode<br>（1）文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区sector，每个扇区存储512字节。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块block。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个sector组成一个block。<br>（2）文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做inode，中文译名为索引节点，也叫i节点。因此，一个文件必须占用一个inode，但至少占用一个block。<br>（3）inode包含很多的文件元信息，但不包含文件名，例如：字节数、属主UserID、属组GroupID、读写执行权限、时间戳等。</p>
<p>而文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用inode号码识别文件。对于系统来说文件名只是inode号码便于识别的别称。<br>（4）ls  -i 可以列出文件的inode<br>（5）df -i查看硬盘分区的inode总数和已使用情况<br>3.xfs文件系统<br>（1）从centos 7开始，默认的文件系统从ext4变成了xfs<br>（2）df -T  可以查看挂载点<br>4.磁盘与目录的容量<br>（1）df 列出文件系统的整体磁盘使用量   df -h  df -aT<br>（2）du 查看文件系统的磁盘的使用量<br>5.磁盘分区<br>（1）lsblk  列出系统上所有的磁盘列表<br>       parted  列出磁盘的分区类型和分区信息<br>（2）gdisk/fdisk<br>《1》    采用默认的 msdos 分区模式<br>fdisk分区工具用来建立msdos分区方案，其交互模式中的主要指令如下：<br>•    m：列出指令帮助<br>•    p：查看当前的分区表信息<br>•    n：新建分区<br>•    d：删除分区<br>•    q：放弃分区更改并退出<br>•    w：保存对分区表所做的更改<br>《2》mkfs.ext4   格式化成ext4类型  和 mkfs.xfs  格式化成xfs类型<br>《3》配置开机自动挂载<br>vim  /etc/fstab</p>
<p>/dev/sdb2       /mnt/part2      ext4    defaults        0 0<br>《4》创建挂载点，并验证挂载配置<br>mkdir  /mnt/part2                 //创建挂载点</p>
<p> mount  -a                         //挂载fstab中的可用设备</p>
<p> df  -hT  /mnt/part2/                 //检查文档所在的文件系统及设备</p>
<p>Filesystem      Type  Size  Used Avail Use% Mounted on<br>/dev/sdb2      ext4  1.9G  5.9M  1.8G   1% /mnt/part2<br>（3）分区扩展swap<br>mkswap  /dev/sdd1  格式化成swap文件系统<br>swapon   -s  未启用之前，查看swap空间组成成员<br>swapon  /dev/sdd1  启用/dev/sdd1交换分区<br>（4）文件扩展swap空间<br>Swap空间来源于硬盘空间，这个思路不变。我们可以换种方式，来扩展Swap空间。就是可以创建一个大的文件，文件占用的是磁盘空间，再将这个文件格式化使用。这个方式是可行的，但难点在于文件怎么生成呢？我们可以用dd这条命令。<br>例如 dd if=/dev/zero of=/opt/swap.db bs=1M count=2048 ，相关说明如下：<br>•    dd：为命令字。<br>•    if：读取数据的来源是哪，而/dev/zero是一个特殊的设备它可以产生无限的数据，常用来与dd命令搭配使用。<br>•    of：将数据写入到哪里去，可以是其他设备，也可以是指定路径下的一个文件名。<br>•    bs：每次读取和写入数据的大小为1M。<br>•    count：为读取和写入的次数为2048次。<br>使用dd命令创建一个大小为2048MB的交换文件，放在/opt/swap.db<br>将swap.db文件格式化成Swap文件系统  mkswap /opt/swap.db<br>启用swap.db文件，查看Swap空间大小 swapon /opt/swap.db   swapon -s<br>停用swap.db文件，查看Swap空间大小  swapoff /opt/swap.db      swapon -s<br>二。vim<br>命令模式常用操作：<br>•    1G 或 gg ，跳转到文件的首行<br>•    G ，跳转到文件的末尾行<br>•    yy、#yy ，复制光标处的一行、#行<br>•    p、P ，粘贴到光标处之后、之前<br>•    x 或 Delete键 ，删除光标处的单个字符<br>•    dd、#dd ，删除光标处的一行、#行<br>•    d^、d$ ，从光标处之前删除至行首/行尾<br>•    /word 向后查找字符串“word”，再按n/N跳至后/前一个结果<br>•    u ，撤销最近的一次操作<br>•    U ，撤销对当前行的所有修改<br>•    Ctrl + r 取消前一次撤销操作<br>•    ZZ 保存修改并退出<br>末行模式常用操作：<br>•    :s/old/new ，替换当前行第一个“old”<br>•    :s/old/new/g ，替换当前行所有的“old”<br>•    :n,m s/old/new/g ，替换第n-m行所有的“old”<br>•    :% s/old/new/g ，替换文件内所有的“old”<br>•    :w /root/newfile ，另存为其它文件<br>•    :r /etc/filesystems ，读入其他文件内容<br>•    :set nu|nonu ，显示/不显示行号<br>•    :set ai|noai ，启用/关闭自动缩进</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/26/linux%E7%A3%81%E7%9B%98%E5%92%8Cvim/" data-id="cl9bbmgix000lmwuqbvmn867l" data-title="linux磁盘和vim" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python笔记day02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/23/python%E7%AC%94%E8%AE%B0day02/" class="article-date">
  <time class="dt-published" datetime="2022-01-23T12:44:16.000Z" itemprop="datePublished">2022-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/23/python%E7%AC%94%E8%AE%B0day02/">python笔记day02</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Python变量</strong><br> 变量名约定：<br>（1）. 第一个字符只能是大小写字母或者下划线<br>（2）. 后续字符只能是大小写字母或者数字或者下划线<br>（3）. 区分大小写</p>
<p>Python是动态类型语言，既不需要预先声明变量的类型<br><strong>变量的定义：</strong><br>一、推荐采用的全名方法</p>
<ol>
<li>变量名全部采用的小写的字母</li>
<li>简短、有意义</li>
<li>多个单词间用下划线分隔</li>
<li>变量名用名词，函数名要用谓词（动词+名词）</li>
<li>类名采用驼峰形式<br>二、变量的赋值</li>
<li>变量的类型和值在赋值那一刻被初始化</li>
<li>变量赋通等号来执行</li>
<li>Python也支持增量赋值<br>三、运算符</li>
<li>标准算术运算符</li>
</ol>
<ul>
<li><ul>
<li><ul>
<li> /  //   %   **</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>比较运算符<br>&lt;  &lt;=   &gt;   &gt;=   ==    !=</li>
<li>逻辑运算符<br>And    not   or  </li>
</ol>
<p>基本数字类型：</p>
<ol>
<li>int：有符号整数</li>
<li>bool：布尔值</li>
</ol>
<p>-True：1<br>-False：0<br>3. float：浮点数<br>4. Complex：复数<br>数字表示方式：</p>
<ol>
<li>Python默认以十进制数显示</li>
<li>数字以0o或者0O开头表示为8进制数</li>
<li>数字以0x或者0X开头表示为16进制数</li>
<li>数字以0b或者0B开头表示为2进制数<br>定义字符串：</li>
<li>Python中字符串被定义为引号之间的字符集合</li>
<li>Python支持使用成对的单引号或者双引号</li>
<li>无论单引号，还是双引号，表示的意义相同</li>
<li>Python还支持三引号（三个来连续的单引号或者双引号），可以用来高喊特殊字符</li>
<li>Python不区分字符和字符串<br>字符串的切割：</li>
<li>使用索引运算符[]和切片运算符[:]可得到字符串</li>
<li>第一个字符的索引是0，最后一个字符的索引是-1</li>
<li>子字符串包含切片中的起始下标，但不包含结束下标。<br>字符串连接的操作：</li>
<li>使用+号可以将多个字符串拼接在一起</li>
<li>使用*号可以将一个字符串重复多次<br>定义列表：</li>
<li>可以将列表当成普通的“数组”，它能保存任意数量任已类型的python对象</li>
<li>像字符串一样，列表也支持下表和切片操作</li>
<li>列表中的项目可以改变<br>在2.7版本里输入是raw_input  3.0版本是input<br>linux系统升级python版本<br>(1)查看python原来的版本<br>python -V<br>（2）下载python安装包并解压<br>wget <a target="_blank" rel="noopener" href="https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz">https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz</a><br>tar -xf Python-3.7.2.tgz<br>mv Python-3.7.2 python3<br>（3）进入解压的python内进行配置并安装<br>cd python3<br>./configure –prefix=/usr/local/python3 --with-ssl --enable-optimizations<br>make<br>make install<br>（4）安装完成后修改默认的python版本<br>cd /usr/bin<br>mv python python.bak<br>ln -s /usr/local/python3/bin/python3 /usr/bin/python   软连接<br>（5）安装完成<br>python -V<h1 id="输出结果：Python-3-7-2"><a href="#输出结果：Python-3-7-2" class="headerlink" title="输出结果：Python 3.7.2"></a>输出结果：Python 3.7.2</h1>列如<br>给文件创建（硬链接），为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同<br>ln log2013.log ln2013</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/23/python%E7%AC%94%E8%AE%B0day02/" data-id="cl9bbmgj6000zmwuqg7ax75no" data-title="python笔记day02" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python笔记day1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/21/python%E7%AC%94%E8%AE%B0day1/" class="article-date">
  <time class="dt-published" datetime="2022-01-21T12:28:09.000Z" itemprop="datePublished">2022-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/21/python%E7%AC%94%E8%AE%B0day1/">python笔记day1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Python语法结构：</p>
<ol>
<li>   python代码块通过缩进对齐表示代码逻辑而不是使用大括号</li>
<li>   缩进表达一个语句属于哪一个代码块</li>
<li>   缩进风格<br>(1) 1或2：可能不够，很难确定代码语句属于哪一个代码块<br>(2) 8至10：可能太多，如果代码内嵌的层次太多，就会使得待py代码很难阅读<br>(3) 4个空格：非常流行，范。罗萨姆支持的风格</li>
<li>   缩进相同的一组语句结构一个代码块，称之为代码组</li>
<li>   首行以关键字开始，以冒号：结束，该行之后的以行或者多行代码构成代码组（细节注意）</li>
<li>   如果代码只有一行，可以将其直接写在冒号后面，但是这样的写法可读性差，不推荐<br>注释及续行：</li>
<li>首要说明：尽管Python是可读性最好的语言之一，这并不意味这程序员在代码中就不写注释。</li>
<li>和很多Unix脚本类似，Python注释语句从#字符开始</li>
<li>注释可以子啊以行的任何地方开始，解释器会忽略该行#之后的所有内容</li>
<li>一行过长的语句可以使用反斜杠\分解成几行<br>同行多个语句： 【了解】</li>
<li>分号；允许你将多个语句写在同一行上</li>
<li>但是这些语句不能在这行开始一个新的代码块</li>
<li>因为可读对变差，所以不推荐使用<br>简单命令<br>输出（打印）print<br>print（’hello world!’）<br>print (‘hello’+’world!’)<br>print (‘hello’,’world!’)<br>print(‘hello’,’world!’,sep=’***’,end=’’)<br>输入 input<br>num=input（“number：”）<br>进入python 直接输入python<br>运行python文件是列如：python log.py<br>退出exit（）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/21/python%E7%AC%94%E8%AE%B0day1/" data-id="cl9bbmgj60010mwuqdx0n5mz9" data-title="python笔记day1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web安全笔记day03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/20/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day03/" class="article-date">
  <time class="dt-published" datetime="2022-01-20T12:35:48.000Z" itemprop="datePublished">2022-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/20/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day03/">web安全笔记day03</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>信息收集：<br>信息收集是指通过各种方式获取所需要的信息，以便我们在后续的渗透过程更好的进行。因为只有我们掌握了目标网站或目标 主机足够多的信息之后，我们才能更好地对其进行漏洞检测。<br>主动信息收集<br>    优点: 精准、灵活<br>    缺点: 与目标直接交互，暴露自身<br>被动信息收集<br>    优点: 无交互、可以统一统计、工具化爬取<br>    缺点: 数据具有时效性，不精准，误差高<br>主要收集的内容：<br>    1. 服务器的配置信息，banner指纹<br>    2. 只要和网站关联的信息都要尽量去收集，包括网站注册人，网站关联公司，网站系统架构，网站关联子域名，网站开放服务以及开放端口等<br>谷歌黑语法<br>intitle:关键字  <del>搜索网页标题中含有关键字的网页</del><br>intext:关键字   <del>搜索站点正文中含有关键字的网页</del><br>inurl:关键字    <del>搜索URL中包含有指定字符串的网址</del><br>site:域名       <del>在指定站点内查找相关的内容</del><br>filetype:文件   <del>搜索指定类型的文件</del><br>github-dorks    <a target="_blank" rel="noopener" href="https://github.com/techgaun/github-dorks">https://github.com/techgaun/github-dorks</a><br>github-dork.py是一个简单的python工具，可以搜索您的存储库或您的组织/用户存储库。它目前不是一个完美的工具，但提供了基本功能，可以针对文本文件中指定的dorks自动搜索存储库。<br>子域名信息收集<br>子域名是某个主域的二级域名或者多级域名或者其他域名，在防御措施严密的情况下无法直接拿下主域，那么可以用迂回战术拿下子域名，然后无限靠近主域。一台服务器上有很多个站点，这些站点之间没有必然的联系，是相互独立的，使用的是不同的域名（甚至端口都不同），但是它们却共存在一台服务器上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/20/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day03/" data-id="cl9bbmgjg001cmwuq6dmv392s" data-title="web安全笔记day03" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-nginxday1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/nginxday1/" class="article-date">
  <time class="dt-published" datetime="2022-01-19T10:32:07.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/nginxday1/">nginxday1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1.安装nginx<br>1）使用源码包安装nginx软件包</p>
<ol>
<li>   [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        #安装依赖包</li>
<li>   [root@proxy ~]# useradd -s /sbin/nologin nginx</li>
<li>   [root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz</li>
<li>   [root@proxy ~]# cd  nginx-1.12.2</li>
<li>   [root@proxy nginx-1.12.2]# ./configure   \</li>
<li>   –prefix=/usr/local/nginx   \                #指定安装路径</li>
<li>   –user=nginx   \                            #指定用户</li>
<li>   –group=nginx  \                            #指定组</li>
<li>   –with-http_ssl_module                    #开启SSL加密功能</li>
<li></li>
<li>   [root@proxy nginx-1.12.2]# make &amp;&amp; make install     #编译并安装<br>2）nginx命令的用法</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx                    #启动服务</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            #关闭服务</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        #重新加载配置文件</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -V                #查看软件信息<br>netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：</li>
</ol>
<p>-a显示所有端口的信息<br>-n以数字格式显示端口号<br>-t显示TCP连接的端口<br>-u显示UDP连接的端口<br>-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口<br>-p显示监听端口的服务名称是什么（也就是程序名称）<br>如果80端口被占用需要使用kill  -9 杀死进程。<br>nginx服务默认通过TCP 80端口监听客户端请求：</p>
<ol>
<li>   root@proxy ~]# netstat  -anptu  |  grep nginx</li>
<li>   tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx<br>3）测试首页文件<br>Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：</li>
<li>   [root@client ~]# curl <a target="_blank" rel="noopener" href="http://192.168.4.5/">http://192.168.4.5</a><br>步骤二：客户端访问测试<br>1）分别使用浏览器和命令行工具curl测试服务器页面<br>如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。</li>
<li>   [root@client ~]# firefox <a target="_blank" rel="noopener" href="http://192.168.4.5/">http://192.168.4.5</a></li>
<li>[root@client ~]# curl <a target="_blank" rel="noopener" href="http://192.168.4.5/">http://192.168.4.5</a><br>案例2：用户认证</li>
<li>1 问题<br>沿用练习一，通过调整Nginx服务端配置，实现以下目标：</li>
<li>   访问Web页面需要进行用户认证</li>
<li>   用户名为：tom，密码为：123456</li>
<li>2 方案<br>通过Nginx实现Web页面的认证，需要修改Nginx配置文件，在配置文件中添加auth语句实现用户认证。最后使用htpasswd命令创建用户及密码即可。效果如图-2所示。</li>
</ol>
<p>图-2<br>2.3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：修改Nginx配置文件<br>1）修改/usr/local/nginx/conf/nginx.conf</p>
<ol>
<li>   [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf</li>
<li>   .. ..</li>
<li>   server {</li>
<li><pre><code>       listen       80;
</code></pre>
</li>
<li><pre><code>       server_name  localhost;
</code></pre>
</li>
<li><pre><code>       auth_basic &quot;Input Password:&quot;;                        //认证提示符信息
</code></pre>
</li>
<li><pre><code>       auth_basic_user_file  &quot;/usr/local/nginx/pass&quot;;        //认证的密码文件
</code></pre>
</li>
<li><pre><code>       location / &#123;
</code></pre>
</li>
<li><pre><code>           root   html;
</code></pre>
</li>
<li><pre><code>           index  index.html index.htm;
</code></pre>
</li>
<li><pre><code>       &#125;
</code></pre>
</li>
<li><pre><code> &#125;
</code></pre>
2）生成密码文件，创建用户及密码<br>使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。</li>
<li>   [root@proxy ~]# yum -y install  httpd-tools</li>
<li>   [root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件</li>
<li>   New password: </li>
<li>   Re-type new password: </li>
<li>   Adding password for user tom</li>
<li>   [root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项</li>
<li>   New password: </li>
<li>   Re-type new password: </li>
<li>   Adding password for user jerry</li>
<li>   [root@proxy ~]# cat /usr/local/nginx/pass<br>3）重新加载配置</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    </li>
<li>   #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：</li>
<li>   #[error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)<br>步骤二：客户端测试<br>1）登录192.168.4.10客户端主机进行测试<br>如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。<br>或者直接使用真实主机的火狐也可以。</li>
<li>   [root@client ~]# firefox <a target="_blank" rel="noopener" href="http://192.168.4.5/">http://192.168.4.5</a>                    //输入密码后可以访问<br>3 案例3：基于域名的虚拟主机</li>
<li>1 问题<br>沿用练习二，配置基于域名的虚拟主机，实现以下目标：</li>
<li>   实现两个基于域名的虚拟主机，域名分别为<a target="_blank" rel="noopener" href="http://www.a.com和www.b.com/">www.a.com和www.b.com</a></li>
<li>   对域名为<a target="_blank" rel="noopener" href="http://www.a.com的站点进行用户认证,用户名称为tom,密码为123456/">www.a.com的站点进行用户认证，用户名称为tom，密码为123456</a></li>
<li>2 方案<br>修改Nginx配置文件，添加server容器实现虚拟主机功能；对于需要进行用户认证的虚拟主机添加auth认证语句。<br>虚拟主机一般可用分为：基于域名、基于IP和基于端口的虚拟主机。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：修改配置文件<br>1）修改Nginx服务配置，添加相关虚拟主机配置如下</li>
<li>   [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf</li>
<li>   .. ..</li>
<li>   server {</li>
<li><pre><code>       listen       80;                                      //端口
</code></pre>
</li>
<li><pre><code>       server_name  www.a.com;                                //域名
</code></pre>
</li>
<li>   auth_basic “Input Password:”;                        //认证提示符</li>
<li><pre><code>       auth_basic_user_file &quot;/usr/local/nginx/pass&quot;;        //认证密码文件
</code></pre>
</li>
<li>   location / {</li>
<li><pre><code>           root   html;                                    //指定网站根路径
</code></pre>
</li>
<li><pre><code>           index  index.html index.htm;
</code></pre>
</li>
<li><pre><code>      &#125;
</code></pre>
</li>
<li></li>
<li>   }</li>
<li>   … …</li>
<li></li>
<li><pre><code>   server &#123;
</code></pre>
</li>
<li><pre><code>       listen  80;                                        //端口
</code></pre>
</li>
<li><pre><code>       server_name  www.b.com;                                //域名
</code></pre>
</li>
<li>   location / { </li>
<li>   root   www;                                 //指定网站根路径</li>
<li>   index  index.html index.htm;</li>
<li>   }</li>
<li>   }<br>2）创建网站根目录及对应首页文件</li>
<li>   [root@proxy ~]# mkdir /usr/local/nginx/www</li>
<li>   [root@proxy ~]# echo “www” &gt; /usr/local/nginx/www/index.html<br>3）重新加载配置</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload</li>
<li>   #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：</li>
<li>   #[error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)<br>步骤二：客户端测试<br>1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析</li>
<li><pre><code>[root@client ~]# vim /etc/hosts
</code></pre>
</li>
<li>   192.168.4.5    <a target="_blank" rel="noopener" href="http://www.a.com/">www.a.com</a>  <a target="_blank" rel="noopener" href="http://www.b.com/">www.b.com</a><br>2）登录192.168.4.10客户端主机进行测试<br>注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。</li>
<li>   [root@client ~]# firefox <a target="_blank" rel="noopener" href="http://www.a.com/">http://www.a.com</a>            //输入密码后可以访问</li>
<li>   [root@client ~]# firefox <a target="_blank" rel="noopener" href="http://www.b.com/">http://www.b.com</a>            //直接访问<br>提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。<br>步骤三：扩展课外实验：其他类型的虚拟主机</li>
<li>基于端口的虚拟主机（参考模板）</li>
<li>   server {</li>
<li><pre><code>       listen       8080;                        //端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;          //域名
</code></pre>
</li>
<li><pre><code>       ......
</code></pre>
</li>
<li>   }</li>
<li><pre><code>   server &#123;
</code></pre>
</li>
<li><pre><code>       listen       8000;                         //端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;           //域名
</code></pre>
</li>
<li><pre><code>     .......
</code></pre>
</li>
<li>   }</li>
<li>基于IP的虚拟主机（参考模板）</li>
<li>   server {</li>
<li><pre><code>       listen       192.168.0.1:80;              //IP地址与端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;          //域名
</code></pre>
</li>
<li><pre><code> ... ...
</code></pre>
</li>
<li>   }</li>
<li><pre><code>   server &#123;
</code></pre>
</li>
<li><pre><code>       listen       192.168.0.2:80;             //IP地址与端口
</code></pre>
</li>
<li><pre><code>       server_name  web1.example.com;
</code></pre>
</li>
<li>   … …</li>
<li>   }<br>4 案例4：SSL虚拟主机</li>
<li>1 问题<br>沿用练习三，配置基于加密网站的虚拟主机，实现以下目标：</li>
<li>   域名为<a target="_blank" rel="noopener" href="http://www.c.com/">www.c.com</a></li>
<li>   该站点通过https访问</li>
<li>   通过私钥、证书对该站点所有数据加密</li>
<li>2 方案<br>源码安装Nginx时必须使用–with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。<br>加密算法一般分为对称算法、非对称算法、信息摘要。<br>对称算法有：AES、DES，主要应用在单机数据加密。<br>非对称算法有：RSA、DSA，主要应用在网络数据加密。<br>信息摘要：MD5、sha256，主要应用在数据完整性校验。</li>
<li>3 步骤<br>实现此案例需要按照如下步骤进行。<br>步骤一：配置SSL虚拟主机<br>1）生成私钥与证书</li>
<li>   [root@proxy ~]# cd /usr/local/nginx/conf</li>
<li>   [root@proxy ~]# openssl genrsa &gt; cert.key                            //生成私钥</li>
<li>   [root@proxy ~]# openssl req -new -x509 -key cert.key &gt; cert.pem      //生成证书<br>2）修改Nginx配置文件，设置加密网站的虚拟主机</li>
<li>   [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf</li>
<li>   … …    </li>
<li>   server {</li>
<li><pre><code>       listen       443 ssl;
</code></pre>
</li>
<li><pre><code>       server_name            www.c.com;
</code></pre>
</li>
<li><pre><code>       ssl_certificate      cert.pem;         #这里是证书文件
</code></pre>
</li>
<li><pre><code>       ssl_certificate_key  cert.key;         #这里是私钥文件
</code></pre>
</li>
<li></li>
<li><pre><code>       ssl_session_cache    shared:SSL:1m;
</code></pre>
</li>
<li><pre><code>       ssl_session_timeout  5m;
</code></pre>
</li>
<li></li>
<li><pre><code>       ssl_ciphers  HIGH:!aNULL:!MD5;
</code></pre>
</li>
<li><pre><code>       ssl_prefer_server_ciphers  on;
</code></pre>
</li>
<li></li>
<li><pre><code>       location / &#123;
</code></pre>
</li>
<li><pre><code>           root   html;
</code></pre>
</li>
<li><pre><code>           index  index.html index.htm;
</code></pre>
</li>
<li><pre><code>       &#125;
</code></pre>
</li>
<li><pre><code>   &#125;
</code></pre>
3）重新加载配置</li>
<li>   [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload</li>
<li>   #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：</li>
<li>   #[error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)<br>步骤二：客户端验证<br>1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析</li>
<li>   [root@client ~]# vim /etc/hosts</li>
<li>   192.168.4.5    <a target="_blank" rel="noopener" href="http://www.c.com/">www.c.com</a>  <a target="_blank" rel="noopener" href="http://www.a.com/">www.a.com</a>   <a target="_blank" rel="noopener" href="http://www.b.com/">www.b.com</a><br>2）登录192.168.4.10客户端主机进行测试</li>
<li>   [root@client ~]# firefox <a target="_blank" rel="noopener" href="https://www.c.com/">https://www.c.com</a>           </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/nginxday1/" data-id="cl9bbmgj2000smwuqb5nu1rs1" data-title="nginxday1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux补充知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/16/linux%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2022-01-16T13:05:46.000Z" itemprop="datePublished">2022-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/16/linux%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/">linux补充知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关闭selinux ： setenforce  0<br>selinux 三种模式<br>1.enforcing   强制模式   1<br>2.permissive  宽松模式  0<br>3.disabled   关闭模式<br>关闭防火墙：firewall-cmd –set-default-zone=trusted<br>systemctl stop firewalld<br>变量<br>环境变量env<br>set观察所有变量<br>PS1    提示字符的设置<br>列如PS1=’[\u@\h\w\A##]$‘<br>\u目前用户的账号名称。<br>\h<br>\w完整的工作名称<br>\A显示时间，为24小时格式。<br>#执行的第几个命令<br>$ 提示符</p>
<p>export 也是变量的<br>locale 语系变量<br>修改：cat /etc/locale.conf</p>
<p>declare 声明变量类型<br>declare -i sum=10+10 声明整数变量<br> echo ${sum}<br>20<br>declare -x sum  声明环境变量<br>export | grep sum </p>
<p>-a数组，-r不能被更改<br>ulimit  文件大小限制<br>通配符<br>*代表任意个字符<br>？代表一个字符<br>【0-9】，代表0-9<br>^取反</p>
<p>&amp;&amp;与  只有前面正确，才会进行后面的操作<br>|| 或 只有前面错误，才会今后后面操作</p>
<p>cut 主要作用是将同一行的数据进行分解<br>列：echo    ${PATH} | cut   -d ‘:’  -f  3,5</p>
<p>grep 过滤查找 -v取反 -n 显示行号</p>
<p>last 列出目前和过去登入系统用户的相关信息。</p>
<p>sort  排序 -t ‘:’ 分隔符<br>-k 用第几排排序<br>uniq 将重复的列出显示<br>wc计数</p>
<p>字符转换符 tr  -d 删除 -s替换<br>col 将文件里的 tab 换成 空格键<br>join 将相同数据的那行加在一起<br>paste  直接将俩行贴在一起<br>expand 将tab 转换成空格键<br>划分命令split 将大的文件划为小的文件<br>参数代换xargs 产生某个命令的参数 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/16/linux%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/" data-id="cl9bbmgiy000mmwuqgp7gespf" data-title="linux补充知识" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web安全笔记day02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/14/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day02/" class="article-date">
  <time class="dt-published" datetime="2022-01-14T12:05:01.000Z" itemprop="datePublished">2022-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/14/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day02/">web安全笔记day02</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一。数据封装过程<br>应用层     PDU<br>传输层     数据<br>网络层     报文<br>数据链路层    帧<br>物理层      比特<br>（1）封装：<br>数据要通过网络进行传输，要从高层一层一层的向下传输，如果一个主机要传送数据到别的主机，则先把数据装到一个特殊的协议报头中，整个过程叫封装。<br>比如数据在表示层向下传输，先经过传输层封装一个 TCP/UDP 头，再经过网络层封装一个 IP 头，继续向下传输经过数据链路层时再封装一个 MAC 头，最后在物理层转化为比特流进行传输。<br>（2）解封装：<br>封装的逆向过程即为解封装。数据封装成帧后，发到传输介质上，达到目标主机后，每层协议剥掉相应的头部，最后将应用层数据交给应用程序处理。<br>比如比特流在物理层向上传输，先经过数据链路层解封成帧并剥掉 MAC 头，再经过网络层解封成报文并剥掉 IP 头，继续向上传输经过传输层解封成数据并剥掉 TCP/UDP 头，最后传输给应用层。<br>TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 IP 协议、ICMP 协议、TCP 协议、以及 http、ftp、pop3、https 协议等，网络中的计算机都采用这套协议族进行互联。<br>二。协议<br>（1）ping命令<br>ping命令 用来测试主机之间网络的连通性。<br> 执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。<br>网络层的协议有 ICMP、IP 和 ARP(地址解析协议)，<br>传输层的协议有 TCP 和 UDP、<br>应用层的协议有 HTTP、HTTPS、FTP、DNS、SMTP、POP3、Telnet、SSH 和 TFTP 协议。<br>（2）ARP协议<br>在局域网中，当主机或者其他网络设备有数据要发送给另一个主机或者设备的时候，必须要知道对方的 IP 地址或者 MAC 地址，而 ARP 协议就是将 IP 地址转换成 MAC (物理) 地址的协议。</p>
<p>地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送 ARP 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 ARP 缓存；由此攻击者就可以向某一主机发送伪 ARP 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 ARP 欺骗。</p>
<p>ARP报文：ARP 报文分为 ARP 请求报文和 ARP 应答报文<br>（3）ip协议<br>在 TCP/IP 协议中，使用 IP 协议传输数据的包被称为 IP 数据包，每个数据包都有包含 IP 协议规定的内容，这些内容被称为 IP 数据报文或者 IP 数据报，这些 IP 数据报文由首部和数据两部分组成。首部的前一部分为固定长度，共 20 字节，是所有 IP 数据报必须具有的，而另一部分为可选部分，其长度是可变的。<br>（4）ICMP 协议<br>ICMP 协议用于用户在 IP 主机、路由器之间传递控制消息，判断网络是否连通、主机是否可达、路由是否可用等。<br>ICMP 本意是希望对 IP 包无法传输时提供报告，这些差错报告帮助了发送方了解为什么无法传递，网络发送了什么问题，以及确定应用程序的后续操作。<br>ICMP 协议是 IP 协议的一个子协议，ICMP 报文包含在 IP 数据报中，IP 报头在 ICMP 报文的最前面。<br>一个 ICMP 报文至少包括: IP 报头 (至少 20 字节)、ICMP 报头 (至少 8 字节) 和 ICMP 报文 (属于 ICMP 报文的数据部分)，当 IP 报头中的协议字段为 1 时说明这是一个 ICMP 报文。<br>（5）tcp协议<br>TCP 协议是一种面向连接的、可靠的、基于字节流的、全双工的传输层通信协议。TCP 协议是 TCP/IP 体系结构中最主要的传输层协议<br>TCP 三次握手和四次挥手<br>（6）udp协议<br>UDP 协议是一种面向无连接的、 不可靠的、基于报文的传输层通信协议。不需要向 TCP 那样需要服务器监听，也不必等待客户端与服务端建立连接。<br>(7)DNS协议<br>DNS 协议是用来将域名解析到 IP 地址的一种协议，基于 TCP 和 UDP 的协议，端口号为 53，用户到服务器采用 UDP，服务器通信采用 TCP。可以通过 nslookup 命令来查询域名对应的 IP 地址。<br>（8）http协议<br>HTTP 协议是超文本传输协议，是客户端浏览器或者其他程序与 Web 服务器之间的应用层通信协议，通过 HTTP 实现数据在 Internet 上的发送和接收<br>（9）https协议<br>HTTPS 协议基于 HTTP 协议，通过 SSL 或者 TLS 来提供加密处理数据，验证对方身份和保证数据完整性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/14/web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0day02/" data-id="cl9bbmgjf001bmwuqgaxfb4ph" data-title="web安全笔记day02" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web安全day01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/10/web%E5%AE%89%E5%85%A8day01/" class="article-date">
  <time class="dt-published" datetime="2022-01-10T11:24:49.000Z" itemprop="datePublished">2022-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/10/web%E5%AE%89%E5%85%A8day01/">web安全01</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>第一节<br>1.交换机<br>什么是交换机：<br>交换机是用来连接局域网的主要设备<br>交换机能够根据以太网帧中目的地址只能的转发数据，因此交换机工作在数据链路层。<br>交换机工作原理：<br>交换机的转发原理：<br>（1）.初始状态<br>（2）.MAC地址学习<br>（3）.广播位置数据帧<br>（4）.接收方回应<br>（5）.交换机实现单播通信<br>转发，学习，广播，更新<br>交换机里面有 ARP (地址解析协议) 缓存表：根据 IP 地址获取物理地址的 TCP/IP 协议。<br>里面存放了 IP 地址、MAC 地址。主机发送信息时将包含 IP 地址的 ARP 请求广播到局域网上的所有主机，并接受返回消息，以此来确定目标的物理地址，收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一段时间，下次请求时直接查询 ARP 表以节约资源<br>2.路由器<br>路由器里面由路由表：包含三个元素，目的地址，掩码，下一跳地址，功能是路由寻址，对不同的网络之间的数据包进行存储、分组转发处理。<br>是连接两个或多个网络的硬件设备，在网络间起到网关的作用，分析不同类型网络传来的数据包的目的地址，把非 TCP/IP 网络的地址转换成 TCP/IP 地址，或者反之；<br>再根据选定的路由算法把各数据包按最佳路线传送到指定位置。<br>路由器原理及配置：<br>什么是路由器：</p>
<ol>
<li>将数据包从一个网络发送到另一个网络<br>(1)    需要依靠路由器来完成<br>(2)    路由器只关心网络的状态，决定最佳路径</li>
<li>路由器可以根据路由表选择最佳路径<br>(1)    每个路由器都维护这一张路由表，这是路由器转发数据包的关键<br>(2)    每条路由表记录指明了：到达某个子网或主机应从路由器的那个物理接口发送，通过此接口可达该路径的下一个路由器的地址（或直接相连网络中的目标主机地址）</li>
</ol>
<p>如何获得路由表：</p>
<ol>
<li>静态、默认路由<br>(1)    由管理员在路由器上手工指定<br>(2)    适合分支机构、家具办公等小型网络</li>
<li>动态路由<br>(1)    根据网络拓扑或流量变化，由路由器通过路由协议自动设置<br>(2)    适合ISP服务厂商、广域网、园区网等大型网络<br>静态路由：</li>
<li>主要特点：<br>(1)    有管理员手工配置，为单向条目<br>(2)    通信双方的边缘路由器都需要指定，否则会导致数据包有去无回<br>路由器和交换机的对比</li>
</ol>
<p>*路由器工作在网络层<br>*交换机工作在数据链路层<br>3.访问控制列表 ACL (包过滤)<br>访问控制列表<br>应用于路由器接口的指令列表，用于指定哪些数据包可以接收转发，那些数据包需要拒绝<br>acl的作用<br>（1）提供网络访问的基本安全手段<br>（2）可以控制数据流量<br>（3)控制通信量<br>4.设备与层对应的关系<br>应用层               计算机/防火墙<br>传输层               防火墙<br>网络层               路由器<br>数据链路层        交换机<br>物理层               网卡<br>物理层：传输比特流数据。将 1、0 转化为电流强弱来进行传输，达到目的地之后在转化成 1、0。主要定义物理设备标准，如网线的接口类型，各种传输介质的传输速率。<br>数据链路层：传输数据帧。接收来自物理层的比特流的数据，通过差错控制等方法传输到网络层，也接收来自上层的数据，封装成数据帧的形式转发到物理层，以便提供可靠的数据传输。主要功能为建立逻辑连接、进行硬件地址寻址、差错校验等功能。<br>网络层：传输数据包。主要是进行逻辑地址寻址，实现不同网络之间的物理选择。<br>传输层：传输报文。向用户提供可靠的端到端的差错控制和流量控制，保证报文的正确传输。主要功能为定义传输数据的协议端口号，以及流量控制和差错校验。<br>会话层：负责建立、管理和终止表示层实体之间的对话。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密。<br>应用层：提供用户接口，使得用户能够与网络进行交互式联系，实现各种服务，完成和实现用户请求的各种服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/10/web%E5%AE%89%E5%85%A8day01/" data-id="cl9bbmgje001amwuqasqk234z" data-title="web安全01" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux应急实战" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/04/linux%E5%BA%94%E6%80%A5%E5%AE%9E%E6%88%98/" class="article-date">
  <time class="dt-published" datetime="2022-01-04T01:42:44.000Z" itemprop="datePublished">2022-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/04/linux%E5%BA%94%E6%80%A5%E5%AE%9E%E6%88%98/">linux应急实战</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code>                                                           Linux入侵排查
</code></pre>
<p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系<br>统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回<br>或减少经济损失。<br>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些Linux服务器入侵排查的思路。<br>1.入侵思路排察<br>1.1账户安全<br>（1）./etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>account:password:UID:GID:GECOS:directory:shell<br>用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell<br>注意：无密码只允许本机登陆，远程不允许登陆<br>（2）、影子文件/etc/shadow<br>root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV<br>9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::<br>用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之<br>后的宽限天数：账号失效时间：保留</p>
<p>用户组的所有信息都存放在/etc/group文件中<br>组名:口令:组标识号:组内用户列表 </p>
<p>命令： who 查看当前登录用户（tty本地登陆 pts远程登录）<br>            w 查看系统信息，想知道某一时刻用户的行为<br>           uptime 查看登陆多久、多少用户，负载<br>入侵排查<br>1.查询特权用户（uid为0）<br> awk -F: ‘$3==0{print $1}’   /etc/passwd<br>2、查询可以远程登录的帐号信息<br> awk   ‘/$1|$6/{print $1}’   /etc/shadow<br>3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限<br> more /etc/sudoers | grep -v “^#|^$” | grep “ALL=(ALL)”<br>4、禁用或删除多余及可疑的帐号<br>usermod -L user 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头<br>userdel user 删除user用户<br>userdel -r user 将删除user用户，并且将/home目录下的user目录一并删除</p>
<p>1.2历史命令<br>通过.bash_history查看帐号执行过的系统命令<br>1、root的历史命令<br>histroy<br>2、打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令<br>为历史的命令增加登录的IP地址、执行命令时间等信息：<br>1）保存1万条命令<br>sed -i ‘s/^HISTSIZE=1000/HISTSIZE=10000/g’ /etc/profile<br>2）在/etc/profile的文件尾部添加如下行数配置信息：<br>######jiagu history xianshi#########<br>USER_IP=<code>who -u am i 2&gt;/dev/null | awk &#39;&#123;print $NF&#125;&#39; | sed -e &#39;s/[()]//g&#39;</code><br>if [ “$USER_IP” = “” ]<br>then<br>USER_IP=<code>hostname</code><br>fi<br>export HISTTIMEFORMAT=”%F %T $USER_IP <code>whoami</code> “<br>shopt -s histappend<br>export PROMPT_COMMAND=”history -a”<br>######### jiagu history xianshi ##########<br>3）source /etc/profile让配置生效<br>生成效果： 1 2018-07-10 19:45:39 192.168.204.1 root source /etc/profile<br>3、历史操作命令的清除：history -c<br>但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录。</p>
<p>入侵排察<br>进入用户目录下<br>cat .bash_history &gt;&gt; history.txt<br>1.3检查异常端口<br>PID 代表进程标识号。<br>使用netstat 网络连接命令，分析可疑端口、IP、PID<br>netstat -antlp|more<br>查看下pid所对应的进程文件路径，<br>运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号）<br>1.4检查异常进程<br>使用ps  aux   |  grep pid  分析进程<br>1.5检查开机启动项<br>运行级别<br>0         关机<br>1     单机模式<br>2     不安全的命令行模式<br>3      安全的命令行模式<br>4      系统保留<br>5      图形模式<br>6      重启动<br>查看运行级别命令 runlevel<br>系统默认允许级别<br>vi   /etc/inittab<br>id=3：initdefault 系统开机后直接进入哪个运行级别<br>开机启动配置文件<br>/etc/rc.local<br>/etc/rc.d/rc[0<del>6].d<br>例子:当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链<br>接即可<br>root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh<br>此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行<br>级别加载时需要关闭的。<br>入侵排查：<br>启动项文件： more /etc/rc.local /etc/rc.d/rc[0</del>6].d ls -l /etc/rc.d/rc3.d/<br>1.6、利用crontab创建计划任务<br>基本命令<br>-l  列出某个用户cron服务的详细内容<br>-r  删除每个用户cront任务<br>-e   使用编译器编译当前的crontab文件。<br>crontab -e 使用编辑器编辑当前的crontab文件<br>如：*/1 * * * * echo “hello world” &gt;&gt; /tmp/test.txt 每分钟写入文件<br>入侵排查<br>重点关注以下目录中是否存在恶意脚本<br>/var/spool/cron/*<br>/etc/crontab<br>/etc/cron.d/*<br>/etc/cron.daily/*<br>/etc/cron.hourly/*<br>/etc/cron.monthly/*<br>/etc/cron.weekly/<br>/etc/anacrontab<br>/var/spool/anacron/*<br>小技巧：<br>more /etc/cron.daily/* 查看目录下所有文件<br>1.7检查服务<br>服务自启动<br>第一种修改方法：<br>chkconfig [–level 运行级别] [独立服务名] [on|off]<br>chkconfig –level 2345 httpd on 开启自启动<br>chkconfig httpd on （默认level是2345）<br>Linux chkconfig 命令用于检查，设置系统的各种服务。<br>–add 　增加所指定的系统服务，让 chkconfig 指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。<br>–del 　删除所指定的系统服务，不再由 chkconfig 指令管理，并同时在系统启动的叙述文件内删除相关数据。<br>–level&lt;等级代号&gt; 　指定读系统服务要在哪一个执行等级中开启或关毕。<br>列出chkconfig 所知道的所有命令。</p>
<h1 id="chkconfig-–list"><a href="#chkconfig-–list" class="headerlink" title="chkconfig –list"></a>chkconfig –list</h1><p>第二种修改方法：<br>修改/etc/re.d/rc.local 文件<br>加入 /etc/init.d/httpd start<br>第三种修改方法：<br>使用ntsysv命令管理自启动，可以管理独立服务和xinetd服务。<br>日志默认存放位置：/var/log/<br>查看日志配置情况：more /etc/rsyslog.conf</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/04/linux%E5%BA%94%E6%80%A5%E5%AE%9E%E6%88%98/" data-id="cl9bbmgix000kmwuqdryl5klq" data-title="linux应急实战" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linuxday12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/04/linuxday12/" class="article-date">
  <time class="dt-published" datetime="2022-01-04T01:11:04.000Z" itemprop="datePublished">2022-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/04/linuxday12/">linuxday12</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>第3篇：常见的Webshell查杀工具<br>目前市场上的很多主机安全产品也都提供这种WebShell<br>检测能力，比如阿里云、青藤云、safedog等<br>1、diff命令<br>在linux中，我们经常使用diff来比较两个文本文件的差异。同样，我们可以通过一行命令快速找出两个项目文件的差<br>异。<br>diff -c -a -r cms1 cms2<br>2、版本控制工具<br>版本控制工具，比如说git，重新上传代码到git，add+commit+push，然后打开项目，点击commits，在历史提交版本<br>里面，查看文件更改内容，很容易就可以发现代码被篡改的地方了。<br>3、文件对比工具<br>关键词：代码对比工具，你会找到很多好用的工具，这里我们推荐两款效果还不错的工具，Beyond Compare和<br>WinMerge。<br>第二章：日志分析篇<br>Linux日志分析<br>日志默认存放位置：/var/log/<br>查看日志配置情况：more /etc/rsyslog.conf<br>比较重要的几个日志： 登录失败记录：/var/log/btmp //lastb 最后一次登录：/var/log/lastlog //lastlog 登录成功记录:<br>/var/log/wtmp //last 登录日志记录：/var/log/secure<br>日志分析技巧<br>A、常用的shell命令<br>Linux下常用的shell命令如：find、grep 、egrep、awk、sed</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/04/linuxday12/" data-id="cl9bbmgir000bmwuqb37v9y87" data-title="linuxday12" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/">面试总结1</a>
          </li>
        
          <li>
            <a href="/2022/10/13/k8s%E9%83%A8%E7%BD%B2/">k8s部署</a>
          </li>
        
          <li>
            <a href="/2022/10/13/docker%E9%83%A8%E7%BD%B2/">docker部署</a>
          </li>
        
          <li>
            <a href="/2022/10/10/zabbix/">zabbix</a>
          </li>
        
          <li>
            <a href="/2022/10/08/mysql%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1/">mysql主从服务</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>